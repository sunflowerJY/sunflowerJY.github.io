<!DOCTYPE html>



  


<html class="theme-next pisces use-motion" lang="zh-hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">


  
  
    
    
  <script src="/lib/pace/pace.min.js?v=1.0.2"></script>
  <link href="/lib/pace/pace-theme-flash.min.css?v=1.0.2" rel="stylesheet">







<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-sunflower.ico?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-sunflower.ico?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Leetcode," />










<meta name="keywords" content="Leetcode">
<meta property="og:type" content="article">
<meta property="og:title" content="LeetCode作战计划">
<meta property="og:url" content="http://yoursite.com/2018/12/07/LeetCode作战计划/index.html">
<meta property="og:site_name" content="向日葵的自留地">
<meta property="og:locale" content="zh-hans">
<meta property="og:image" content="https://res.cloudinary.com/sunflower/image/upload/v1544100034/Blog/20160607102525smREGHipDCNYAg2v.jpg">
<meta property="og:image" content="https://res.cloudinary.com/sunflower/image/upload/v1543888864/Blog/%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E6%9F%A5%E6%89%BE.png">
<meta property="og:image" content="https://res.cloudinary.com/sunflower/image/upload/v1543890434/Blog/%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E6%8F%92%E5%85%A5.png">
<meta property="og:image" content="https://res.cloudinary.com/sunflower/image/upload/v1543921452/Blog/BST_delete_1.png">
<meta property="og:image" content="https://res.cloudinary.com/sunflower/image/upload/v1543921625/Blog/BST_delete_1_.png">
<meta property="og:image" content="https://res.cloudinary.com/sunflower/image/upload/v1543922264/Blog/BST_delete_2.png">
<meta property="og:image" content="https://res.cloudinary.com/sunflower/image/upload/v1543922450/Blog/BST_delete_2_.png">
<meta property="og:updated_time" content="2019-01-22T14:50:31.678Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="LeetCode作战计划">
<meta name="twitter:image" content="https://res.cloudinary.com/sunflower/image/upload/v1544100034/Blog/20160607102525smREGHipDCNYAg2v.jpg">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Pisces',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: 'Author'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/2018/12/07/LeetCode作战计划/"/>





  <title>LeetCode作战计划 | 向日葵的自留地</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-hans">
	
  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">向日葵的自留地</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            Home
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            Tags
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            Categories
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            Archives
          </a>
        </li>
      

      
        <li class="menu-item menu-item-search">
          
            <a href="javascript:;" class="popup-trigger">
          
            
              <i class="menu-item-icon fa fa-search fa-fw"></i> <br />
            
            Search
          </a>
        </li>
      
    </ul>
  

  
    <div class="site-search">
      
  <div class="popup search-popup local-search-popup">
  <div class="local-search-header clearfix">
    <span class="search-icon">
      <i class="fa fa-search"></i>
    </span>
    <span class="popup-btn-close">
      <i class="fa fa-times-circle"></i>
    </span>
    <div class="local-search-input-wrapper">
      <input autocomplete="off"
             placeholder="Searching..." spellcheck="false"
             type="text" id="local-search-input">
    </div>
  </div>
  <div id="local-search-result"></div>
</div>



    </div>
  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/12/07/LeetCode作战计划/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="sunflowerJY">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="向日葵的自留地">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">LeetCode作战计划</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-12-07T16:24:00+08:00">
                2018-12-07
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/IT应聘/" itemprop="url" rel="index">
                    <span itemprop="name">IT应聘</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2018/12/07/LeetCode作战计划/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count gitment-comments-count" data-xid="/2018/12/07/LeetCode作战计划/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          
          

          
            <span class="post-meta-divider">|</span>
            <span class="page-pv"><i class="fa fa-file-o"></i> 浏览
            <span class="busuanzi-value" id="busuanzi_value_page_pv" ></span>次
            </span>
          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <img src="https://res.cloudinary.com/sunflower/image/upload/v1544100034/Blog/20160607102525smREGHipDCNYAg2v.jpg" width="400" align="center">
<a id="more"></a>
<h1 id="规划"><a class="header-anchor" href="#规划"></a>规划</h1>
<p>论文初稿完成，目前处于投递期刊状态😐看看各大公司招聘预告😱7月中旬开始校招，想想真是没时间喘息啊🙅是时候好好规划下了  <br>
<strong>规划Version1</strong>  <br>
预期4周的时间完成LeetCode绝大部分题型，熟悉总结解题规律，到7月中旬就可以尝试去参加笔试面试了😝</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">06/19--06/24: 数组(10)、动态规划(10)</span><br><span class="line">06/25--07/01: 字符串(10)、数学(10)</span><br><span class="line">07/02--07/08: 哈希表(10)、树(10)</span><br><span class="line">07/09--07/15: 深度优先搜索(10)、二分查找(5)</span><br></pre></td></tr></table></figure>
<p>目前的计划表就是这样，后期看情况调整，每周日来此汇报进度，并针对每种题型单独写博客整理解题思路。</p>
<hr>
<p>按照上面的计划执行LeetCode一周后，每周做两组题型对我来说，难度颇大，没办法按时完成任务😔参考网上意见后决定暂时放弃LeetCode路线，LeetCode适合原本就是编程大神的人或者工作过一段时间的，并不适合小白类型的选手😲  <br>
决定换牛客网了，补充下基础知识，再去做算法题。牛客网有数据结构、算法等基础知识相关的选择题，做一做选择题复习下基础知识，还有招聘真题，牛客网应该更适合我循序渐进得准备笔试。</p>
<hr>
<p><strong>规划Version2</strong><br>
2018/6/25</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">06/25--07/01: [数据结构]树、栈；[算法]排序(5)</span><br><span class="line">07/02--07/08: [数据结构]图、链表；[算法]复杂度(5)</span><br><span class="line">07/09--07/15: [数据结构]哈希、队列；[算法]查找(5)</span><br></pre></td></tr></table></figure>
<hr>
<p><strong>规划Version3</strong><br>
感觉在写这第三个版本计划时，就是分分钟打脸的写照😑</p>
<p>之前规划7月中旬出去找实习，却被突然的中文核心等待一个月退稿而落幕。整个7月都在修改翻译论文投会议，也不知道有没有机会中。不管结果怎么样，小论文在研究生期间就这样了，也算是尽力了吧，整整从18年1月到7月，除去寒假过年，半年时间都在做论文这件事情。</p>
<p>目前找工作的进度最快也要到月底了，2周的时间，集中火力做前200道LeetCode中easy题目，快点出去面试，积攒面经，希望努力能找个大公司工作吧</p>
<hr>
<p><strong>规划Version4</strong>  <br>
永远有更打脸的😂整个秋招结束了仍然不会做几道算法题也是很失败了，现在准备抓住冬天的尾巴，再来准备最后一波春招😉</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">每天两道题目，这次每道题都做一个详细的小结，再归并到总结当中去。</span><br></pre></td></tr></table></figure>
<h1 id="数据结构"><a class="header-anchor" href="#数据结构"></a>数据结构</h1>
<table>
<thead>
<tr>
<th>划分依据</th>
<th>数据类型</th>
<th>举例</th>
</tr>
</thead>
<tbody>
<tr>
<td></td>
<td>集 合</td>
<td>无逻辑关系</td>
</tr>
<tr>
<td><strong>逻辑</strong></td>
<td>线性结构</td>
<td>一维数组、队列、栈</td>
</tr>
<tr>
<td></td>
<td>非线性结构</td>
<td>树、图、网</td>
</tr>
<tr>
<td></td>
<td>顺序存储结构</td>
<td></td>
</tr>
<tr>
<td><strong>存储</strong></td>
<td>链式存储结构</td>
<td></td>
</tr>
<tr>
<td></td>
<td>索引存储结构</td>
<td></td>
</tr>
<tr>
<td></td>
<td>散列存储结构</td>
<td></td>
</tr>
</tbody>
</table>
<h2 id="数组"><a class="header-anchor" href="#数组"></a>数组</h2>
<p>日期：2018/06/22 16:15<br>
一共13道题目，每道题目中往往结合固定几种方法解题，规律性较强，总结题目、标签对应如下：</p>
<table>
<thead>
<tr>
<th>题号</th>
<th>数组</th>
<th>哈希表</th>
<th>双指针</th>
<th>二分查找</th>
<th>分治算法</th>
</tr>
</thead>
<tbody>
<tr>
<td>1</td>
<td>★</td>
<td>★</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>4</td>
<td>★</td>
<td></td>
<td></td>
<td>★</td>
<td>★</td>
</tr>
<tr>
<td>11</td>
<td>★</td>
<td></td>
<td>★</td>
<td></td>
<td></td>
</tr>
<tr>
<td>15</td>
<td>★</td>
<td></td>
<td>★</td>
<td></td>
<td></td>
</tr>
<tr>
<td>16</td>
<td>★</td>
<td></td>
<td>★</td>
<td></td>
<td></td>
</tr>
<tr>
<td>18</td>
<td>★</td>
<td>★</td>
<td>★</td>
<td></td>
<td></td>
</tr>
<tr>
<td>26</td>
<td>★</td>
<td></td>
<td>★</td>
<td></td>
<td></td>
</tr>
<tr>
<td>283</td>
<td>★</td>
<td></td>
<td>★</td>
<td></td>
<td></td>
</tr>
<tr>
<td>448</td>
<td>★</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>485</td>
<td>★</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>561</td>
<td>★</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>566</td>
<td>★</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>766</td>
<td>★</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody>
</table>
<p>由此可以看出，数组类型的题目常与双指针、哈希表方法相结合。</p>
<hr>
<p>统计完成情况：<br>
13题中通过5题，正确率只有38%😭其中6道双指针题目，只会其中1题，双指针类型题目错误率占比38%😶也就是说数组题目中基本碰到双指针就基本都不会😶😶😶</p>
<table>
<thead>
<tr>
<th>题号</th>
<th>完成情况</th>
</tr>
</thead>
<tbody>
<tr>
<td>1</td>
<td>★</td>
</tr>
<tr>
<td>4</td>
<td>★</td>
</tr>
<tr>
<td>11</td>
<td>题目旨意模糊，答案为返回最大容量</td>
</tr>
<tr>
<td>15</td>
<td>不会去重</td>
</tr>
<tr>
<td>16</td>
<td>无法将想法转换为编程语言</td>
</tr>
<tr>
<td>18</td>
<td>复杂</td>
</tr>
<tr>
<td>26</td>
<td>题目旨意模糊，不需要删除重复项，只要没有引用到即可</td>
</tr>
<tr>
<td>283</td>
<td>★</td>
</tr>
<tr>
<td>448</td>
<td>★</td>
</tr>
<tr>
<td>485</td>
<td>思路</td>
</tr>
<tr>
<td>561</td>
<td>★</td>
</tr>
<tr>
<td>566</td>
<td>特别函数</td>
</tr>
<tr>
<td>766</td>
<td>思路</td>
</tr>
</tbody>
</table>
<p><strong>特殊函数</strong><br>
第566题用到的两个函数，平常用的比较少：  <br>
1.降低数组维度</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sum([[1,2], [3,4]], [])</span><br></pre></td></tr></table></figure>
<p>输出：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[1,2,3,4]</span><br></pre></td></tr></table></figure>
<p>2.压缩函数zip()<br>
<strong>常规考虑</strong><br>
1.对部分数组题目进行排序操作，可以减少程序运行时间，降低复杂度。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nums.sort()</span><br></pre></td></tr></table></figure>
<h2 id="树"><a class="header-anchor" href="#树"></a>树</h2>
<p>日期：2018/06/27 20:57   <br>
转战牛客网后的第一次总结，牛客网上可以更好地巩固复习基础知识，选择题的正确率在55%左右。</p>
<h3 id="基础知识"><a class="header-anchor" href="#基础知识"></a>基础知识</h3>
<p>树形结构属于非线性结构、层次结构，可以顺序存储或者链式存储，操作有遍历和查找。属于“一对多”的数据类型。</p>
<p>森林指m棵互不相交的树的集合。</p>
<p>树中的关键概念：</p>
<ul>
<li>
<p>有序树/无序树<br>
如果将树中结点的各子树看成从左至右是有次序的（即不能互换），则称该树为有序树，否则称为无序树。</p>
</li>
<li>
<p>结点的层次<br>
从根结点开始计算起，根为第一层，根的孩子为第二层，依次类推。树中结点的最大层次称为树的深度（Depth）或高度。</p>
</li>
<li>
<p>度  <br>
即结点的子树个数</p>
<ul>
<li>度为0的结点为叶子结点</li>
<li>度为1的结点有1个分支</li>
<li>度为2的结点有2个分支</li>
</ul>
</li>
<li>
<p>二叉树中不存在度大于2的结点</p>
</li>
<li>
<p>总结点数总比总度数多1</p>
</li>
</ul>
<h3 id="二叉树"><a class="header-anchor" href="#二叉树"></a>二叉树</h3>
<p>二叉树（Binary Tree）的特点是每个结点至多具有两棵子树（即在二叉树中不存在度大于2的结点），并且子树之间有左右之分。</p>
<p>二叉树的性质：</p>
<ul>
<li>在二叉树的第i层上至多有2i-1个结点（i≥1）。</li>
<li>深度为k的二叉树至多有2k-1个结点（k≥1）。</li>
<li>对任何一棵二叉树，如果其终端结点数为n0，度为2的结点数为n2，则n0=n2+1。</li>
</ul>
<p>分类：</p>
<ul>
<li>满二叉树</li>
<li>完全二叉树  <br>
叶子结点只能出现在最下层和次下层，且最下层的叶子结点集中在树的左部。</li>
<li><a href="#head"><code>哈夫曼树(最优二叉树)</code></a></li>
</ul>
<p>二叉树的度数与结点数：<br>
假设总度数：k，叶子结点、度为1和度为2的结点个数分别即为$n_0,n_1,n_2$  <br>
度：$k = n_2 \times 2 + n_1$  <br>
结点：$k+1 = n_2 + n_1 + n_0$  <br>
综合二式：$n_0 = n_2 + 1$</p>
<p>二叉树的高度与结点数：<br>
高度为h的二叉树，每层最多有$2^{h-1}$个结点。  <br>
对于高度为h满二叉树，其总结点数$2^h-1$。  <br>
具有N个结点的完全二叉树的高度h为$(\log_2 N)+1$</p>
<h4 id="二叉查找树-左-中-右"><a class="header-anchor" href="#二叉查找树-左-中-右"></a>二叉查找树（左&lt;中&lt;右）</h4>
<ul>
<li>若它的左子树不为空，则左子树上所有结点的值均小于它的根结点的值；</li>
<li>若它的右子树不为空，则右子树上所有结点的值均大于它的根结点的值；</li>
<li>它的左、右子树也分别为二叉查找树。</li>
</ul>
<p>二叉查找树的基本操作是<strong>查找，插入，删除，遍历</strong>。</p>
<ul>
<li>查找<br>
查找某个节点时，先从根节点入手，如果该元素值小于根节点，则转向左子节点，否则转向右子节点，以此类推，直到找到该节点，或者到最后一个叶子节点依然没有找到，则证明树中没有该节点。<br>
<img src="https://res.cloudinary.com/sunflower/image/upload/v1543888864/Blog/%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E6%9F%A5%E6%89%BE.png" width="350" align="center"></li>
<li>插入<br>
插入一个新节点首先要确定插入的位置，关键思路是确定新节点父节点所在的位置。<br>
<img src="https://res.cloudinary.com/sunflower/image/upload/v1543890434/Blog/%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E6%8F%92%E5%85%A5.png" width="350" align="center"></li>
<li>删除<br>
删除BST中的一个节点是最麻烦的操作，总结一下大概下面两种方法：</li>
<li>当删除点没有左孩子  <br>
只需要将该节点的父节点和当前节点的右孩子相连即可<br>
<img src="https://res.cloudinary.com/sunflower/image/upload/v1543921452/Blog/BST_delete_1.png" width="350" align="center"><br>
删除节点10：  <br>
<img src="https://res.cloudinary.com/sunflower/image/upload/v1543921625/Blog/BST_delete_1_.png" width="350" align="center"></li>
<li>删除点有左孩子<br>
先找到当前节点的左子树的最右节点，因为一个节点的左子树的最右节点也比右子树的最左节点小，把最右节点复制给删除点，然后删除最右节点。<br>
<img src="https://res.cloudinary.com/sunflower/image/upload/v1543922264/Blog/BST_delete_2.png" width="350" align="center"><br>
删除节点20：  <br>
<img src="https://res.cloudinary.com/sunflower/image/upload/v1543922450/Blog/BST_delete_2_.png" width="350" align="center"></li>
</ul>
<h4 id="哈夫曼树-最优二叉树"><a class="header-anchor" href="#哈夫曼树-最优二叉树"></a>哈夫曼树(最优二叉树)</h4>
<p>带权路径最短的二叉树。$$WPL=\sum_{i=1}^{n} {W_i}{I_i}$$其中，二叉树共有n个叶子结点，$W_i$:第i个叶子结点的权，$I_i$:根到第i个叶子结点的路径长度。  <br>
<strong>哈夫曼编码</strong>  <br>
需要编码的字符集合为{$C_1,C_2,…,C_n$}，各个字符在电文出现的次数集合为{$w_1,w_2,…,w_n$}，用$C_1,C_2,…,C_n$作为叶子，$w_1,w_2,…,w_n$作为各叶子的权构造一棵哈夫曼树。  <br>
哈夫曼树中，左分支上标0，右分支上标1，$C_i$的编码顺序为从根到该叶子结点$C_i$的顺序。</p>
<h3 id="二叉树的遍历"><a class="header-anchor" href="#二叉树的遍历"></a>二叉树的遍历</h3>
<table>
<thead>
<tr>
<th>遍历</th>
<th>顺序</th>
</tr>
</thead>
<tbody>
<tr>
<td>先序</td>
<td>根→左子树→右子树</td>
</tr>
<tr>
<td>中序</td>
<td>左子树→根→右子树</td>
</tr>
<tr>
<td>后序</td>
<td>左子树→右子树→根</td>
</tr>
<tr>
<td>层次</td>
<td>从上到下，从左到右</td>
</tr>
</tbody>
</table>
<p>遍历经常出的选择题型：</p>
<ul>
<li>已知两种遍历顺序，例如中序和后序，要求确定一棵二叉树。  <br>
首先后序可以确定根结点，结合中序，区分左子树和右子树。再分别针对左子树和右子树，集合中序和后序，慢慢还原一棵二叉树。</li>
</ul>
<p>编程的题目还没有得到有效训练，LeetCode由于对树有内部编码，与本地自己实现的编程有差异。<a id="head"></a></p>
<h3 id="几种转换"><a class="header-anchor" href="#几种转换"></a>几种转换</h3>
<ul>
<li>
<p>树转换为二叉树  <br>
由于普通的树是无序的，将其转换为二叉树的步骤：</p>
<ul>
<li>加线：所有兄弟结点之间加一条线</li>
<li>抹线：对树中的每一个结点，只保留它与第1个孩子结点之间的连线，删除它与其它孩子结点的连线</li>
<li>旋转：把虚线改为实线从水平方向向下旋转45°形成二叉树。</li>
</ul>
</li>
<li>
<p>森林转换为二叉树  <br>
森林由若干棵树组成。</p>
<ul>
<li>先把每棵树转换为二叉树</li>
<li>第一棵二叉树不动，从第二棵二叉树开始，依次把后一棵二叉树的根结点作为前一棵二叉树的根结点的右孩子结点，用线连接起来。当所有的二叉树连起来后得到的二叉树就是由森林转换得到的。</li>
</ul>
</li>
</ul>
<h2 id="栈"><a class="header-anchor" href="#栈"></a>栈</h2>
<p>日期：2018/07/03 23:00</p>
<h3 id="基础知识-v2"><a class="header-anchor" href="#基础知识-v2"></a>基础知识</h3>
<p>栈和队列都是特殊的线性表，只能有部分操作的线性表。  <br>
特点：插入和删除操作都在线性表的一端(栈顶)进行，即按“后进先出”的规则进行操作。  <br>
top指针永远指向栈顶：</p>
<ul>
<li>空栈：top=-1</li>
<li>满栈：top=n(n为数组大小)</li>
<li>每压入1个元素进栈，则指针+1</li>
</ul>
<h3 id="存储"><a class="header-anchor" href="#存储"></a>存储</h3>
<ul>
<li>顺序栈  <br>
必须预先分配固定大小内存空间。<br>
静态分配内存容易出现浪费空间或者上溢的情况。</li>
<li>链栈  <br>
动态结点分配消除存储空间上的限制，避免“栈上溢”错误。</li>
</ul>
<h3 id="出栈顺序"><a class="header-anchor" href="#出栈顺序"></a>出栈顺序</h3>
<p>入栈顺序:ABCDEF，如果没有特别指明，可能指示：  <br>
A入栈，A出栈，B入栈，B出栈等</p>
<h3 id="前缀表达式"><a class="header-anchor" href="#前缀表达式"></a>前缀表达式</h3>
<p>前缀表达式的计算机求值特点：</p>
<ul>
<li>从右至左扫描表达式</li>
<li>遇到数字时，将数字压入堆栈</li>
<li>遇到运算符时，弹出栈顶的两个数，用运算符对它们做相应的计算，并将结果入栈</li>
<li>重复上述过程直至表达式最左端</li>
<li>最后运算得出的值即为表达式的结果(中缀结果)</li>
</ul>
<h3 id="汉诺塔-hanoi"><a class="header-anchor" href="#汉诺塔-hanoi"></a>汉诺塔(Hanoi)</h3>
<p>涉及递归与栈的知识。  <br>
题目：4个圆盘的Hanoi塔,总的移动次数为多少？<br>
设f(n)为n个圆盘的hanoi塔总的移动次数，  <br>
其递推方程为f(n)=f(n-1)+1+ f(n-1)=2*f(n-1)+1。<br>
理解就是先把上面n-1个圆盘移到第二个柱子上(共f(n-1)步），<br>
再把最后一个圆盘移到第三个柱子(共1步），<br>
再把第二柱子上的圆盘移动到第三个柱子上（共f(n-1)步）。<br>
而f（1）=1；于是f(2)=3,f(3)=7,f(4)=15。<br>
进一步，根据递推方程其实可以得出f(n) = 2^n - 1。</p>
<h3 id="复杂度"><a class="header-anchor" href="#复杂度"></a>复杂度</h3>
<ul>
<li>时间复杂度<br>
用栈顶指针表示栈顶，栈的插入和删除操作均在栈顶进行。<br>
因此对于顺序存储和链式存储的栈，进行插入和删除运算的时间复杂度均为O(1)。</li>
<li>空间复杂度</li>
</ul>
<h3 id="卡特兰数"><a class="header-anchor" href="#卡特兰数"></a>卡特兰数</h3>
<p>题目：若一序列的进栈顺序为A,B,C,D,E,问存在多少种可能的出栈序列？  <br>
$$f(n)=\frac{C_{2n}^n}{n+1}$$<br>
如上题，答案应为42。</p>
<h2 id="哈希"><a class="header-anchor" href="#哈希"></a>哈希</h2>
<p>日期：2018/08/06 16:04</p>
<h3 id="基本知识"><a class="header-anchor" href="#基本知识"></a>基本知识</h3>
<p>哈希表就是一种以 键-值(key-indexed) 存储数据的结构，输入待查找的值即key，即可查找到其对应的值。</p>
<p>像python中的字典就是基于哈希表实现的。</p>
<ol>
<li>使用哈希函数将被查找的键转换为数组的索引。在理想的情况下，不同的键会被转换为不同的索引值，但是在有些情况下我们需要处理多个键被哈希到同一个索引值的情况。所以哈希查找的第二个步骤就是处理冲突<br>
处理哈希碰撞冲突。</li>
<li>有很多处理哈希碰撞冲突的方法，本文后面会介绍拉链法和线性探测法。</li>
</ol>
<p>哈希表是一个在时间和空间上做出权衡的经典例子。<br>
如果没有内存限制，那么可以直接将键作为数组的索引。那么所有的查找时间复杂度为O(1)；<br>
如果没有时间限制，那么我们可以使用无序数组并进行顺序查找，这样只需要很少的内存。<br>
哈希表使用了适度的时间和空间来在这两个极端之间找到了平衡。只需要调整哈希函数算法即可在时间和空间上做出取舍。</p>
<h3 id="哈希函数"><a class="header-anchor" href="#哈希函数"></a>哈希函数</h3>
<p>哈希查找第一步就是使用哈希函数将键映射成索引。这种映射函数就是哈希函数。</p>
<p>哈希函数需要易于计算并且能够均匀分布所有键。</p>
<p>比如举个简单的例子，使用手机号码后三位就比前三位作为key更好，因为前三位手机号码的重复率很高。再比如使用身份证号码出生年月位数要比使用前几位数要更好。</p>
<p>在实际中，我们的键并不都是数字，有可能是字符串，还有可能是几个值的组合等，所以我们需要实现自己的哈希函数。</p>
<ul>
<li>直接定址法<br>
直接定址法的优点很明显，就是它不会产生重复的hash值。但由于它与键值本身有关系，所以当键值分布很散的时候，会浪费大量的存储空间。所以一般是不会用到直接定址法的。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hash(k)= a*k+b</span><br></pre></td></tr></table></figure>
<ul>
<li></li>
</ul>
<h3 id="避免哈希冲突"><a class="header-anchor" href="#避免哈希冲突"></a>避免哈希冲突</h3>
<p>定义一个hash函数<code>hash(k)=k mod 10</code>，假设key:[15,1,24,32,55,64,42,93,82,76]</p>
<table>
<thead>
<tr>
<th>0</th>
<th>1</th>
<th>2</th>
<th>3</th>
<th>4</th>
<th>5</th>
<th>6</th>
<th>7</th>
<th>8</th>
<th>9</th>
</tr>
</thead>
<tbody>
<tr>
<td></td>
<td>1</td>
<td>32</td>
<td>93</td>
<td>24</td>
<td>15</td>
<td>76</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td>42</td>
<td></td>
<td>64</td>
<td>55</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td>82</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody>
</table>
<ul>
<li>开放定址法<br>
$$hash_{i}=(hash(key)+d_{i}) mod m, i=1,2,…,k(k \leq m-1)$$<br>
其中，<code>hash(key)</code>是哈希函数，<code>di</code>是增量序列，<code>i</code>为已冲突的次数。</li>
</ul>
<ol>
<li>线性探测法<br>
$$d_{i}=1,2,…,(m-1)$$<br>
即$d_{i}=i$，或者其它线性函数。相当于逐个探测存放地址的表，直到查找到一个空单元，然后放置在该单元。<br>
对于[15,1,24,32,55,64,42,93,82,76]:<br>
可以看到，在<code>55</code>之前都还没冲突：<br>
| 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 |<br>
|—|---|—|---|—|---|—|---|—|---|<br>
|  | 1 | 32 |   | 24| 15| |   |  |   |<br>
此时插入<code>55</code>，与<code>15</code>冲突，应用线性探测，此时<code>i=1</code>，可以得到：<br>
| 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 |<br>
|—|---|—|---|—|---|—|---|—|---|<br>
|  | 1 | 32 |   | 24| 15|55 |   |  |   |<br>
再插入<code>64</code>，冲突不少，要取到i=3：<br>
| 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 |<br>
|—|---|—|---|—|---|—|---|—|---|<br>
|  | 1 | 32 |   | 24| 15|55 | 64|  |   |<br>
插入<code>42</code>，<code>i=1</code>：<br>
| 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 |<br>
|—|---|—|---|—|---|—|---|—|---|<br>
|  | 1 | 32 | 42| 24| 15|55 | 64|  |   |<br>
插入<code>93</code>，<code>i=5</code>：<br>
| 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 |<br>
|—|---|—|---|—|---|—|---|—|---|<br>
|  | 1 | 32 | 42| 24| 15|55 | 64| 93|   |<br>
插入<code>82</code>，<code>i=7</code>：<br>
| 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 |<br>
|—|---|—|---|—|---|—|---|—|---|<br>
|  | 1 | 32 | 42| 24| 15|55 | 64| 93| 82|<br>
插入<code>76</code>，<code>i=4</code>：<br>
| 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 |<br>
|—|---|—|---|—|---|—|---|—|---|<br>
|76 | 1 | 32 | 42| 24| 15|55 | 64| 93| 82|<br>
发现越到后面，冲突的越来越离谱。所以，表的大小选择也很重要，此例中选择了10作为表的大小，所以容易产生冲突。一般来讲，越是质数，mod取余就越可能分布的均匀。</li>
<li>平方探测</li>
<li>伪随机探测</li>
</ol>
<ul>
<li>链表法<br>
拉链法解决冲突时，需要使用指针，指示下一个元素的存储位置。<br>
各链表上的结点空间是动态申请的,故链表法更适合于造表前无法确定表长的情况。<br>
拉链法的缺点是：指针需要额外的空间，故当结点规模较小时，开放定址法较为节省空间</li>
</ul>
<h2 id="数据结构总结"><a class="header-anchor" href="#数据结构总结"></a>数据结构总结</h2>
<p>Hash操作能根据散列值直接定位数据的存储地址，设计良好的hash表能在常数级时间下找到需要的数据，但是更适合于内存中的查找。</p>
<p>B+树是一种是一种树状的数据结构，适合做索引，对磁盘数据来说，索引查找是比较高效的</p>
<p>STL_Map的内部实现是一颗红黑树，但是只是一颗在内存中建立二叉树树，不能用于磁盘操作，而其内存查找性能也比不上Hash查找。</p>
<h1 id="算法"><a class="header-anchor" href="#算法"></a>算法</h1>
<h2 id="排序"><a class="header-anchor" href="#排序"></a>排序</h2>
<p>日期：2018/07/04 21:31</p>
<h3 id="分类"><a class="header-anchor" href="#分类"></a>分类</h3>
<ul>
<li>插入排序  <br>
不到最后一轮排序，存在完全变换序列位置的可能性。
<ul>
<li>直接插入排序<br>
 <image src="http://p8ran6tub.bkt.clouddn.com/insert_array.jpg" width="350"><br>
 稳定排序方式。</image></li>
<li>折半插入排序(二分插入排序)<br>
 不太理解，也是稳定的排序方式。</li>
<li>希尔排序(缩小增量排序)  <br>
<image src="http://p8ran6tub.bkt.clouddn.com/3065130796-591d0118a9fc2_articlex.jpg" width="350"><br>
 不稳定的排序方式。</image></li>
</ul>
</li>
<li>交换排序
<ul>
<li>冒泡排序  <br>
<image src="http://p8ran6tub.bkt.clouddn.com/20170603151337153.jpg" width="350"><br>
冒泡排序最多要交换n(n-1)/2次。<br>
两两比较和交换，是一种稳定的排序方式。</image></li>
<li>快速排序(划分排序)  <br>
<image src="http://p8ran6tub.bkt.clouddn.com/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20180707210806.jpg" width="350"><br>
以序列第一个元素为基准，两端各一个指针。<br>
速度最快，但序列有序的情况下，反而插入排序更快。<br>
但是一种不稳定的排序方式。</image></li>
</ul>
</li>
<li>选择排序
<ul>
<li>简单选择排序<br>
<image src="http://p8ran6tub.bkt.clouddn.com/20170109154011409.png" width="350"><br>
每一趟选出最小的，是一种不稳定的排序方式。<br>
 - 树形选择排序  <br>
<image src="http://p8ran6tub.bkt.clouddn.com/1-1203011431164Y.jpg" width="350"><br>
从叶子节点开始，兄弟节点之间两两比赛，胜者上升到父节点。<br>
是一种不稳定的排序方式。</image></image></li>
<li>堆排序  <br>
<image src="http://lzpgithub.github.io/images/posts/Datastructure/60.png" width="350"><br>
大根堆：从上到下-从大到小<br>
小根堆：从上到下-从小到大  <br>
是一种不稳定的排序方式。</image></li>
</ul>
</li>
<li>归并排序  <br>
最常见的是二路归并排序。  <br>
是一种要求内存最大、稳定的排序方式。</li>
<li>基数排序
<ul>
<li>多关键字排序<br>
 是一种稳定的排序方式。</li>
<li>链式基数排序  <br>
是一种稳定的排序方式。</li>
</ul>
</li>
<li>外部排序
<ul>
<li>基本方法</li>
<li>多路归并排序</li>
<li>置换-选择排序</li>
</ul>
</li>
</ul>
<h3 id="归纳表"><a class="header-anchor" href="#归纳表"></a>归纳表</h3>
<image src="http://p8ran6tub.bkt.clouddn.com/617149_1458617550644_D6285CF4869068D2F4348C37ECB6F49D.jpg" width="350">
<h2 id="图的遍历算法"><a class="header-anchor" href="#图的遍历算法"></a>图的遍历算法</h2>
<h3 id="深度优先搜索-deep-first-search-dfs"><a class="header-anchor" href="#深度优先搜索-deep-first-search-dfs"></a>深度优先搜索(Deep First Search,DFS)</h3>
<p>对连通图进行遍历的算法。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Gragh</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self,nodes,sides)</span>:</span></span><br><span class="line">        <span class="string">'''</span></span><br><span class="line"><span class="string">        nodes 表示点</span></span><br><span class="line"><span class="string">        sides 表示边</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        '''</span></span><br><span class="line">        <span class="comment"># self.sequense是字典，key是点，value是与key相连接的点</span></span><br><span class="line">        self.sequense = &#123;&#125;</span><br><span class="line">        <span class="comment"># self.side是临时变量，主要用于保存与指定点相连接的点</span></span><br><span class="line">        self.side=[]</span><br><span class="line">        <span class="keyword">for</span> node <span class="keyword">in</span> nodes:</span><br><span class="line">            <span class="keyword">for</span> side <span class="keyword">in</span> sides:</span><br><span class="line">                u,v=side</span><br><span class="line">                <span class="comment"># 指定点与另一个点在同一个边中，则说明这个点与指定点是相连接的点，则需要将这个点放到self.side中</span></span><br><span class="line">                <span class="keyword">if</span> node ==u:</span><br><span class="line">                    self.side.append(v)</span><br><span class="line">                <span class="keyword">elif</span> node == v:</span><br><span class="line">                    self.side.append(u)</span><br><span class="line">            self.sequense[node] = self.side</span><br><span class="line">            self.side=[]</span><br><span class="line">        <span class="comment">#print self.sequense</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="string">'''</span></span><br><span class="line"><span class="string">    # Depth-First-Search </span></span><br><span class="line"><span class="string">        深度优先算法，是一种用于遍历或搜索树或图的算法。沿着树的深度遍历树的节点，尽可能深的搜索树的分支。</span></span><br><span class="line"><span class="string">        当节点v的所在边都己被探寻过，搜索将回溯到发现节点v的那条边的起始节点。</span></span><br><span class="line"><span class="string">        这一过程一直进行到已发现从源节点可达的所有节点为止。如果还存在未被发现的节点，</span></span><br><span class="line"><span class="string">        则选择其中一个作为源节点并重复以上过程，整个进程反复进行直到所有节点都被访问为止。属于盲目搜索。        </span></span><br><span class="line"><span class="string">    '''</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">DFS</span><span class="params">(self,node0)</span>:</span></span><br><span class="line">        <span class="comment">#queue本质上是堆栈，用来存放需要进行遍历的数据</span></span><br><span class="line">        <span class="comment">#order里面存放的是具体的访问路径</span></span><br><span class="line">        queue,order=[],[]</span><br><span class="line">        <span class="comment">#首先将初始遍历的节点放到queue中，表示将要从这个点开始遍历</span></span><br><span class="line">        queue.append(node0)</span><br><span class="line">        <span class="keyword">while</span> queue:</span><br><span class="line">            <span class="comment">#从queue中pop出点v，然后从v点开始遍历了，所以可以将这个点pop出，然后将其放入order中</span></span><br><span class="line">            <span class="comment">#这里才是最有用的地方，pop（）表示弹出栈顶，由于下面的for循环不断的访问子节点，并将子节点压入堆栈，</span></span><br><span class="line">            <span class="comment">#也就保证了每次的栈顶弹出的顺序是下面的节点</span></span><br><span class="line">            v = queue.pop()</span><br><span class="line">            order.append(v)</span><br><span class="line">            <span class="comment">#这里开始遍历v的子节点</span></span><br><span class="line">            <span class="keyword">for</span> w <span class="keyword">in</span> self.sequense[v]:</span><br><span class="line">                <span class="comment">#w既不属于queue也不属于order，意味着这个点没被访问过，所以讲起放到queue中，然后后续进行访问</span></span><br><span class="line">                <span class="keyword">if</span> w <span class="keyword">not</span> <span class="keyword">in</span> order <span class="keyword">and</span> w <span class="keyword">not</span> <span class="keyword">in</span> queue: </span><br><span class="line">                    queue.append(w)</span><br><span class="line">        <span class="keyword">return</span> order</span><br></pre></td></tr></table></figure>
<h3 id="广度优先搜索-breadth-first-search-bfs"><a class="header-anchor" href="#广度优先搜索-breadth-first-search-bfs"></a>广度优先搜索(Breadth First Search,BFS)</h3>
<h2 id="动态规划"><a class="header-anchor" href="#动态规划"></a>动态规划</h2>
<h3 id="最长公共子序列"><a class="header-anchor" href="#最长公共子序列"></a>最长公共子序列</h3>
<p>参考：<a href="https://blog.csdn.net/hrn1216/article/details/51534607" target="_blank" rel="noopener">https://blog.csdn.net/hrn1216/article/details/51534607</a>  <br>
用一个表记录已经解决的子问题的答案，避免大量的重复计算，节约时间。不管该子问题以后是否被用到，只要它被计算过，就将其结果填入表中。这就是动态规划法的基本思路。<br>
<image src="https://res.cloudinary.com/sunflower/image/upload/v1544691945/Blog/digui.png" width="350"></image></p>
<h3 id="背包问题"><a class="header-anchor" href="#背包问题"></a>背包问题</h3>
<p>背包九讲：<a href="https://github.com/tianyicui/pack/blob/master/V2.pdf" target="_blank" rel="noopener">https://github.com/tianyicui/pack/blob/master/V2.pdf</a></p>
<h2 id="并查集"><a class="header-anchor" href="#并查集"></a>并查集</h2>
<p>并查集（Union-Find）是解决<strong>动态连通性</strong>问题的一类非常高效的算法。</p>
<h3 id="动态连通性"><a class="header-anchor" href="#动态连通性"></a>动态连通性</h3>
<p>举例：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[(4, 3), (3, 8), (6, 5), (9, 4), (2, 1), (8, 9), (5, 0), (7, 2), (6, 1), (6, 7)]</span><br></pre></td></tr></table></figure>
<p>将这些点对依次表达出来，找出互相连通的部分。<br>
<image src="https://res.cloudinary.com/sunflower/image/upload/v1548125221/Blog/%E5%8A%A8%E6%80%81%E8%BF%9E%E9%80%9A%E6%80%A7.png" width="350"></image></p>
<h3 id="步骤"><a class="header-anchor" href="#步骤"></a>步骤</h3>
<p>为了找出图的连通性，一个简单的思路就是分组，就是将相互连通的点看成是一个组，如果查询的点不在一个组，那么这个点对就是不连通的。  <br>
主要分为“并”和“查”两个步骤：  <br>
还是以上述的10个点为例，首先以自身初始化每个点的组别，</p>
<table>
<thead>
<tr>
<th>element</th>
<th>0</th>
<th>1</th>
<th>2</th>
<th>3</th>
<th>4</th>
<th>5</th>
<th>6</th>
<th>7</th>
<th>8</th>
<th>9</th>
</tr>
</thead>
<tbody>
<tr>
<td>group number</td>
<td>0</td>
<td>1</td>
<td>2</td>
<td>3</td>
<td>4</td>
<td>5</td>
<td>6</td>
<td>7</td>
<td>8</td>
<td>9</td>
</tr>
</tbody>
</table>
<p>“并”操作，以点对(4,3)为例。发现所在组别不一样，将点4和点3的组别都变为3（或者都变为4），然后产生如下的表，</p>
<table>
<thead>
<tr>
<th>element</th>
<th>0</th>
<th>1</th>
<th>2</th>
<th>3</th>
<th>4</th>
<th>5</th>
<th>6</th>
<th>7</th>
<th>8</th>
<th>9</th>
</tr>
</thead>
<tbody>
<tr>
<td>group number</td>
<td>0</td>
<td>1</td>
<td>2</td>
<td><em>3</em></td>
<td><em>3</em></td>
<td>5</td>
<td>6</td>
<td>7</td>
<td>8</td>
<td>9</td>
</tr>
</tbody>
</table>
<p>“查”操作，就是查找点对所在组别是否一致。</p>
<p>并查集适合用树这一数据结构，因为树的根节点可以用来表示这个树所有结点的组别。</p>
<p>用树结构实现并查集的算法思路可以如下描述，假设现在要添加多个路径（点对）：</p>
<ul>
<li>初始化：每个点看做一棵树，当然这是一棵只有根节点的树，存储了这个节点本身的值作为组别（你也可以令其他不会产生冲突的记号做组别）；</li>
<li>查询：对于点对(a,b)，通过a和b向其根节点回溯（当然初始时就是它们本身），判断其所在组别；</li>
<li>合并：若不在同一组别，令其中一个点（比如a吧）所在树的根节点成为另一个点（比如b）的根节点的孩子。这样即便再查询到a，通过上面的查询过程，程序也会最终判断得到的是现在b的根节点所在的组别，相当于是改变了a所在组的全部元素的组别；</li>
</ul>
<h3 id="代码"><a class="header-anchor" href="#代码"></a>代码</h3>
<p>以下是一个并查集结构：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UnionFind</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, grid)</span>:</span><span class="comment">#初始化</span></span><br><span class="line">        self.n = len(grid)</span><br><span class="line">        self.parent = [<span class="number">-1</span>] * self.n</span><br><span class="line">        <span class="keyword">for</span> idx <span class="keyword">in</span> range(self.n):</span><br><span class="line">            self.parent[idx] = idx</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">find</span><span class="params">(self, i)</span>:</span><span class="comment">#查</span></span><br><span class="line">        <span class="keyword">if</span> self.parent[i] != i:</span><br><span class="line">            self.parent[i] = self.find(self.parent[i])</span><br><span class="line">        <span class="keyword">return</span> self.parent[i]</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">union</span><span class="params">(self, x, y)</span>:</span><span class="comment">#并</span></span><br><span class="line">        rootx = self.find(x)</span><br><span class="line">        rooty = self.find(y)</span><br><span class="line">        <span class="keyword">if</span> rootx != rooty:</span><br><span class="line">            self.parent[rooty] = rootx</span><br></pre></td></tr></table></figure>
<h1 id="leetcode题目"><a class="header-anchor" href="#leetcode题目"></a>Leetcode题目</h1>
<h2 id="96-不同的二叉搜索树"><a class="header-anchor" href="#96-不同的二叉搜索树"></a>96.不同的二叉搜索树</h2>
<p>状态：不会，重做<br>
<strong>题目</strong><br>
给定一个整数 n，求以 1 … n 为节点组成的二叉搜索树有多少种？</p>
<p>示例:<br>
输入: 3<br>
输出: 5<br>
解释:<br>
给定 n = 3, 一共有 5 种不同结构的二叉搜索树:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1     1      2         3       3  </span><br><span class="line"> \    \     /  \       /       /            </span><br><span class="line">  3    2    1   3      2       1          </span><br><span class="line"> /      \            /          \</span><br><span class="line">2       3           1            2</span><br></pre></td></tr></table></figure>
<p><strong>解析</strong><br>
动态规划  <br>
以<code>1,2,...,n</code>为节点组成的BST有<code>G[n]</code>种，<br>
<code>G[n]=F(1,n)+F(2,n)+...+F(i,n)+...+F(n,n)</code>  <br>
其中，<code>F(i,n)</code>表示以i为根节点组成的BST个数，  <br>
然而，<code>F(i,n)=G[i-1] * G[n-i]</code>  <br>
注意，<code>G[0]=1</code></p>
<p>以n=3为例，<code>G[3]=F(1,3)+F(2,3)+F(3,3)</code>,</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">F(1,3)=G[0] * G[2]</span><br><span class="line">F(2,3)=G[1] * G[1]</span><br><span class="line">F(3,3)=G[2] * G[0]</span><br></pre></td></tr></table></figure>
<p><strong>代码</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">numTrees</span><span class="params">(self, n)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type n: int</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        G = [<span class="number">0</span>] * (n+<span class="number">1</span>)</span><br><span class="line">        G[<span class="number">0</span>] = <span class="number">1</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, n+<span class="number">1</span>):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(i):</span><br><span class="line">                G[i] += G[j] * G[i<span class="number">-1</span>-j]</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> G[n]</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    a = Solution()</span><br><span class="line">    print(a.numTrees(n=<span class="number">3</span>))</span><br></pre></td></tr></table></figure>
<h2 id="413-等差数列划分"><a class="header-anchor" href="#413-等差数列划分"></a>413. 等差数列划分</h2>
<p>状态：亟待优化<br>
<strong>题目</strong><br>
如果一个数列至少有三个元素，并且任意两个相邻元素之差相同，则称该数列为等差数列。</p>
<p>例如，以下数列为等差数列:<br>
1, 3, 5, 7, 9<br>
7, 7, 7, 7<br>
3, -1, -5, -9</p>
<p>以下数列不是等差数列。<br>
1, 1, 2, 5, 7</p>
<p>数组 A 包含 N 个数，且索引从0开始。数组 A 的一个子数组划分为数组 (P, Q)，P 与 Q 是整数且满足 0&lt;=P&lt;Q&lt;N 。<br>
如果满足以下条件，则称子数组(P, Q)为等差数组：<br>
元素 A[P], A[p + 1], …, A[Q - 1], A[Q] 是等差的。并且 P + 1 &lt; Q 。<br>
函数要返回数组 A 中所有为等差数组的子数组个数。</p>
<p>示例:<br>
A = [1, 2, 3, 4]<br>
返回: 3, A 中有三个子等差数组: [1, 2, 3], [2, 3, 4] 以及自身 [1, 2, 3, 4]。</p>
<p><strong>version1</strong>  <br>
过程：<br>
<image src="https://res.cloudinary.com/sunflower/image/upload/v1544164932/Blog/413_process.png" width="350"><br>
成绩：<br>
<image src="https://res.cloudinary.com/sunflower/image/upload/v1544164932/Blog/413_res.png" width="350"></image></image></p>
<p><strong>解析</strong>    <br>
审题一定要清楚：</p>
<ol>
<li>给定的数组A不一定是等差数列，不要让示例先入为止；</li>
<li>等差子数列，题目中明确要求：元素 A[P], A[p + 1], …, A[Q - 1], A[Q] 是等差的。并且 P + 1 &lt; Q 。即表明，子数列是在原数列中不间隔选出的，且至少3个元素。</li>
</ol>
<p>基于以上分析，先枚举出子数列的所有情形，再判断该子数列是否为等差，但是超时的缘故，在枚举子数列的过程中，若判定该子数列不等差，那么可以包含该子数列的数列肯定也不等差。优化这一判断条件后才勉强通过时间限制。</p>
<p><strong>代码</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">numberOfArithmeticSlices</span><span class="params">(self, A)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type A: List[int]</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">if</span> len(A) &lt; <span class="number">3</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            res = <span class="number">0</span></span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> range(len(A)):         </span><br><span class="line">                <span class="keyword">for</span> j <span class="keyword">in</span> range(i + <span class="number">3</span>, len(A) + <span class="number">1</span>):</span><br><span class="line">                    li = A[i:j]</span><br><span class="line">                    k = li[<span class="number">1</span>] - li[<span class="number">0</span>]<span class="comment">#等差</span></span><br><span class="line">                    flag = <span class="number">0</span></span><br><span class="line">                    <span class="keyword">for</span> m <span class="keyword">in</span> range(<span class="number">1</span>, len(li)):</span><br><span class="line">                        <span class="keyword">if</span> li[m] == li[m<span class="number">-1</span>] + k:</span><br><span class="line">                            flag += <span class="number">1</span></span><br><span class="line">                        <span class="keyword">else</span>:</span><br><span class="line">                            <span class="keyword">break</span></span><br><span class="line">                    <span class="keyword">if</span> flag == len(li) - <span class="number">1</span>:</span><br><span class="line">                        res += <span class="number">1</span></span><br><span class="line">                    <span class="keyword">else</span>:</span><br><span class="line">                        <span class="keyword">break</span>                   </span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>
<p><strong>标准答案</strong><br>
以A=[1,2,3,4,5,6]为例：<br>
10=1+2+3+4<br>
在枚举子数列时，判断A[i-2],A[i-1],A[i]是否为等差数列，若是则根据前一个循环是否也是等差决定是否叠加。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">numberOfArithmeticSlices</span><span class="params">(self, A)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :param A: List[int]</span></span><br><span class="line"><span class="string">        :return: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        N = len(A)</span><br><span class="line">        <span class="keyword">if</span> N &lt;= <span class="number">2</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line"></span><br><span class="line">        count = <span class="number">0</span></span><br><span class="line">        streak = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">2</span>, N):</span><br><span class="line">            <span class="keyword">if</span> A[i] - A[i<span class="number">-1</span>] == A[i<span class="number">-1</span>] - A[i<span class="number">-2</span>]:</span><br><span class="line">                streak += <span class="number">1</span><span class="comment">#以A[i]结尾的等差子数列的个数</span></span><br><span class="line">                count += streak</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                streak = <span class="number">0</span></span><br><span class="line">        <span class="keyword">return</span> count</span><br></pre></td></tr></table></figure>
<h2 id="120-三角形最小路径和"><a class="header-anchor" href="#120-三角形最小路径和"></a>120. 三角形最小路径和</h2>
<p>状态：排名85%，未考虑空间复杂度<br>
<strong>题目</strong>  <br>
给定一个三角形，找出自顶向下的最小路径和。每一步只能移动到下一行中相邻的结点上。</p>
<p>例如，给定三角形：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[</span><br><span class="line">     [2],</span><br><span class="line">    [3,4],</span><br><span class="line">   [6,5,7],</span><br><span class="line">  [4,1,8,3]</span><br><span class="line">]</span><br></pre></td></tr></table></figure>
<p>自顶向下的最小路径和为 11（即，2 + 3 + 5 + 1 = 11）。</p>
<p>说明：<br>
如果你可以只使用 O(n) 的额外空间（n 为三角形的总行数）来解决这个问题，那么你的算法会很加分。</p>
<p><strong>version1</strong>  <br>
过程：<br>
<image src="https://res.cloudinary.com/sunflower/image/upload/v1544363867/Blog/120_process.png" width="350"><br>
成绩：<br>
<image src="https://res.cloudinary.com/sunflower/image/upload/v1544363867/Blog/120_score.png" width="350"></image></image></p>
<p><strong>解析</strong>    <br>
参考之前矩阵的题目，从最左上角开始，每次只能往下或者往右走，最佳的解题思路就是算出每走一步后的结果，依次迭代。  <br>
那么，这里的思路也是一样的，这里的限制条件是只能走相邻的点。</p>
<p><strong>代码</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">minimumTotal</span><span class="params">(self, triangle)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type triangle: List[List[int]]</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">if</span> len(triangle) == <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> triangle[<span class="number">0</span>][<span class="number">0</span>]</span><br><span class="line">        <span class="keyword">elif</span> len(triangle) == <span class="number">2</span>:</span><br><span class="line">            <span class="keyword">return</span> triangle[<span class="number">0</span>][<span class="number">0</span>] + min(triangle[<span class="number">1</span>])</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            triangle[<span class="number">1</span>][<span class="number">0</span>], triangle[<span class="number">1</span>][<span class="number">1</span>] = triangle[<span class="number">1</span>][<span class="number">0</span>] + triangle[<span class="number">0</span>][<span class="number">0</span>], triangle[<span class="number">1</span>][<span class="number">1</span>] + triangle[<span class="number">0</span>][<span class="number">0</span>]</span><br><span class="line">            <span class="keyword">for</span> row <span class="keyword">in</span> range(<span class="number">2</span>, len(triangle)):</span><br><span class="line">                <span class="keyword">for</span> idx <span class="keyword">in</span> range(row + <span class="number">1</span>):</span><br><span class="line">                    <span class="keyword">if</span> idx == <span class="number">0</span>:</span><br><span class="line">                        triangle[row][idx] += triangle[row - <span class="number">1</span>][idx]</span><br><span class="line">                    <span class="keyword">elif</span> idx == row:</span><br><span class="line">                        triangle[row][idx] += triangle[row - <span class="number">1</span>][idx - <span class="number">1</span>]</span><br><span class="line">                    <span class="keyword">else</span>:</span><br><span class="line">                        triangle[row][idx] += min(triangle[row - <span class="number">1</span>][idx], triangle[row - <span class="number">1</span>][idx - <span class="number">1</span>])</span><br><span class="line">            <span class="keyword">return</span> min(triangle[<span class="number">-1</span>])</span><br></pre></td></tr></table></figure>
<p><strong>标准答案</strong>  <br>
关键在于空间复杂度：  <br>
我的解法是至上而下的，需要修改数组中的每一个元素。现在有一种解法是至下而上，只写存最后一行的内层数组空间，这种解法更节约空间。  <br>
<strong>代码</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">minimumTotal</span><span class="params">(self, triangle)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type triangle: List[List[int]]</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> triangle:</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        res = triangle[<span class="number">-1</span>]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(triangle) - <span class="number">2</span>, <span class="number">-1</span>, <span class="number">-1</span>):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(len(triangle[i])):</span><br><span class="line">                res[j] = min(res[j], res[j + <span class="number">1</span>]) + triangle[i][j]</span><br><span class="line">        <span class="keyword">return</span> res[<span class="number">0</span>]</span><br></pre></td></tr></table></figure>
<h2 id="62-不同路径"><a class="header-anchor" href="#62-不同路径"></a>62. 不同路径</h2>
<p>状态：排名95.86%<br>
<strong>题目</strong>  <br>
一个机器人位于一个 m x n 网格的左上角 （起始点在下图中标记为“Start” ）。</p>
<p>机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为“Finish”）。</p>
<p>问总共有多少条不同的路径？<br>
<image src="https://res.cloudinary.com/sunflower/image/upload/v1544446636/Blog/robot_maze.png" width="350"><br>
例如，上图是一个7 x 3 的网格。有多少可能的路径？</image></p>
<p>说明：m 和 n 的值均不超过 100。<br>
示例 1:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">输入: m = 3, n = 2</span><br><span class="line">输出: 3</span><br><span class="line">解释:</span><br><span class="line">从左上角开始，总共有 3 条路径可以到达右下角。</span><br><span class="line">1. 向右 -&gt; 向右 -&gt; 向下</span><br><span class="line">2. 向右 -&gt; 向下 -&gt; 向右</span><br><span class="line">3. 向下 -&gt; 向右 -&gt; 向右</span><br></pre></td></tr></table></figure>
<p>示例 2:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: m = 7, n = 3</span><br><span class="line">输出: 28</span><br></pre></td></tr></table></figure>
<p><strong>version1</strong>  <br>
过程：<br>
<image src="https://res.cloudinary.com/sunflower/image/upload/v1544446538/Blog/62_process.png" width="350"><br>
成绩：<br>
<image src="https://res.cloudinary.com/sunflower/image/upload/v1544446539/Blog/62_score.png" width="350"></image></image></p>
<p><strong>解析</strong>  <br>
第一次提交失败：未考虑周全矩阵的形式。  <br>
思路和之前矩阵求最小路径和以及三角形最小路径和是一样的，计算每个节点的路径可能数，最终答案即为最后一个点的值。</p>
<p><strong>代码</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">uniquePaths</span><span class="params">(self, m, n)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type m: int</span></span><br><span class="line"><span class="string">        :type n: int</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">if</span> m == <span class="number">1</span> <span class="keyword">or</span> n == <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            res = [[<span class="number">0</span> <span class="keyword">for</span> i <span class="keyword">in</span> range(n)] <span class="keyword">for</span> i <span class="keyword">in</span> range(m)]</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> range(m):</span><br><span class="line">                <span class="keyword">for</span> j <span class="keyword">in</span> range(n):</span><br><span class="line">                    <span class="keyword">if</span> i == <span class="number">0</span> <span class="keyword">and</span> j == <span class="number">0</span>:</span><br><span class="line">                        <span class="keyword">continue</span></span><br><span class="line">                    <span class="keyword">elif</span> i == <span class="number">0</span>:</span><br><span class="line">                        res[i][j] = <span class="number">1</span></span><br><span class="line">                    <span class="keyword">elif</span> j == <span class="number">0</span>:</span><br><span class="line">                        res[i][j] = <span class="number">1</span></span><br><span class="line">                    <span class="keyword">else</span>:</span><br><span class="line">                        res[i][j] = res[i - <span class="number">1</span>][j] + res[i][j - <span class="number">1</span>]</span><br><span class="line">            <span class="keyword">return</span> res[<span class="number">-1</span>][<span class="number">-1</span>]</span><br></pre></td></tr></table></figure>
<h2 id="712-两个字符串的最小ascii删除和"><a class="header-anchor" href="#712-两个字符串的最小ascii删除和"></a>712. 两个字符串的最小ASCII删除和</h2>
<p>状态：不会做<br>
<strong>题目</strong>  <br>
给定两个字符串s1, s2，找到使两个字符串相等所需删除字符的ASCII值的最小和。</p>
<p>示例 1:<br>
输入: s1 = “sea”, s2 = &quot;eat&quot;<br>
输出: 231<br>
解释: 在 “sea” 中删除 “s” 并将 “s” 的值(115)加入总和。<br>
在 “eat” 中删除 “t” 并将 116 加入总和。<br>
结束时，两个字符串相等，115 + 116 = 231 就是符合条件的最小和。</p>
<p>示例 2:<br>
输入: s1 = “delete”, s2 = &quot;leet&quot;<br>
输出: 403<br>
解释: 在 “delete” 中删除 “dee” 字符串变成 “let”，<br>
将 100[d]+101[e]+101[e] 加入总和。在 “leet” 中删除 “e” 将 101[e] 加入总和。<br>
结束时，两个字符串都等于 “let”，结果即为 100+101+101+101 = 403 。<br>
如果改为将两个字符串转换为 “lee” 或 “eet”，我们会得到 433 或 417 的结果，比答案更大。</p>
<p>注意:<br>
0 &lt; s1.length, s2.length &lt;= 1000。<br>
所有字符串中的字符ASCII值在[97, 122]之间。</p>
<p><strong>最佳答案</strong>  <br>
这题是经典题目“最长公共子串LCS”的变形题目。  <br>
在弄懂LCS之后，这题就很好理解了。<br>
LCS:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">初始化dp矩阵：</span><br><span class="line">----------d---e---l---e---t---e--</span><br><span class="line">|___|_0_|_0_|_0_|_0_|_0_|_0_|_0_|</span><br><span class="line">|_l_|_0_|_0_|_0_|_0_|_0_|_0_|_0_|</span><br><span class="line">|_e_|_0_|_0_|_0_|_0_|_0_|_0_|_0_|</span><br><span class="line">|_e_|_0_|_0_|_0_|_0_|_0_|_0_|_0_|</span><br><span class="line">|_t_|_0_|_0_|_0_|_0_|_0_|_0_|_0_|</span><br><span class="line">从s1=&quot;leet&quot;开始遍历对比s2=&quot;delete&quot;，</span><br><span class="line">1.如果相同，那么dp[i][j]=dp[i-1][j-1]+1;</span><br><span class="line">意味着，如果s1与s2最后一个元素相同，那么</span><br><span class="line">LCS（s1,s2）=LCS(s1[:-1],s2[:-1])+s1[-1]</span><br><span class="line">2.如果不同，那么dp[i][j]=max(dp[i-1][j],dp[i][j-1])</span><br><span class="line">意味着，如果s1与s2最后一个元素不同，那么</span><br><span class="line">LCS(s1,s2)=max(LCS(s1[:-1],s2),LCS(s1,s2[:-1]))</span><br><span class="line">----------d---e---l---e---t---e--</span><br><span class="line">|___|_0_|_0_|_0_|_0_|_0_|_0_|_0_|</span><br><span class="line">|_l_|_0_|_0_|_0_|_1_|_1_|_1_|_1_|</span><br><span class="line">|_e_|_0_|_0_|_1_|_1_|_2_|_2_|_2_|</span><br><span class="line">|_e_|_0_|_0_|_1_|_1_|_2_|_2_|_3_|</span><br><span class="line">|_t_|_0_|_0_|_1_|_1_|_2_|_3_|_3_|</span><br></pre></td></tr></table></figure>
<p><strong>标准代码</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">minimumDeleteSum</span><span class="params">(self, s1, s2)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type s1: str</span></span><br><span class="line"><span class="string">        :type s2: str</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        l1, l2 = len(s1), len(s2)</span><br><span class="line">        dp = [[<span class="number">0</span>] * (l2 + <span class="number">1</span>) <span class="keyword">for</span> _ <span class="keyword">in</span> range(l1 + <span class="number">1</span>)]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(l1):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(l2):</span><br><span class="line">                <span class="keyword">if</span> s1[i] == s2[j]:</span><br><span class="line">                    dp[i + <span class="number">1</span>][j + <span class="number">1</span>] = dp[i][j] + ord(s1[i])</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    dp[i + <span class="number">1</span>][j + <span class="number">1</span>] = max(dp[i][j + <span class="number">1</span>], dp[i + <span class="number">1</span>][j])</span><br><span class="line">        result = sum(map(ord, s1 + s2)) - dp[l1][l2] * <span class="number">2</span></span><br><span class="line">        <span class="keyword">return</span> result</span><br></pre></td></tr></table></figure>
<h2 id="647-回文子串"><a class="header-anchor" href="#647-回文子串"></a>647. 回文子串</h2>
<p>状态：排名23.26%<br>
<strong>题目</strong>  <br>
给定一个字符串，你的任务是计算这个字符串中有多少个回文子串。</p>
<p>具有不同开始位置或结束位置的子串，即使是由相同的字符组成，也会被计为是不同的子串。</p>
<p>示例 1:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: &quot;abc&quot;</span><br><span class="line">输出: 3</span><br><span class="line">解释: 三个回文子串: &quot;a&quot;, &quot;b&quot;, &quot;c&quot;.</span><br></pre></td></tr></table></figure>
<p>示例 2:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: &quot;aaa&quot;</span><br><span class="line">输出: 6</span><br><span class="line">说明: 6个回文子串: &quot;a&quot;, &quot;a&quot;, &quot;a&quot;, &quot;aa&quot;, &quot;aa&quot;, &quot;aaa&quot;.</span><br></pre></td></tr></table></figure>
<p>注意:<br>
输入的字符串长度不会超过1000。</p>
<p><strong>version1</strong>  <br>
过程：<br>
<image src="https://res.cloudinary.com/sunflower/image/upload/v1544703333/Blog/647_process.png" width="350"><br>
成绩：<br>
<image src="https://res.cloudinary.com/sunflower/image/upload/v1544703439/Blog/647_score.png" width="350"></image></image></p>
<p><strong>解析</strong>  <br>
首先一定搞明白回文字符串的意思，回文即正着读反着读都一样。  <br>
所以第一次提交失败。  <br>
第二次暴力求解，成绩亟待提高。</p>
<p><strong>代码</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">countSubstrings</span><span class="params">(self, s)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type s: str</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        flag = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(s)):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(i, len(s)):</span><br><span class="line">                <span class="keyword">if</span> s[i:j + <span class="number">1</span>] == s[i:j + <span class="number">1</span>][::<span class="number">-1</span>]:</span><br><span class="line">                    flag += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> flag</span><br></pre></td></tr></table></figure>
<h2 id="303-区域和检索-数组不可变"><a class="header-anchor" href="#303-区域和检索-数组不可变"></a>303. 区域和检索 - 数组不可变</h2>
<p>状态：排名41.91%，待提高<br>
<strong>题目</strong>  <br>
给定一个整数数组  nums，求出数组从索引 i 到 j  (i ≤ j) 范围内元素的总和，包含 i,  j 两点。</p>
<p>示例：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">给定 nums = [-2, 0, 3, -5, 2, -1]，求和函数为 sumRange()</span><br><span class="line">sumRange(0, 2) -&gt; 1</span><br><span class="line">sumRange(2, 5) -&gt; -1</span><br><span class="line">sumRange(0, 5) -&gt; -3</span><br></pre></td></tr></table></figure>
<p>说明:<br>
你可以假设数组不可变。<br>
会多次调用 sumRange 方法。</p>
<p><strong>version1</strong>  <br>
过程：<br>
<image src="https://res.cloudinary.com/sunflower/image/upload/v1544704657/Blog/303_process.png" width="350"><br>
成绩：<br>
<image src="https://res.cloudinary.com/sunflower/image/upload/v1544704743/Blog/303_score.png" width="350"></image></image></p>
<p><strong>解析</strong>    <br>
这题思路很简单。</p>
<p><strong>代码</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NumArray</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, nums)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type nums: List[int]</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        self.nums = nums</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">sumRange</span><span class="params">(self, i, j)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type i: int</span></span><br><span class="line"><span class="string">        :type j: int</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">return</span> sum(self.nums[i:j+<span class="number">1</span>])</span><br><span class="line"><span class="comment"># Your NumArray object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"># obj = NumArray(nums)</span></span><br><span class="line"><span class="comment"># param_1 = obj.sumRange(i,j)</span></span><br></pre></td></tr></table></figure>
<p><strong>标准答案</strong>  <br>
这题主要是要用动态规划的思想，题目要求的sumRange(i,j)，是可以在遍历数组元素的时候进行叠加求和，一次性求出新的叠加数组。</p>
<p><strong>代码</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NumArray</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, nums)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type nums: List[int]</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        self.nums = nums</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">sumRange</span><span class="params">(self, i, j)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type i: int</span></span><br><span class="line"><span class="string">        :type j: int</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">return</span> sum(self.nums[i:j+<span class="number">1</span>])</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    a = NumArray(nums=[<span class="number">-2</span>, <span class="number">0</span>, <span class="number">3</span>, <span class="number">-5</span>, <span class="number">2</span>, <span class="number">-1</span>])</span><br><span class="line">    print(a.sumRange(<span class="number">0</span>, <span class="number">5</span>))</span><br></pre></td></tr></table></figure>
<h2 id="343-整数拆分"><a class="header-anchor" href="#343-整数拆分"></a>343. 整数拆分</h2>
<p>状态：  排名99%<br>
<strong>题目</strong>  <br>
给定一个正整数 n，将其拆分为至少两个正整数的和，并使这些整数的乘积最大化。 返回你可以获得的最大乘积。</p>
<p>示例 1:<br>
输入: 2<br>
输出: 1<br>
解释: 2 = 1 + 1, 1 × 1 = 1。</p>
<p>示例 2:<br>
输入: 10<br>
输出: 36<br>
解释: 10 = 3 + 3 + 4, 3 × 3 × 4 = 36。</p>
<p>说明: 你可以假设 n 不小于 2 且不大于 58。</p>
<p><strong>version1</strong>    <br>
过程：<br>
<image src="https://res.cloudinary.com/sunflower/image/upload/v1544798598/Blog/343_process.png" width="350"></image></p>
<p><strong>version2</strong>    <br>
过程：<br>
<image src="https://res.cloudinary.com/sunflower/image/upload/v1545488812/Blog/343_progress.png" width="350">  <br>
成绩：<br>
<image src="https://res.cloudinary.com/sunflower/image/upload/v1545488812/Blog/343_score.png" width="350"></image></image></p>
<p><strong>解析</strong>  <br>
第二次再写，硬生生地记住了结论，解题关键要尽可能多拆分为3，若剩下1，则要将3和1转换为2和2。</p>
<p><strong>标准答案</strong>  <br>
这题主要还是没搞懂解题思路，解题的关键是神奇的质数2和质数3。</p>
<p><strong>代码</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> functools <span class="keyword">import</span> reduce</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">integerBreak</span><span class="params">(self, n)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type n: int</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">if</span> n == <span class="number">2</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> n == <span class="number">3</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">2</span></span><br><span class="line">        list_3 = [<span class="number">3</span>] * int((n / <span class="number">3</span>))  <span class="comment"># generate a list of 3</span></span><br><span class="line">        mod_3 = n % <span class="number">3</span></span><br><span class="line">        <span class="keyword">if</span> mod_3 == <span class="number">1</span>:  <span class="comment"># if a 1 is left, then add it to the first element to get a 4</span></span><br><span class="line">            list_3[<span class="number">0</span>] += <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> mod_3 == <span class="number">2</span>:  <span class="comment"># if a 2 is left, then put it into the list</span></span><br><span class="line">            list_3.append(<span class="number">2</span>)</span><br><span class="line">        <span class="keyword">return</span> reduce(<span class="keyword">lambda</span> a, b: a * b, list_3)</span><br></pre></td></tr></table></figure>
<h2 id="638-大礼包"><a class="header-anchor" href="#638-大礼包"></a>638. 大礼包</h2>
<p>状态：未通过，有思路但是有难点无法克服   <br>
<strong>题目</strong>  <br>
在LeetCode商店中， 有许多在售的物品。</p>
<p>然而，也有一些大礼包，每个大礼包以优惠的价格捆绑销售一组物品。<br>
现给定每个物品的价格，每个大礼包包含物品的清单，以及待购物品清单。请输出确切完成待购清单的最低花费。</p>
<p>每个大礼包的由一个数组中的一组数据描述，最后一个数字代表大礼包的价格，其他数字分别表示内含的其他种类物品的数量。</p>
<p>任意大礼包可无限次购买。</p>
<p>示例 1:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">输入: [2,5], [[3,0,5],[1,2,10]], [3,2]</span><br><span class="line">输出: 14</span><br><span class="line">解释: </span><br><span class="line">有A和B两种物品，价格分别为¥2和¥5。</span><br><span class="line">大礼包1，你可以以¥5的价格购买3A和0B。</span><br><span class="line">大礼包2， 你可以以¥10的价格购买1A和2B。</span><br><span class="line">你需要购买3个A和2个B， 所以你付了¥10购买了1A和2B（大礼包2），以及¥4购买2A。</span><br></pre></td></tr></table></figure>
<p>示例 2:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">输入: [2,3,4], [[1,1,0,4],[2,2,1,9]], [1,2,1]</span><br><span class="line">输出: 11</span><br><span class="line">解释: </span><br><span class="line">A，B，C的价格分别为¥2，¥3，¥4.</span><br><span class="line">你可以用¥4购买1A和2B，也可以用¥9购买2A，2B和1C。</span><br><span class="line">你需要买1A，2B和1C，所以你付了¥4买了1A和1B（大礼包1），以及¥3购买1B， ¥4购买1C。</span><br><span class="line">你不可以购买超出待购清单的物品，尽管购买大礼包2更加便宜。</span><br></pre></td></tr></table></figure>
<p>说明:<br>
最多6种物品， 100种大礼包。<br>
每种物品，你最多只需要购买6个。<br>
你不可以购买超出待购清单的物品，即使更便宜。</p>
<p><strong>version1</strong>    <br>
过程：  <br>
本地编译器上未调通，有思路，但是不知道如何解决不同大礼包优惠程度的对比。</p>
<p><strong>标准答案</strong>  <br>
深度优先搜索，主要就是用大礼包或者原价购买的价格比较，不仅要比较不同大礼包之间的差别，还要比较与原价之间的价格。大礼包的比较肯定要用for循环，然后保存下来方便与后续比较。</p>
<p><strong>代码</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">shoppingOffers</span><span class="params">(self, price, special, needs)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type price: List[int]</span></span><br><span class="line"><span class="string">        :type special: List[List[int]]</span></span><br><span class="line"><span class="string">        :type needs: List[int]</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        d = &#123;&#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">dfs</span><span class="params">(cur)</span>:</span></span><br><span class="line">            val = sum(cur[i] * price[i] <span class="keyword">for</span> i <span class="keyword">in</span> range(len(needs)))  <span class="comment"># cost without special</span></span><br><span class="line">            <span class="keyword">for</span> spec <span class="keyword">in</span> special:</span><br><span class="line">                tmp = [cur[j] - spec[j] <span class="keyword">for</span> j <span class="keyword">in</span> range(len(needs))]</span><br><span class="line">                <span class="keyword">if</span> min(tmp) &gt;= <span class="number">0</span>:  <span class="comment"># skip deals that exceed needs</span></span><br><span class="line">                    val = min(val, d.get(tuple(tmp), dfs(tmp)) + spec[<span class="number">-1</span>])  <span class="comment"># .get check the dictionary first for result, otherwise perform dfs.</span></span><br><span class="line">            d[tuple(cur)] = val</span><br><span class="line">            <span class="keyword">return</span> val</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> dfs(needs)</span><br></pre></td></tr></table></figure>
<h2 id="312-戳气球"><a class="header-anchor" href="#312-戳气球"></a>312. 戳气球</h2>
<p>状态：未通过，思路错误    <br>
<strong>题目</strong>  <br>
有 n 个气球，编号为0 到 n-1，每个气球上都标有一个数字，这些数字存在数组 nums 中。</p>
<p>现在要求你戳破所有的气球。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">每当你戳破一个气球 i 时，你可以获得 nums[left] * nums[i] * nums[right] 个硬币。</span><br></pre></td></tr></table></figure>
<p>这里的 left 和 right 代表和 i 相邻的两个气球的序号。  <br>
注意当你戳破了气球 i 后，气球 left 和气球 right 就变成了相邻的气球。</p>
<p>求所能获得硬币的最大数量。</p>
<p>说明:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">你可以假设 nums[-1] = nums[n] = 1，但注意它们不是真实存在的所以并不能被戳破。  </span><br><span class="line">0 ≤ n ≤ 500, 0 ≤ nums[i] ≤ 100</span><br></pre></td></tr></table></figure>
<p>示例:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入: [3,1,5,8]</span><br><span class="line">输出: 167 </span><br><span class="line">解释: nums = [3,1,5,8] --&gt; [3,5,8] --&gt;   [3,8]   --&gt;  [8]  --&gt; []</span><br><span class="line">     coins =  3*1*5      +  3*5*8    +  1*3*8      + 1*8*1   = 167</span><br></pre></td></tr></table></figure>
<p><strong>version1</strong>    <br>
过程：  <br>
整个思考过程就是错误的。忧伤···</p>
<p><strong>标准答案</strong></p>
<p><strong>代码</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maxCoins</span><span class="params">(self, nums)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type nums: List[int]</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        nums = [<span class="number">1</span>] + nums + [<span class="number">1</span>]</span><br><span class="line">        n = len(nums)</span><br><span class="line">        dp = [[<span class="number">0</span>] * n <span class="keyword">for</span> _ <span class="keyword">in</span> xrange(n)]</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">calculate</span><span class="params">(i, j)</span>:</span></span><br><span class="line">            <span class="keyword">if</span> dp[i][j] <span class="keyword">or</span> j == i + <span class="number">1</span>: <span class="comment"># in memory or gap &lt; 2</span></span><br><span class="line">                <span class="keyword">return</span> dp[i][j]</span><br><span class="line">            coins = <span class="number">0</span></span><br><span class="line">            <span class="keyword">for</span> k <span class="keyword">in</span> xrange(i+<span class="number">1</span>, j): <span class="comment"># find the last balloon</span></span><br><span class="line">                coins = max(coins, nums[i] * nums[k] * nums[j] + calculate(i, k) + calculate(k, j))</span><br><span class="line">            dp[i][j] = coins</span><br><span class="line">            <span class="keyword">return</span> coins</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> calculate(<span class="number">0</span>, n<span class="number">-1</span>)</span><br></pre></td></tr></table></figure>
<h2 id="740-删除与获得点数"><a class="header-anchor" href="#740-删除与获得点数"></a>740.删除与获得点数</h2>
<h2 id="95-不同的二叉搜索树ii"><a class="header-anchor" href="#95-不同的二叉搜索树ii"></a>95.不同的二叉搜索树II</h2>
<h2 id="121-买卖股票的最佳时机-a-id-121"><a class="header-anchor" href="#121-买卖股票的最佳时机-a-id-121"></a>121.买卖股票的最佳时机<a id="121"></a></h2>
<p>状态：未通过，超时    <br>
<strong>题目</strong>  <br>
给定一个数组，它的第 i 个元素是一支给定股票第 i 天的价格。</p>
<p>如果你最多只允许完成一笔交易（即买入和卖出一支股票），设计一个算法来计算你所能获取的最大利润。</p>
<p>注意你不能在买入股票前卖出股票。</p>
<p>示例 1:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入: [7,1,5,3,6,4]</span><br><span class="line">输出: 5</span><br><span class="line">解释: 在第 2 天（股票价格 = 1）的时候买入，在第 5 天（股票价格 = 6）的时候卖出，最大利润 = 6-1 = 5 。</span><br><span class="line">     注意利润不能是 7-1 = 6, 因为卖出价格需要大于买入价格。</span><br></pre></td></tr></table></figure>
<p>示例 2:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: [7,6,4,3,1]</span><br><span class="line">输出: 0</span><br><span class="line">解释: 在这种情况下, 没有交易完成, 所以最大利润为 0。</span><br></pre></td></tr></table></figure>
<p><strong>version1</strong>    <br>
过程：  <br>
思路有，就是实现起来不够动态规划。所以会导致很慢，超时不通过。</p>
<p><strong>标准答案</strong>  <br>
标准答案是只需要一次遍历，求出答案，复杂度是O(N)。而我第一次版本是不止一次遍历的，不仅是明显写出的第一次循环还是隐性的求min,max（其实也是遍历）。</p>
<p><strong>代码</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maxProfit</span><span class="params">(self, prices)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type prices: List[int]</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        max_profit, min_price = <span class="number">0</span>, float(<span class="string">'inf'</span>)</span><br><span class="line">        <span class="keyword">for</span> price <span class="keyword">in</span> prices:</span><br><span class="line">            min_price = min(min_price, price)</span><br><span class="line">            profit = price - min_price</span><br><span class="line">            max_profit = max(max_profit, profit)</span><br><span class="line">        <span class="keyword">return</span> max_profit</span><br></pre></td></tr></table></figure>
<h2 id="931-下降路径最小和"><a class="header-anchor" href="#931-下降路径最小和"></a>931.下降路径最小和</h2>
<p>状态：排名98%      <br>
<strong>题目</strong>  <br>
给定一个方形整数数组 A，我们想要得到通过 A 的下降路径的最小和。</p>
<p>下降路径可以从第一行中的任何元素开始，并从每一行中选择一个元素。在下一行选择的元素和当前行所选元素最多相隔一列。</p>
<p>示例：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">输入：[[1,2,3],[4,5,6],[7,8,9]]</span><br><span class="line">输出：12</span><br><span class="line">解释：</span><br><span class="line">可能的下降路径有：</span><br><span class="line">[1,4,7], [1,4,8], [1,5,7], [1,5,8], [1,5,9]</span><br><span class="line">[2,4,7], [2,4,8], [2,5,7], [2,5,8], [2,5,9], [2,6,8], [2,6,9]</span><br><span class="line">[3,5,7], [3,5,8], [3,5,9], [3,6,8], [3,6,9]</span><br><span class="line"></span><br><span class="line">和最小的下降路径是 [1,4,7]，所以答案是 12。</span><br></pre></td></tr></table></figure>
<p>提示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1 &lt;= A.length == A[0].length &lt;= 100</span><br><span class="line">-100 &lt;= A[i][j] &lt;= 100</span><br></pre></td></tr></table></figure>
<p><strong>version1</strong>    <br>
过程：  <br>
<image src="https://res.cloudinary.com/sunflower/image/upload/v1545401185/Blog/931_progress.png" width="350"><br>
成绩：<br>
<image src="https://res.cloudinary.com/sunflower/image/upload/v1545401185/Blog/931_score.png" width="350">  <br>
这种类型的题目已经掌握了，笔试是不会怕了。<br>
相似题目有120，62。</image></image></p>
<p><strong>代码</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">minFallingPathSum</span><span class="params">(self, A)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type A: List[List[int]]</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">if</span> len(A) == <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> sum(A[<span class="number">0</span>])</span><br><span class="line">        <span class="keyword">if</span> len(A[<span class="number">0</span>]) == <span class="number">1</span>:</span><br><span class="line">            res = <span class="number">0</span></span><br><span class="line">            <span class="keyword">for</span> row <span class="keyword">in</span> range(len(A)):</span><br><span class="line">                res += A[row][<span class="number">0</span>]</span><br><span class="line">            <span class="keyword">return</span> res</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, len(A)):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(len(A[<span class="number">0</span>])):</span><br><span class="line">                <span class="keyword">if</span> j == <span class="number">0</span>:</span><br><span class="line">                    A[i][j] += min(A[i<span class="number">-1</span>][j], A[i<span class="number">-1</span>][j+<span class="number">1</span>])</span><br><span class="line">                <span class="keyword">elif</span> j == len(A[<span class="number">0</span>])<span class="number">-1</span>:</span><br><span class="line">                    A[i][j] += min(A[i<span class="number">-1</span>][j], A[i<span class="number">-1</span>][j<span class="number">-1</span>])</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    A[i][j] += min(A[i<span class="number">-1</span>][j], A[i<span class="number">-1</span>][j<span class="number">-1</span>], A[i<span class="number">-1</span>][j+<span class="number">1</span>])</span><br><span class="line">        <span class="keyword">return</span> min(A[<span class="number">-1</span>])</span><br></pre></td></tr></table></figure>
<h2 id="70-爬楼梯"><a class="header-anchor" href="#70-爬楼梯"></a>70.爬楼梯</h2>
<p>状态：未通过<br>
<strong>题目</strong>  <br>
假设你正在爬楼梯。需要 n 阶你才能到达楼顶。<br>
每次你可以爬 1 或 2 个台阶。你有多少种不同的方法可以爬到楼顶呢？<br>
注意：给定 n 是一个正整数。</p>
<p>示例 1：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入： 2</span><br><span class="line">输出： 2</span><br><span class="line">解释： 有两种方法可以爬到楼顶。</span><br><span class="line">1.  1 阶 + 1 阶</span><br><span class="line">2.  2 阶</span><br></pre></td></tr></table></figure>
<p>示例 2：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">输入： 3</span><br><span class="line">输出： 3</span><br><span class="line">解释： 有三种方法可以爬到楼顶。</span><br><span class="line">1.  1 阶 + 1 阶 + 1 阶</span><br><span class="line">2.  1 阶 + 2 阶</span><br><span class="line">3.  2 阶 + 1 阶</span><br></pre></td></tr></table></figure>
<p><strong>标准答案</strong>    <br>
爬楼梯是一道经典的动态规划类型题目。  <br>
这道题目是逆推。比如，要想爬10级楼梯，可以1次爬1级，也可以1次爬2级。如果现在考虑，只剩最后一步，那么有可能是最后一步爬1级，也有可能是最后一步爬2级。如果最后一步爬1级，那么问题转换为爬9级台阶的方式，同理可知，如果最后一步爬2级，就等价于秋节爬8级台阶的方法。  <br>
数学表达式：<br>
F(10)=F(9)+F(8)<br>
F(9)=F(8)+F(7)<br>
…</p>
<p><strong>代码</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">climbStairs</span><span class="params">(self, n)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type n: int</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">if</span> n == <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">        <span class="keyword">elif</span> n == <span class="number">2</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">2</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> self.climbStairs(n<span class="number">-1</span>) + self.climbStairs(n<span class="number">-2</span>)</span><br></pre></td></tr></table></figure>
<h2 id="152-乘积最大子序列"><a class="header-anchor" href="#152-乘积最大子序列"></a>152. 乘积最大子序列</h2>
<p>状态：未通过<br>
<strong>题目</strong>  <br>
给定一个整数数组 nums ，找出一个序列中乘积最大的连续子序列（该序列至少包含一个数）。</p>
<p>示例 1:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: [2,3,-2,4]</span><br><span class="line">输出: 6</span><br><span class="line">解释: 子数组 [2,3] 有最大乘积 6。</span><br></pre></td></tr></table></figure>
<p>示例 2:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: [-2,0,-1]</span><br><span class="line">输出: 0</span><br><span class="line">解释: 结果不能为 2, 因为 [-2,-1] 不是子数组。</span><br></pre></td></tr></table></figure>
<p><strong>标准答案</strong>    <br>
动态规划的题目做多了，直觉告诉我这题应该一次遍历即可得到答案。  <br>
连续子序列的最大值可能因为符号的变化，最大值瞬间变为最小值，最小值瞬间变为最大值，故这题的关键是记录当前遍历状态下的最大值与最小值。</p>
<p><strong>代码</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maxProduct</span><span class="params">(self, nums)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type nums: List[int]</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        maximum = big = small = nums[<span class="number">0</span>]</span><br><span class="line">        <span class="keyword">for</span> n <span class="keyword">in</span> nums[<span class="number">1</span>:]:</span><br><span class="line">            big, small = max(n, n * big, n * small), min(n, n * big, n * small)</span><br><span class="line">            maximum = max(maximum, big)</span><br><span class="line">        <span class="keyword">return</span> maximum</span><br></pre></td></tr></table></figure>
<h2 id="122-买卖股票的最佳时机-ii"><a class="header-anchor" href="#122-买卖股票的最佳时机-ii"></a>122. 买卖股票的最佳时机 II</h2>
<p>状态：未通过<br>
<strong>题目</strong>  <br>
给定一个数组，它的第 i 个元素是一支给定股票第 i 天的价格。<br>
设计一个算法来计算你所能获取的最大利润。你可以尽可能地完成更多的交易（多次买卖一支股票）。<br>
注意：你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。</p>
<p>示例 1:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入: [7,1,5,3,6,4]</span><br><span class="line">输出: 7</span><br><span class="line">解释: 在第 2 天（股票价格 = 1）的时候买入，在第 3 天（股票价格 = 5）的时候卖出, 这笔交易所能获得利润 = 5-1 = 4 。</span><br><span class="line">     随后，在第 4 天（股票价格 = 3）的时候买入，在第 5 天（股票价格 = 6）的时候卖出, 这笔交易所能获得利润 = 6-3 = 3 。</span><br></pre></td></tr></table></figure>
<p>示例 2:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入: [1,2,3,4,5]</span><br><span class="line">输出: 4</span><br><span class="line">解释: 在第 1 天（股票价格 = 1）的时候买入，在第 5 天 （股票价格 = 5）的时候卖出, 这笔交易所能获得利润 = 5-1 = 4 。</span><br><span class="line">     注意你不能在第 1 天和第 2 天接连购买股票，之后再将它们卖出。</span><br><span class="line">     因为这样属于同时参与了多笔交易，你必须在再次购买前出售掉之前的股票。</span><br></pre></td></tr></table></figure>
<p>示例 3:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: [7,6,4,3,1]</span><br><span class="line">输出: 0</span><br><span class="line">解释: 在这种情况下, 没有交易完成, 所以最大利润为 0。</span><br></pre></td></tr></table></figure>
<p><strong>标准答案</strong>    <br>
这题的题目背景与<a href="#121"><code>121.买卖股票的最佳时机</code></a>非常相似。但是不要搞混淆，题目给出的条件一点点的差异也可能导致解法大大不同。这题没有不允许同一天操作买入与卖出的交易行为，而121题则明确提出不可以。</p>
<p><strong>代码</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maxProfit</span><span class="params">(self, prices)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type prices: List[int]</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        res = []</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(prices)<span class="number">-1</span>):</span><br><span class="line">            <span class="keyword">if</span> prices[i+<span class="number">1</span>] &gt; prices[i]:</span><br><span class="line">                res.append(prices[i+<span class="number">1</span>]-prices[i])</span><br><span class="line">        <span class="keyword">return</span> sum(res)</span><br></pre></td></tr></table></figure>
<h2 id="200-岛屿的个数-a-id-200"><a class="header-anchor" href="#200-岛屿的个数-a-id-200"></a>200. 岛屿的个数<a id="200"></a></h2>
<p>状态：未通过<br>
<strong>题目</strong>  <br>
给定一个由’1’（陆地）和 ‘0’（水）组成的的二维网格，计算岛屿的数量。<br>
一个岛被水包围，并且它是通过水平方向或垂直方向上相邻的陆地连接而成的。<br>
你可以假设网格的四个边均被水包围。</p>
<p>示例 1:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">输入:</span><br><span class="line">11110</span><br><span class="line">11010</span><br><span class="line">11000</span><br><span class="line">00000</span><br><span class="line">输出: 1</span><br></pre></td></tr></table></figure>
<p>示例 2:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">输入:</span><br><span class="line">11000</span><br><span class="line">11000</span><br><span class="line">00100</span><br><span class="line">00011</span><br><span class="line">输出: 3</span><br></pre></td></tr></table></figure>
<p><strong>标准答案</strong>    <br>
深度优先搜索，在每次遍历中尽可能深入地迭代遍历。  <br>
在目标函数中调用自建的dfs函数，dfs函数中递归调用dfs函数本身。</p>
<p><strong>代码</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">numIslands</span><span class="params">(self, grid)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type grid: List[List[str]]</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> grid:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line"></span><br><span class="line">        count = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(grid)):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(len(grid[<span class="number">0</span>])):</span><br><span class="line">                <span class="keyword">if</span> grid[i][j] == <span class="string">'1'</span>:</span><br><span class="line">                    self.dfs(grid, i, j)</span><br><span class="line">                    count += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> count</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">dfs</span><span class="params">(self, grid, i, j)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> i &lt; <span class="number">0</span> <span class="keyword">or</span> j &lt; <span class="number">0</span> <span class="keyword">or</span> i &gt;= len(grid) <span class="keyword">or</span> j &gt;= len(grid[<span class="number">0</span>]) <span class="keyword">or</span> grid[i][j] != <span class="string">'1'</span>:</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        grid[i][j] = <span class="string">'#'</span></span><br><span class="line">        self.dfs(grid, i + <span class="number">1</span>, j)</span><br><span class="line">        self.dfs(grid, i - <span class="number">1</span>, j)</span><br><span class="line">        self.dfs(grid, i, j + <span class="number">1</span>)</span><br><span class="line">        self.dfs(grid, i, j - <span class="number">1</span>)</span><br></pre></td></tr></table></figure>
<h2 id="695-岛屿的最大面积"><a class="header-anchor" href="#695-岛屿的最大面积"></a>695. 岛屿的最大面积</h2>
<p>状态：排名53.56%     <br>
<strong>题目</strong>  <br>
给定一个包含了一些 0 和 1的非空二维数组 grid , 一个 岛屿 是由四个方向 (水平或垂直) 的 1 (代表土地) 构成的组合。你可以假设二维矩阵的四个边缘都被水包围着。</p>
<p>找到给定的二维数组中最大的岛屿面积。(如果没有岛屿，则返回面积为0。)</p>
<p>示例 1:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">[[0,0,1,0,0,0,0,1,0,0,0,0,0],</span><br><span class="line"> [0,0,0,0,0,0,0,1,1,1,0,0,0],</span><br><span class="line"> [0,1,1,0,1,0,0,0,0,0,0,0,0],</span><br><span class="line"> [0,1,0,0,1,1,0,0,1,0,1,0,0],</span><br><span class="line"> [0,1,0,0,1,1,0,0,1,1,1,0,0],</span><br><span class="line"> [0,0,0,0,0,0,0,0,0,0,1,0,0],</span><br><span class="line"> [0,0,0,0,0,0,0,1,1,1,0,0,0],</span><br><span class="line"> [0,0,0,0,0,0,0,1,1,0,0,0,0]]</span><br><span class="line">对于上面这个给定矩阵应返回 6。注意答案不应该是11，因为岛屿只能包含水平或垂直的四个方向的‘1’。</span><br></pre></td></tr></table></figure>
<p>示例 2:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[[0,0,0,0,0,0,0,0]]</span><br><span class="line">对于上面这个给定的矩阵, 返回 0。</span><br><span class="line">注意: 给定的矩阵grid 的长度和宽度都不超过 50。</span><br></pre></td></tr></table></figure>
<p><strong>version1</strong>    <br>
过程：  <br>
<image src="https://res.cloudinary.com/sunflower/image/upload/v1546343789/Blog/695_process.png" width="350"><br>
成绩：<br>
<image src="https://res.cloudinary.com/sunflower/image/upload/v1546343789/Blog/695_score.png" width="350">  <br>
与<a href="#200"><code>200. 岛屿的个数</code></a>类似，采用深度优先搜索的思想，200那题是计算岛屿的个数，这题计算岛屿的大小，大同小异。</image></image></p>
<p><strong>代码</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maxAreaOfIsland</span><span class="params">(self, grid)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type grid: List[List[int]]</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        res = [<span class="number">0</span>]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(grid)):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(len(grid[<span class="number">0</span>])):</span><br><span class="line">                area = <span class="number">0</span></span><br><span class="line">                tmp = self.dfs(grid, i, j, area)</span><br><span class="line">                <span class="keyword">if</span> tmp:</span><br><span class="line">                    res.append(tmp)</span><br><span class="line">        <span class="keyword">return</span> max(res)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">dfs</span><span class="params">(self, grid, i, j, area)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> i &lt; <span class="number">0</span> <span class="keyword">or</span> j &lt; <span class="number">0</span> <span class="keyword">or</span> i &gt;= len(grid) <span class="keyword">or</span> j &gt;= len(grid[<span class="number">0</span>]) <span class="keyword">or</span> grid[i][j] != <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        grid[i][j] = <span class="string">'#'</span></span><br><span class="line">        area = <span class="number">1</span></span><br><span class="line">        down = self.dfs(grid, i + <span class="number">1</span>, j, area)</span><br><span class="line">        <span class="keyword">if</span> down:</span><br><span class="line">            area += down</span><br><span class="line">        up = self.dfs(grid, i<span class="number">-1</span>, j, area)</span><br><span class="line">        <span class="keyword">if</span> up:</span><br><span class="line">            area += up</span><br><span class="line">        right = self.dfs(grid, i, j+<span class="number">1</span>, area)</span><br><span class="line">        <span class="keyword">if</span> right:</span><br><span class="line">            area += right</span><br><span class="line">        left = self.dfs(grid, i, j<span class="number">-1</span>, area)</span><br><span class="line">        <span class="keyword">if</span> left:</span><br><span class="line">            area += left</span><br><span class="line">        <span class="keyword">return</span> area</span><br></pre></td></tr></table></figure>
<h2 id="300-最长上升子序列"><a class="header-anchor" href="#300-最长上升子序列"></a>300. 最长上升子序列</h2>
<p>状态：不会     <br>
<strong>题目</strong>  <br>
给定一个无序的整数数组，找到其中最长上升子序列的长度。</p>
<p>示例:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: [10,9,2,5,3,7,101,9,18]</span><br><span class="line">输出: 4 </span><br><span class="line">解释: 最长的上升子序列是 [2,3,7,101]，它的长度是 4。</span><br></pre></td></tr></table></figure>
<p>说明:<br>
可能会有多种最长上升子序列的组合，你只需要输出对应的长度即可。<br>
你算法的时间复杂度应该为 O(n2) 。<br>
进阶: 你能将算法的时间复杂度降低到 O(n log n) 吗?</p>
<p><strong>标准答案</strong>    <br>
动态规划，设置两个指针i,j以及一个长度与给定数组相同的数组T，核心公式：<code>T[i]=max(T[i],T[j]+1)</code>。  <br>
具体讲解见Youtube：<a href="https://www.youtube.com/watch?v=CE2b_-XfVDk" target="_blank" rel="noopener">https://www.youtube.com/watch?v=CE2b_-XfVDk</a></p>
<p><strong>代码</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">lengthOfLIS</span><span class="params">(self, nums)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type nums: List[int]</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        res = []</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(nums)):</span><br><span class="line">            tmp = self.find_bigger(cur=nums[i], rest=nums[i+<span class="number">1</span>:])</span><br><span class="line">            <span class="keyword">if</span> tmp!= <span class="keyword">None</span>:</span><br><span class="line">                res.append(tmp+<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> max(res)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">find_bigger</span><span class="params">(self, cur, rest)</span>:</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(rest)):</span><br><span class="line">            <span class="keyword">if</span> rest[i] &gt; cur:</span><br><span class="line">                tmpp = self.find_bigger(rest[i], rest[i+<span class="number">1</span>:])</span><br><span class="line">                <span class="keyword">if</span> tmpp != <span class="keyword">None</span>:</span><br><span class="line">                    <span class="keyword">return</span> tmpp+<span class="number">1</span></span><br><span class="line">            <span class="keyword">elif</span> i == len(rest)<span class="number">-1</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    a = Solution()</span><br><span class="line">    print(a.lengthOfLIS(nums=[<span class="number">10</span>,<span class="number">9</span>,<span class="number">2</span>,<span class="number">5</span>,<span class="number">3</span>,<span class="number">7</span>,<span class="number">101</span>,<span class="number">9</span>,<span class="number">18</span>]))</span><br></pre></td></tr></table></figure>
<h2 id="416-分割等和子集-a-id-beibao"><a class="header-anchor" href="#416-分割等和子集-a-id-beibao"></a>416. 分割等和子集<a id="beibao"></a></h2>
<p>状态：不会     <br>
<strong>题目</strong>  <br>
给定一个只包含正整数的非空数组。是否可以将这个数组分割成两个子集，使得两个子集的元素和相等。</p>
<p>注意:<br>
每个数组中的元素不会超过 100<br>
数组的大小不会超过 200</p>
<p>示例 1:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: [1, 5, 11, 5]</span><br><span class="line">输出: true</span><br><span class="line">解释: 数组可以分割成 [1, 5, 5] 和 [11].</span><br></pre></td></tr></table></figure>
<p>示例 2:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: [1, 2, 3, 5]</span><br><span class="line">输出: false</span><br><span class="line">解释: 数组不能分割成两个元素和相等的子集.</span><br></pre></td></tr></table></figure>
<p><strong>标准答案</strong>    <br>
0/1背包问题，详细讲解见：<br>
<a href="https://www.youtube.com/watch?v=8LusJS5-AGo" target="_blank" rel="noopener">https://www.youtube.com/watch?v=8LusJS5-AGo</a>  <br>
这题背包的重量为sum/2,比背包问题简单，没有价值信息，更不用求价值最大值。</p>
<p><strong>代码</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">canPartition</span><span class="params">(self, nums)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type nums: List[int]</span></span><br><span class="line"><span class="string">        :rtype: bool</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        total = sum(nums)</span><br><span class="line">        <span class="keyword">if</span> total % <span class="number">2</span> == <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            total = int(total / <span class="number">2</span>)</span><br><span class="line">            dp = [[<span class="number">0</span> <span class="keyword">for</span> i <span class="keyword">in</span> range(total + <span class="number">1</span>)] <span class="keyword">for</span> j <span class="keyword">in</span> range(len(nums))]</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> range(nums[<span class="number">0</span>], total + <span class="number">1</span>):</span><br><span class="line">                dp[<span class="number">0</span>][i] = nums[<span class="number">0</span>]</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, len(nums)):</span><br><span class="line">                <span class="keyword">for</span> j <span class="keyword">in</span> range(nums[i], total + <span class="number">1</span>):</span><br><span class="line">                    dp[i][j] = max(dp[i - <span class="number">1</span>][j], dp[i - <span class="number">1</span>][j - nums[i]] + nums[i])</span><br><span class="line">            <span class="keyword">if</span> dp[len(nums) - <span class="number">1</span>][total] != total:</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">True</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    a = Solution()</span><br><span class="line">    print(a.canPartition(nums=[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>]))</span><br></pre></td></tr></table></figure>
<h2 id="322-零钱兑换"><a class="header-anchor" href="#322-零钱兑换"></a>322. 零钱兑换</h2>
<p>状态：不会     <br>
<strong>题目</strong>  <br>
给定不同面额的硬币 coins 和一个总金额 amount。<br>
编写一个函数来计算可以凑成总金额所需的最少的硬币个数。<br>
如果没有任何一种硬币组合能组成总金额，返回 -1。</p>
<p>示例 1:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: coins = [1, 2, 5], amount = 11</span><br><span class="line">输出: 3 </span><br><span class="line">解释: 11 = 5 + 5 + 1</span><br></pre></td></tr></table></figure>
<p>示例 2:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: coins = [2], amount = 3</span><br><span class="line">输出: -1</span><br></pre></td></tr></table></figure>
<p>说明:<br>
你可以认为每种硬币的数量是无限的。</p>
<p><strong>标准答案</strong>    <br>
<a href="#beibao"><code>经典0/1背包问题</code></a>的变种类型——完全背包，与01背包不同在于每种物品可以不止使用一次，物品个数是无限的。  <br>
解题关键在于当未计算或者使用该硬币，硬币总数量下降的就更新<code>dp[i]</code>。</p>
<p><strong>代码</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">coinChange</span><span class="params">(self, coins, amount)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type coins: List[int]</span></span><br><span class="line"><span class="string">        :type amount: int</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        dp = [<span class="number">-1</span>] * (amount + <span class="number">1</span>)</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, amount + <span class="number">1</span>):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">0</span>, len(coins)):</span><br><span class="line">                <span class="keyword">if</span> i &gt;= coins[j] <span class="keyword">and</span> dp[i - coins[j]] != <span class="number">-1</span>:</span><br><span class="line">                    <span class="keyword">if</span> dp[i] == <span class="number">-1</span> <span class="keyword">or</span> dp[i] &gt; dp[i - coins[j]] + <span class="number">1</span>:</span><br><span class="line">                        dp[i] = dp[i - coins[j]] + <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> dp[amount]</span><br><span class="line">        </span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    a = Solution()</span><br><span class="line">    print(a.coinChange(coins = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">5</span>], amount = <span class="number">11</span>))</span><br></pre></td></tr></table></figure>
<h2 id="377-组合总和-ⅳ-a-id-wanquanbeibao"><a class="header-anchor" href="#377-组合总和-ⅳ-a-id-wanquanbeibao"></a>377. 组合总和 Ⅳ<a id="wanquanbeibao"></a></h2>
<p>状态：不会     <br>
<strong>题目</strong>  <br>
给定一个由正整数组成且不存在重复数字的数组，找出和为给定目标正整数的组合的个数。</p>
<p>示例:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">nums = [1, 2, 3]</span><br><span class="line">target = 4</span><br><span class="line"></span><br><span class="line">所有可能的组合为：</span><br><span class="line">(1, 1, 1, 1)</span><br><span class="line">(1, 1, 2)</span><br><span class="line">(1, 2, 1)</span><br><span class="line">(1, 3)</span><br><span class="line">(2, 1, 1)</span><br><span class="line">(2, 2)</span><br><span class="line">(3, 1)</span><br></pre></td></tr></table></figure>
<p>请注意，顺序不同的序列被视作不同的组合。<br>
因此输出为 7。</p>
<p><strong>标准答案</strong>    <br>
<a href="#beibao"><code>经典0/1背包问题</code></a>的变种类型——完全背包，与Leetcode322相似，都是物品可以无限次使用，但是dp数组里记录的是不同组合个数。</p>
<p><strong>代码</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">combinationSum4</span><span class="params">(self, nums, target)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type nums: List[int]</span></span><br><span class="line"><span class="string">        :type target: int</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        dp = [<span class="number">0</span>] * (target + <span class="number">1</span>)</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">1</span>  <span class="comment"># if num == target</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, target + <span class="number">1</span>):</span><br><span class="line">            <span class="keyword">for</span> num <span class="keyword">in</span> nums:</span><br><span class="line">                <span class="keyword">if</span> i &gt;= num:</span><br><span class="line">                    dp[i] += dp[i - num]</span><br><span class="line">        <span class="keyword">return</span> dp[target]</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    a = Solution()</span><br><span class="line">    print(a.combinationSum4(nums = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>], target = <span class="number">4</span>))</span><br></pre></td></tr></table></figure>
<h2 id="474-一和零"><a class="header-anchor" href="#474-一和零"></a>474. 一和零</h2>
<p>状态：不会     <br>
<strong>题目</strong>  <br>
在计算机界中，我们总是追求用有限的资源获取最大的收益。<br>
现在，假设你分别支配着 m 个 0 和 n 个 1。另外，还有一个仅包含 0 和 1 字符串的数组。<br>
你的任务是使用给定的 m 个 0 和 n 个 1 ，找到能拼出存在于数组中的字符串的最大数量。每个 0 和 1 至多被使用一次。</p>
<p>注意:<br>
给定 0 和 1 的数量都不会超过 100。<br>
给定字符串数组的长度不会超过 600。</p>
<p>示例 1:<br>
输入: Array = {“10”, “0001”, “111001”, “1”, “0”}, m = 5, n = 3<br>
输出: 4<br>
解释: 总共 4 个字符串可以通过 5 个 0 和 3 个 1 拼出，即 “10”,“0001”,“1”,“0” 。</p>
<p>示例 2:<br>
输入: Array = {“10”, “0”, “1”}, m = 1, n = 1<br>
输出: 2<br>
解释: 你可以拼出 “10”，但之后就没有剩余数字了。更好的选择是拼出 “0” 和 “1” 。</p>
<p><strong>标准答案</strong>    <br>
<a href="#beibao"><code>经典0/1背包问题</code></a>的变种类型——多维背包问题，不仅考虑物品的重量，而是要衡量物品的重量和体积，并且这里求的不是背包的最大价值，而是可能性中包含的最大字符串个数。</p>
<p><strong>代码</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">findMaxForm</span><span class="params">(self, strs, m, n)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type strs: List[str]</span></span><br><span class="line"><span class="string">        :type m: int</span></span><br><span class="line"><span class="string">        :type n: int</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        dp = [[<span class="number">0</span>] * (n + <span class="number">1</span>) <span class="keyword">for</span> _ <span class="keyword">in</span> range(m + <span class="number">1</span>)]</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> item <span class="keyword">in</span> strs:</span><br><span class="line">            z = item.count(<span class="string">'0'</span>)</span><br><span class="line">            o = item.count(<span class="string">'1'</span>)</span><br><span class="line">            <span class="keyword">for</span> x <span class="keyword">in</span> range(m, <span class="number">-1</span>, <span class="number">-1</span>):</span><br><span class="line">                <span class="keyword">for</span> y <span class="keyword">in</span> range(n, <span class="number">-1</span>, <span class="number">-1</span>):</span><br><span class="line">                    <span class="keyword">if</span> x &gt;= z <span class="keyword">and</span> y &gt;= o:</span><br><span class="line">                        dp[x][y] = max(<span class="number">1</span> + dp[x - z][y - o], dp[x][y])</span><br><span class="line">        <span class="keyword">return</span> dp[m][n]</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    a = Solution()</span><br><span class="line">    print(a.findMaxForm(strs=[<span class="string">"10"</span>, <span class="string">"0001"</span>, <span class="string">"111001"</span>, <span class="string">"1"</span>, <span class="string">"0"</span>], m = <span class="number">5</span>, n = <span class="number">3</span>))</span><br></pre></td></tr></table></figure>
<h2 id="139-单词拆分"><a class="header-anchor" href="#139-单词拆分"></a>139. 单词拆分</h2>
<p>状态：不会     <br>
<strong>题目</strong>  <br>
给定一个非空字符串 s 和一个包含非空单词列表的字典 wordDict，判定 s 是否可以被空格拆分为一个或多个在字典中出现的单词。</p>
<p>说明：<br>
拆分时可以重复使用字典中的单词。<br>
你可以假设字典中没有重复的单词。</p>
<p>示例 1：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: s = &quot;leetcode&quot;, wordDict = [&quot;leet&quot;, &quot;code&quot;]</span><br><span class="line">输出: true</span><br><span class="line">解释: 返回 true 因为 &quot;leetcode&quot; 可以被拆分成 &quot;leet code&quot;。</span><br></pre></td></tr></table></figure>
<p>示例 2：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入: s = &quot;applepenapple&quot;, wordDict = [&quot;apple&quot;, &quot;pen&quot;]</span><br><span class="line">输出: true</span><br><span class="line">解释: 返回 true 因为 &quot;applepenapple&quot; 可以被拆分成 &quot;apple pen apple&quot;。</span><br><span class="line">     注意你可以重复使用字典中的单词。</span><br></pre></td></tr></table></figure>
<p>示例 3：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: s = &quot;catsandog&quot;, wordDict = [&quot;cats&quot;, &quot;dog&quot;, &quot;sand&quot;, &quot;and&quot;, &quot;cat&quot;]</span><br><span class="line">输出: false</span><br></pre></td></tr></table></figure>
<p><strong>标准答案</strong>    <br>
属于<a href="#wanquanbeibao"><code>完全背包问题</code></a>,考察的标准不再是体重，价值之类的数值型标准了，而是字符串。dp数组记录当前位置i是否可分。</p>
<p><strong>代码</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">wordBreak</span><span class="params">(self, s, wordDict)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type s: str</span></span><br><span class="line"><span class="string">        :type wordDict: List[str]</span></span><br><span class="line"><span class="string">        :rtype: bool</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        dp = [<span class="keyword">False</span>] * (len(s) + <span class="number">1</span>)  <span class="comment"># dp[i] means s[:i+1] can be segmented into words in the wordDicts</span></span><br><span class="line">        dp[<span class="number">0</span>] = <span class="keyword">True</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(s)):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(i+<span class="number">1</span>, len(s)):</span><br><span class="line">                <span class="keyword">if</span> dp[i] <span class="keyword">and</span> s[i: j] <span class="keyword">in</span> wordDict:</span><br><span class="line">                    dp[j] = <span class="keyword">True</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> dp[<span class="number">-1</span>]</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    a = Solution()</span><br><span class="line">    print(a.wordBreak(s=<span class="string">"catsandog"</span>, wordDict=[<span class="string">"cats"</span>, <span class="string">"dog"</span>, <span class="string">"sand"</span>, <span class="string">"and"</span>, <span class="string">"cat"</span>]))</span><br></pre></td></tr></table></figure>
<h2 id="494-目标和"><a class="header-anchor" href="#494-目标和"></a>494. 目标和</h2>
<p>状态：不会     <br>
<strong>题目</strong>  <br>
给定一个非负整数数组，a1, a2, …, an, 和一个目标数，S。现在你有两个符号 + 和 -。<br>
对于数组中的任意一个整数，你都可以从 + 或 -中选择一个符号添加在前面。</p>
<p>返回可以使最终数组和为目标数 S 的所有添加符号的方法数。</p>
<p>示例 1:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">输入: nums: [1, 1, 1, 1, 1], S: 3</span><br><span class="line">输出: 5</span><br><span class="line">解释: </span><br><span class="line">-1+1+1+1+1 = 3</span><br><span class="line">+1-1+1+1+1 = 3</span><br><span class="line">+1+1-1+1+1 = 3</span><br><span class="line">+1+1+1-1+1 = 3</span><br><span class="line">+1+1+1+1-1 = 3</span><br><span class="line"></span><br><span class="line">一共有5种方法让最终目标和为3。</span><br></pre></td></tr></table></figure>
<p>注意:<br>
数组的长度不会超过20，并且数组中的值全为正数。<br>
初始的数组的和不会超过1000。<br>
保证返回的最终结果为32位整数。</p>
<p><strong>标准答案</strong>    <br>
这题要根据公式推导转换为背包问题  <br>
在nums中，有部分正数和负数。p表示所有正数的集合，q表示所有负数的集合，那么有sum§ - sum(q) = S，<br>
sum§ + sum(q) = sum(all)  <br>
以上两个公式转换可得：<br>
sum§ = (sum(all) + S)/2  <br>
那么，这个问题转换为单纯的背包价值问题。选择将不同价值的物品放入背包与否。</p>
<p><strong>代码</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">findTargetSumWays</span><span class="params">(self, nums, S)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type nums: List[int]</span></span><br><span class="line"><span class="string">        :type S: int</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        s = sum(nums)</span><br><span class="line">        N = s + S</span><br><span class="line">        <span class="keyword">if</span> N % <span class="number">2</span> <span class="keyword">or</span> S &gt; s: <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        N = N // <span class="number">2</span></span><br><span class="line">        dp = [<span class="number">0</span> <span class="keyword">for</span> _ <span class="keyword">in</span> range(N + <span class="number">1</span>)]</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> num <span class="keyword">in</span> nums:</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> range(N, num - <span class="number">1</span>, <span class="number">-1</span>):</span><br><span class="line">                dp[i] += dp[i - num]</span><br><span class="line">        <span class="keyword">return</span> dp[<span class="number">-1</span>]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    a = Solution()</span><br><span class="line">    print(a.findTargetSumWays(nums=[<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>], S=<span class="number">3</span>))</span><br></pre></td></tr></table></figure>
<h2 id="547-朋友圈"><a class="header-anchor" href="#547-朋友圈"></a>547. 朋友圈</h2>
<p>状态：不会     <br>
<strong>题目</strong>  <br>
班上有 N 名学生。其中有些人是朋友，有些则不是。他们的友谊具有是传递性。<br>
如果已知 A 是 B 的朋友，B 是 C 的朋友，那么我们可以认为 A 也是 C 的朋友。<br>
所谓的朋友圈，是指所有朋友的集合。</p>
<p>给定一个 N * N 的矩阵 M，表示班级中学生之间的朋友关系。<br>
如果M[i][j] = 1，表示已知第 i 个和 j 个学生互为朋友关系，否则为不知道。<br>
你必须输出所有学生中的已知的朋友圈总数。</p>
<p>示例 1:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">输入: </span><br><span class="line">[[1,1,0],</span><br><span class="line"> [1,1,0],</span><br><span class="line"> [0,0,1]]</span><br><span class="line">输出: 2 </span><br><span class="line">说明：已知学生0和学生1互为朋友，他们在一个朋友圈。</span><br><span class="line">第2个学生自己在一个朋友圈。所以返回2。</span><br></pre></td></tr></table></figure>
<p>示例 2:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">输入: </span><br><span class="line">[[1,1,0],</span><br><span class="line"> [1,1,1],</span><br><span class="line"> [0,1,1]]</span><br><span class="line">输出: 1</span><br><span class="line">说明：已知学生0和学生1互为朋友，学生1和学生2互为朋友，所以学生0和学生2也是朋友，所以他们三个在一个朋友圈，返回1。</span><br></pre></td></tr></table></figure>
<p><strong>标准答案</strong>    <br>
这题有两种解题思路，一个是DFS，另一个是并查集。<br>
DFS：<br>
依次遍历每个人，查看当前这个人所有的关系网，如果这个人有新朋友，添加到已查看集合中去，并再次查看这个新朋友的关系网，依次循环往复。</p>
<p><strong>DFS代码</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">findCircleNum</span><span class="params">(self, M)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type M: List[List[int]]</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        N = len(M)</span><br><span class="line">        seen = set()</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">dfs</span><span class="params">(node)</span>:</span></span><br><span class="line">            <span class="keyword">for</span> nei, adj <span class="keyword">in</span> enumerate(M[node]):</span><br><span class="line">                <span class="keyword">if</span> adj <span class="keyword">and</span> nei <span class="keyword">not</span> <span class="keyword">in</span> seen:</span><br><span class="line">                    seen.add(nei)</span><br><span class="line">                    dfs(nei)</span><br><span class="line"></span><br><span class="line">        ans = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(N):</span><br><span class="line">            <span class="keyword">if</span> i <span class="keyword">not</span> <span class="keyword">in</span> seen:</span><br><span class="line">                dfs(i)</span><br><span class="line">                ans += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> ans</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    a = Solution()</span><br><span class="line">    print(a.findCircleNum(M=[[<span class="number">1</span>,<span class="number">1</span>,<span class="number">0</span>], [<span class="number">1</span>,<span class="number">1</span>,<span class="number">0</span>], [<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>]]))</span><br></pre></td></tr></table></figure>
<p><strong>并查集代码</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">class UnionFind(object):</span><br><span class="line">    def __init__(self, grid):</span><br><span class="line">        self.n = len(grid)</span><br><span class="line">        self.parent = [-1] * self.n</span><br><span class="line">        for idx in range(self.n):</span><br><span class="line">            self.parent[idx] = idx</span><br><span class="line"></span><br><span class="line">    def find(self, i):</span><br><span class="line">        if self.parent[i] != i:</span><br><span class="line">            self.parent[i] = self.find(self.parent[i])</span><br><span class="line">        return self.parent[i]</span><br><span class="line"></span><br><span class="line">    def union(self, x, y):</span><br><span class="line">        rootx = self.find(x)</span><br><span class="line">        rooty = self.find(y)</span><br><span class="line">        if rootx != rooty:</span><br><span class="line">            self.parent[rooty] = rootx</span><br><span class="line"></span><br><span class="line">    def diff_groups(self):</span><br><span class="line">        diff_groups = set()</span><br><span class="line">        for i in range(self.n):</span><br><span class="line">            diff_groups.add(self.find(i))</span><br><span class="line">        return len(diff_groups)</span><br><span class="line"></span><br><span class="line">class Solution(object):</span><br><span class="line">    def findCircleNum(self, M):</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        :type M: List[List[int]]</span><br><span class="line">        :rtype: int</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        n = len(M)</span><br><span class="line">        uf = UnionFind(M)</span><br><span class="line"></span><br><span class="line">        for i in range(n):</span><br><span class="line">            for j in range(n):</span><br><span class="line">                if M[i][j] == 1:</span><br><span class="line">                    uf.union(i, j)</span><br><span class="line"></span><br><span class="line">        return uf.diff_groups()</span><br><span class="line"></span><br><span class="line">if __name__ == &quot;__main__&quot;:</span><br><span class="line">    a = Solution()</span><br><span class="line">    M = [[1, 1, 0], [1, 1, 0], [0, 0, 1]]</span><br><span class="line">    print(a.findCircleNum(M=M))</span><br></pre></td></tr></table></figure></image>
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/Leetcode/" rel="tag"><i class="fa fa-tag"></i> Leetcode</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2018/09/06/校招编程题总结/" rel="next" title="校招笔试记录">
                <i class="fa fa-chevron-left"></i> 校招笔试记录
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          

  
    <div class="comments" id="comments">
      
        <div id="gitment-container"></div>
      
    </div>

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            Table of Contents
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            Overview
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image"
                src="/images/avatar.jpg"
                alt="sunflowerJY" />
            
              <p class="site-author-name" itemprop="name">sunflowerJY</p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">15</span>
                  <span class="site-state-item-name">posts</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">4</span>
                  <span class="site-state-item-name">categories</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">12</span>
                  <span class="site-state-item-name">tags</span>
                </a>
              </div>
            

          </nav>

          

          

          
          

          
          

          

        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#规划"><span class="nav-number">1.</span> <span class="nav-text">规划</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#数据结构"><span class="nav-number">2.</span> <span class="nav-text">数据结构</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#数组"><span class="nav-number">2.1.</span> <span class="nav-text">数组</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#树"><span class="nav-number">2.2.</span> <span class="nav-text">树</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#基础知识"><span class="nav-number">2.2.1.</span> <span class="nav-text">基础知识</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#二叉树"><span class="nav-number">2.2.2.</span> <span class="nav-text">二叉树</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#二叉查找树-左-中-右"><span class="nav-number">2.2.2.1.</span> <span class="nav-text">二叉查找树（左&lt;中&lt;右）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#哈夫曼树-最优二叉树"><span class="nav-number">2.2.2.2.</span> <span class="nav-text">哈夫曼树(最优二叉树)</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#二叉树的遍历"><span class="nav-number">2.2.3.</span> <span class="nav-text">二叉树的遍历</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#几种转换"><span class="nav-number">2.2.4.</span> <span class="nav-text">几种转换</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#栈"><span class="nav-number">2.3.</span> <span class="nav-text">栈</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#基础知识-v2"><span class="nav-number">2.3.1.</span> <span class="nav-text">基础知识</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#存储"><span class="nav-number">2.3.2.</span> <span class="nav-text">存储</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#出栈顺序"><span class="nav-number">2.3.3.</span> <span class="nav-text">出栈顺序</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#前缀表达式"><span class="nav-number">2.3.4.</span> <span class="nav-text">前缀表达式</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#汉诺塔-hanoi"><span class="nav-number">2.3.5.</span> <span class="nav-text">汉诺塔(Hanoi)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#复杂度"><span class="nav-number">2.3.6.</span> <span class="nav-text">复杂度</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#卡特兰数"><span class="nav-number">2.3.7.</span> <span class="nav-text">卡特兰数</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#哈希"><span class="nav-number">2.4.</span> <span class="nav-text">哈希</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#基本知识"><span class="nav-number">2.4.1.</span> <span class="nav-text">基本知识</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#哈希函数"><span class="nav-number">2.4.2.</span> <span class="nav-text">哈希函数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#避免哈希冲突"><span class="nav-number">2.4.3.</span> <span class="nav-text">避免哈希冲突</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#数据结构总结"><span class="nav-number">2.5.</span> <span class="nav-text">数据结构总结</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#算法"><span class="nav-number">3.</span> <span class="nav-text">算法</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#排序"><span class="nav-number">3.1.</span> <span class="nav-text">排序</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#分类"><span class="nav-number">3.1.1.</span> <span class="nav-text">分类</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#归纳表"><span class="nav-number">3.1.2.</span> <span class="nav-text">归纳表</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#图的遍历算法"><span class="nav-number">3.2.</span> <span class="nav-text">图的遍历算法</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#深度优先搜索-deep-first-search-dfs"><span class="nav-number">3.2.1.</span> <span class="nav-text">深度优先搜索(Deep First Search,DFS)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#广度优先搜索-breadth-first-search-bfs"><span class="nav-number">3.2.2.</span> <span class="nav-text">广度优先搜索(Breadth First Search,BFS)</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#动态规划"><span class="nav-number">3.3.</span> <span class="nav-text">动态规划</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#最长公共子序列"><span class="nav-number">3.3.1.</span> <span class="nav-text">最长公共子序列</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#背包问题"><span class="nav-number">3.3.2.</span> <span class="nav-text">背包问题</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#并查集"><span class="nav-number">3.4.</span> <span class="nav-text">并查集</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#动态连通性"><span class="nav-number">3.4.1.</span> <span class="nav-text">动态连通性</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#步骤"><span class="nav-number">3.4.2.</span> <span class="nav-text">步骤</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#代码"><span class="nav-number">3.4.3.</span> <span class="nav-text">代码</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#leetcode题目"><span class="nav-number">4.</span> <span class="nav-text">Leetcode题目</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#96-不同的二叉搜索树"><span class="nav-number">4.1.</span> <span class="nav-text">96.不同的二叉搜索树</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#413-等差数列划分"><span class="nav-number">4.2.</span> <span class="nav-text">413. 等差数列划分</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#120-三角形最小路径和"><span class="nav-number">4.3.</span> <span class="nav-text">120. 三角形最小路径和</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#62-不同路径"><span class="nav-number">4.4.</span> <span class="nav-text">62. 不同路径</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#712-两个字符串的最小ascii删除和"><span class="nav-number">4.5.</span> <span class="nav-text">712. 两个字符串的最小ASCII删除和</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#647-回文子串"><span class="nav-number">4.6.</span> <span class="nav-text">647. 回文子串</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#303-区域和检索-数组不可变"><span class="nav-number">4.7.</span> <span class="nav-text">303. 区域和检索 - 数组不可变</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#343-整数拆分"><span class="nav-number">4.8.</span> <span class="nav-text">343. 整数拆分</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#638-大礼包"><span class="nav-number">4.9.</span> <span class="nav-text">638. 大礼包</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#312-戳气球"><span class="nav-number">4.10.</span> <span class="nav-text">312. 戳气球</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#740-删除与获得点数"><span class="nav-number">4.11.</span> <span class="nav-text">740.删除与获得点数</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#95-不同的二叉搜索树ii"><span class="nav-number">4.12.</span> <span class="nav-text">95.不同的二叉搜索树II</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#121-买卖股票的最佳时机-a-id-121"><span class="nav-number">4.13.</span> <span class="nav-text">121.买卖股票的最佳时机</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#931-下降路径最小和"><span class="nav-number">4.14.</span> <span class="nav-text">931.下降路径最小和</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#70-爬楼梯"><span class="nav-number">4.15.</span> <span class="nav-text">70.爬楼梯</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#152-乘积最大子序列"><span class="nav-number">4.16.</span> <span class="nav-text">152. 乘积最大子序列</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#122-买卖股票的最佳时机-ii"><span class="nav-number">4.17.</span> <span class="nav-text">122. 买卖股票的最佳时机 II</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#200-岛屿的个数-a-id-200"><span class="nav-number">4.18.</span> <span class="nav-text">200. 岛屿的个数</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#695-岛屿的最大面积"><span class="nav-number">4.19.</span> <span class="nav-text">695. 岛屿的最大面积</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#300-最长上升子序列"><span class="nav-number">4.20.</span> <span class="nav-text">300. 最长上升子序列</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#416-分割等和子集-a-id-beibao"><span class="nav-number">4.21.</span> <span class="nav-text">416. 分割等和子集</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#322-零钱兑换"><span class="nav-number">4.22.</span> <span class="nav-text">322. 零钱兑换</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#377-组合总和-ⅳ-a-id-wanquanbeibao"><span class="nav-number">4.23.</span> <span class="nav-text">377. 组合总和 Ⅳ</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#474-一和零"><span class="nav-number">4.24.</span> <span class="nav-text">474. 一和零</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#139-单词拆分"><span class="nav-number">4.25.</span> <span class="nav-text">139. 单词拆分</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#494-目标和"><span class="nav-number">4.26.</span> <span class="nav-text">494. 目标和</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#547-朋友圈"><span class="nav-number">4.27.</span> <span class="nav-text">547. 朋友圈</span></a></li></ol></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2019</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">sunflowerJY</span>

  
</div>
        
<div class="busuanzi-count">
  <script async src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script>

  
    <span class="site-uv">
      <i class="fa fa-user"></i> 访问人数
      <span class="busuanzi-value" id="busuanzi_value_site_uv"></span>
      
    </span>
  

  
</div>








        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  


  











  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  

  
  
    <script type="text/javascript" src="/lib/canvas-nest/canvas-nest.min.js"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.4"></script>



  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.4"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.4"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  







<!-- LOCAL: You can save these files to your site and update links -->
    
        
        <link rel="stylesheet" href="https://aimingoo.github.io/gitmint/style/default.css">
        <script src="https://aimingoo.github.io/gitmint/dist/gitmint.browser.js"></script>
    
<!-- END LOCAL -->

    

    
      <script type="text/javascript">
      function renderGitment(){
        var gitment = new Gitmint({
			id: '1544171040000', 
            owner: 'sunflowerJY',
            repo: 'gitment-comments',
            
            lang: "" || navigator.language || navigator.systemLanguage || navigator.userLanguage,
            
            oauth: {
            
            
                client_secret: '50caad7a61fb5f6d84fc9a66653e6ff625d1db57',
            
                client_id: '5321cd82f4205f8b784e'
            }});
        gitment.render('gitment-container');
      }

      
      renderGitment();
      
      </script>
    







  

  <script type="text/javascript">
    // Popup Window;
    var isfetched = false;
    var isXml = true;
    // Search DB path;
    var search_path = "search.xml";
    if (search_path.length === 0) {
      search_path = "search.xml";
    } else if (/json$/i.test(search_path)) {
      isXml = false;
    }
    var path = "/" + search_path;
    // monitor main search box;

    var onPopupClose = function (e) {
      $('.popup').hide();
      $('#local-search-input').val('');
      $('.search-result-list').remove();
      $('#no-result').remove();
      $(".local-search-pop-overlay").remove();
      $('body').css('overflow', '');
    }

    function proceedsearch() {
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay"></div>')
        .css('overflow', 'hidden');
      $('.search-popup-overlay').click(onPopupClose);
      $('.popup').toggle();
      var $localSearchInput = $('#local-search-input');
      $localSearchInput.attr("autocapitalize", "none");
      $localSearchInput.attr("autocorrect", "off");
      $localSearchInput.focus();
    }

    // search function;
    var searchFunc = function(path, search_id, content_id) {
      'use strict';

      // start loading animation
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay">' +
          '<div id="search-loading-icon">' +
          '<i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>' +
          '</div>' +
          '</div>')
        .css('overflow', 'hidden');
      $("#search-loading-icon").css('margin', '20% auto 0 auto').css('text-align', 'center');

      $.ajax({
        url: path,
        dataType: isXml ? "xml" : "json",
        async: true,
        success: function(res) {
          // get the contents from search data
          isfetched = true;
          $('.popup').detach().appendTo('.header-inner');
          var datas = isXml ? $("entry", res).map(function() {
            return {
              title: $("title", this).text(),
              content: $("content",this).text(),
              url: $("url" , this).text()
            };
          }).get() : res;
          var input = document.getElementById(search_id);
          var resultContent = document.getElementById(content_id);
          var inputEventFunction = function() {
            var searchText = input.value.trim().toLowerCase();
            var keywords = searchText.split(/[\s\-]+/);
            if (keywords.length > 1) {
              keywords.push(searchText);
            }
            var resultItems = [];
            if (searchText.length > 0) {
              // perform local searching
              datas.forEach(function(data) {
                var isMatch = false;
                var hitCount = 0;
                var searchTextCount = 0;
                var title = data.title.trim();
                var titleInLowerCase = title.toLowerCase();
                var content = data.content.trim().replace(/<[^>]+>/g,"");
                var contentInLowerCase = content.toLowerCase();
                var articleUrl = decodeURIComponent(data.url);
                var indexOfTitle = [];
                var indexOfContent = [];
                // only match articles with not empty titles
                if(title != '') {
                  keywords.forEach(function(keyword) {
                    function getIndexByWord(word, text, caseSensitive) {
                      var wordLen = word.length;
                      if (wordLen === 0) {
                        return [];
                      }
                      var startPosition = 0, position = [], index = [];
                      if (!caseSensitive) {
                        text = text.toLowerCase();
                        word = word.toLowerCase();
                      }
                      while ((position = text.indexOf(word, startPosition)) > -1) {
                        index.push({position: position, word: word});
                        startPosition = position + wordLen;
                      }
                      return index;
                    }

                    indexOfTitle = indexOfTitle.concat(getIndexByWord(keyword, titleInLowerCase, false));
                    indexOfContent = indexOfContent.concat(getIndexByWord(keyword, contentInLowerCase, false));
                  });
                  if (indexOfTitle.length > 0 || indexOfContent.length > 0) {
                    isMatch = true;
                    hitCount = indexOfTitle.length + indexOfContent.length;
                  }
                }

                // show search results

                if (isMatch) {
                  // sort index by position of keyword

                  [indexOfTitle, indexOfContent].forEach(function (index) {
                    index.sort(function (itemLeft, itemRight) {
                      if (itemRight.position !== itemLeft.position) {
                        return itemRight.position - itemLeft.position;
                      } else {
                        return itemLeft.word.length - itemRight.word.length;
                      }
                    });
                  });

                  // merge hits into slices

                  function mergeIntoSlice(text, start, end, index) {
                    var item = index[index.length - 1];
                    var position = item.position;
                    var word = item.word;
                    var hits = [];
                    var searchTextCountInSlice = 0;
                    while (position + word.length <= end && index.length != 0) {
                      if (word === searchText) {
                        searchTextCountInSlice++;
                      }
                      hits.push({position: position, length: word.length});
                      var wordEnd = position + word.length;

                      // move to next position of hit

                      index.pop();
                      while (index.length != 0) {
                        item = index[index.length - 1];
                        position = item.position;
                        word = item.word;
                        if (wordEnd > position) {
                          index.pop();
                        } else {
                          break;
                        }
                      }
                    }
                    searchTextCount += searchTextCountInSlice;
                    return {
                      hits: hits,
                      start: start,
                      end: end,
                      searchTextCount: searchTextCountInSlice
                    };
                  }

                  var slicesOfTitle = [];
                  if (indexOfTitle.length != 0) {
                    slicesOfTitle.push(mergeIntoSlice(title, 0, title.length, indexOfTitle));
                  }

                  var slicesOfContent = [];
                  while (indexOfContent.length != 0) {
                    var item = indexOfContent[indexOfContent.length - 1];
                    var position = item.position;
                    var word = item.word;
                    // cut out 100 characters
                    var start = position - 20;
                    var end = position + 80;
                    if(start < 0){
                      start = 0;
                    }
                    if (end < position + word.length) {
                      end = position + word.length;
                    }
                    if(end > content.length){
                      end = content.length;
                    }
                    slicesOfContent.push(mergeIntoSlice(content, start, end, indexOfContent));
                  }

                  // sort slices in content by search text's count and hits' count

                  slicesOfContent.sort(function (sliceLeft, sliceRight) {
                    if (sliceLeft.searchTextCount !== sliceRight.searchTextCount) {
                      return sliceRight.searchTextCount - sliceLeft.searchTextCount;
                    } else if (sliceLeft.hits.length !== sliceRight.hits.length) {
                      return sliceRight.hits.length - sliceLeft.hits.length;
                    } else {
                      return sliceLeft.start - sliceRight.start;
                    }
                  });

                  // select top N slices in content

                  var upperBound = parseInt('1');
                  if (upperBound >= 0) {
                    slicesOfContent = slicesOfContent.slice(0, upperBound);
                  }

                  // highlight title and content

                  function highlightKeyword(text, slice) {
                    var result = '';
                    var prevEnd = slice.start;
                    slice.hits.forEach(function (hit) {
                      result += text.substring(prevEnd, hit.position);
                      var end = hit.position + hit.length;
                      result += '<b class="search-keyword">' + text.substring(hit.position, end) + '</b>';
                      prevEnd = end;
                    });
                    result += text.substring(prevEnd, slice.end);
                    return result;
                  }

                  var resultItem = '';

                  if (slicesOfTitle.length != 0) {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + highlightKeyword(title, slicesOfTitle[0]) + "</a>";
                  } else {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + title + "</a>";
                  }

                  slicesOfContent.forEach(function (slice) {
                    resultItem += "<a href='" + articleUrl + "'>" +
                      "<p class=\"search-result\">" + highlightKeyword(content, slice) +
                      "...</p>" + "</a>";
                  });

                  resultItem += "</li>";
                  resultItems.push({
                    item: resultItem,
                    searchTextCount: searchTextCount,
                    hitCount: hitCount,
                    id: resultItems.length
                  });
                }
              })
            };
            if (keywords.length === 1 && keywords[0] === "") {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-search fa-5x" /></div>'
            } else if (resultItems.length === 0) {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-frown-o fa-5x" /></div>'
            } else {
              resultItems.sort(function (resultLeft, resultRight) {
                if (resultLeft.searchTextCount !== resultRight.searchTextCount) {
                  return resultRight.searchTextCount - resultLeft.searchTextCount;
                } else if (resultLeft.hitCount !== resultRight.hitCount) {
                  return resultRight.hitCount - resultLeft.hitCount;
                } else {
                  return resultRight.id - resultLeft.id;
                }
              });
              var searchResultList = '<ul class=\"search-result-list\">';
              resultItems.forEach(function (result) {
                searchResultList += result.item;
              })
              searchResultList += "</ul>";
              resultContent.innerHTML = searchResultList;
            }
          }

          if ('auto' === 'auto') {
            input.addEventListener('input', inputEventFunction);
          } else {
            $('.search-icon').click(inputEventFunction);
            input.addEventListener('keypress', function (event) {
              if (event.keyCode === 13) {
                inputEventFunction();
              }
            });
          }

          // remove loading animation
          $(".local-search-pop-overlay").remove();
          $('body').css('overflow', '');

          proceedsearch();
        }
      });
    }

    // handle and trigger popup window;
    $('.popup-trigger').click(function(e) {
      e.stopPropagation();
      if (isfetched === false) {
        searchFunc(path, 'local-search-input', 'local-search-result');
      } else {
        proceedsearch();
      };
    });

    $('.popup-btn-close').click(onPopupClose);
    $('.popup').click(function(e){
      e.stopPropagation();
    });
    $(document).on('keyup', function (event) {
      var shouldDismissSearchPopup = event.which === 27 &&
        $('.search-popup').is(':visible');
      if (shouldDismissSearchPopup) {
        onPopupClose();
      }
    });
  </script>





  

  

  

  
  

  
  
    <script type="text/x-mathjax-config">
      MathJax.Hub.Config({
        tex2jax: {
          inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
          processEscapes: true,
          skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
        }
      });
    </script>

    <script type="text/x-mathjax-config">
      MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax(), i;
        for (i=0; i < all.length; i += 1) {
          all[i].SourceElement().parentNode.className += ' has-jax';
        }
      });
    </script>
    <script type="text/javascript" src="//cdn.bootcss.com/mathjax/2.7.1/latest.js?config=TeX-AMS-MML_HTMLorMML"></script>
  


  

  

<script src="/live2dw/lib/L2Dwidget.min.js?0c58a1486de42ac6cc1c59c7d98ae887"></script><script>L2Dwidget.init({"pluginRootPath":"live2dw/","pluginJsPath":"lib/","pluginModelPath":"assets/","model":{"jsonPath":"/live2dw/assets/hijiki.model.json"},"display":{"position":"left","width":80,"height":300,"hOffset":20,"vOffset":-200},"mobile":{"show":true}});</script></body>
</html>
