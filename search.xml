<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[LeetCode刷题记录]]></title>
    <url>%2F2019%2F12%2F14%2FLeetCode%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95%2F</url>
    <content type="text"><![CDATA[96.不同的二叉搜索树 状态：不会，重做 题目 给定一个整数 n，求以 1 … n 为节点组成的二叉搜索树有多少种？ 示例: 输入: 3 输出: 5 解释: 给定 n = 3, 一共有 5 种不同结构的二叉搜索树: 123451 1 2 3 3 \ \ / \ / / 3 2 1 3 2 1 / \ / \2 3 1 2 解析 动态规划 以1,2,...,n为节点组成的BST有G[n]种， G[n]=F(1,n)+F(2,n)+...+F(i,n)+...+F(n,n) 其中，F(i,n)表示以i为根节点组成的BST个数， 然而，F(i,n)=G[i-1] * G[n-i] 注意，G[0]=1 以n=3为例，G[3]=F(1,3)+F(2,3)+F(3,3), 123F(1,3)=G[0] * G[2]F(2,3)=G[1] * G[1]F(3,3)=G[2] * G[0] 代码 123456789101112131415161718class Solution(object): def numTrees(self, n): """ :type n: int :rtype: int """ G = [0] * (n+1) G[0] = 1 for i in range(1, n+1): for j in range(i): G[i] += G[j] * G[i-1-j] return G[n]if __name__ == '__main__': a = Solution() print(a.numTrees(n=3)) 413. 等差数列划分 状态：亟待优化 题目 如果一个数列至少有三个元素，并且任意两个相邻元素之差相同，则称该数列为等差数列。 例如，以下数列为等差数列: 1, 3, 5, 7, 9 7, 7, 7, 7 3, -1, -5, -9 以下数列不是等差数列。 1, 1, 2, 5, 7 数组 A 包含 N 个数，且索引从0开始。数组 A 的一个子数组划分为数组 (P, Q)，P 与 Q 是整数且满足 0&lt;=P&lt;Q&lt;N 。 如果满足以下条件，则称子数组(P, Q)为等差数组： 元素 A[P], A[p + 1], …, A[Q - 1], A[Q] 是等差的。并且 P + 1 &lt; Q 。 函数要返回数组 A 中所有为等差数组的子数组个数。 示例: A = [1, 2, 3, 4] 返回: 3, A 中有三个子等差数组: [1, 2, 3], [2, 3, 4] 以及自身 [1, 2, 3, 4]。 version1 过程： 成绩： 解析 审题一定要清楚： 给定的数组A不一定是等差数列，不要让示例先入为止； 等差子数列，题目中明确要求：元素 A[P], A[p + 1], …, A[Q - 1], A[Q] 是等差的。并且 P + 1 &lt; Q 。即表明，子数列是在原数列中不间隔选出的，且至少3个元素。 基于以上分析，先枚举出子数列的所有情形，再判断该子数列是否为等差，但是超时的缘故，在枚举子数列的过程中，若判定该子数列不等差，那么可以包含该子数列的数列肯定也不等差。优化这一判断条件后才勉强通过时间限制。 代码 12345678910111213141516171819202122232425class Solution(object): def numberOfArithmeticSlices(self, A): """ :type A: List[int] :rtype: int """ if len(A) &lt; 3: return 0 else: res = 0 for i in range(len(A)): for j in range(i + 3, len(A) + 1): li = A[i:j] k = li[1] - li[0]#等差 flag = 0 for m in range(1, len(li)): if li[m] == li[m-1] + k: flag += 1 else: break if flag == len(li) - 1: res += 1 else: break return res 标准答案 以A=[1,2,3,4,5,6]为例： 10=1+2+3+4 在枚举子数列时，判断A[i-2],A[i-1],A[i]是否为等差数列，若是则根据前一个循环是否也是等差决定是否叠加。 12345678910111213141516171819class Solution(object): def numberOfArithmeticSlices(self, A): """ :param A: List[int] :return: int """ N = len(A) if N &lt;= 2: return 0 count = 0 streak = 0 for i in range(2, N): if A[i] - A[i-1] == A[i-1] - A[i-2]: streak += 1#以A[i]结尾的等差子数列的个数 count += streak else: streak = 0 return count 120. 三角形最小路径和 状态：排名85%，未考虑空间复杂度 题目 给定一个三角形，找出自顶向下的最小路径和。每一步只能移动到下一行中相邻的结点上。 例如，给定三角形： 123456[ [2], [3,4], [6,5,7], [4,1,8,3]] 自顶向下的最小路径和为 11（即，2 + 3 + 5 + 1 = 11）。 说明： 如果你可以只使用 O(n) 的额外空间（n 为三角形的总行数）来解决这个问题，那么你的算法会很加分。 version1 过程： 成绩： 解析 参考之前矩阵的题目，从最左上角开始，每次只能往下或者往右走，最佳的解题思路就是算出每走一步后的结果，依次迭代。 那么，这里的思路也是一样的，这里的限制条件是只能走相邻的点。 代码 123456789101112131415161718192021class Solution(object): def minimumTotal(self, triangle): """ :type triangle: List[List[int]] :rtype: int """ if len(triangle) == 1: return triangle[0][0] elif len(triangle) == 2: return triangle[0][0] + min(triangle[1]) else: triangle[1][0], triangle[1][1] = triangle[1][0] + triangle[0][0], triangle[1][1] + triangle[0][0] for row in range(2, len(triangle)): for idx in range(row + 1): if idx == 0: triangle[row][idx] += triangle[row - 1][idx] elif idx == row: triangle[row][idx] += triangle[row - 1][idx - 1] else: triangle[row][idx] += min(triangle[row - 1][idx], triangle[row - 1][idx - 1]) return min(triangle[-1]) 标准答案 关键在于空间复杂度： 我的解法是至上而下的，需要修改数组中的每一个元素。现在有一种解法是至下而上，只写存最后一行的内层数组空间，这种解法更节约空间。 代码 12345678910111213class Solution(object): def minimumTotal(self, triangle): """ :type triangle: List[List[int]] :rtype: int """ if not triangle: return res = triangle[-1] for i in range(len(triangle) - 2, -1, -1): for j in range(len(triangle[i])): res[j] = min(res[j], res[j + 1]) + triangle[i][j] return res[0] 62. 不同路径 状态：排名95.86% 题目 一个机器人位于一个 m x n 网格的左上角 （起始点在下图中标记为“Start” ）。 机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为“Finish”）。 问总共有多少条不同的路径？ 例如，上图是一个7 x 3 的网格。有多少可能的路径？ 说明：m 和 n 的值均不超过 100。 示例 1: 1234567输入: m = 3, n = 2输出: 3解释:从左上角开始，总共有 3 条路径可以到达右下角。1. 向右 -&gt; 向右 -&gt; 向下2. 向右 -&gt; 向下 -&gt; 向右3. 向下 -&gt; 向右 -&gt; 向右 示例 2: 12输入: m = 7, n = 3输出: 28 version1 过程： 成绩： 解析 第一次提交失败：未考虑周全矩阵的形式。 思路和之前矩阵求最小路径和以及三角形最小路径和是一样的，计算每个节点的路径可能数，最终答案即为最后一个点的值。 代码 12345678910111213141516171819202122class Solution: def uniquePaths(self, m, n): """ :type m: int :type n: int :rtype: int """ if m == 1 or n == 1: return 1 else: res = [[0 for i in range(n)] for i in range(m)] for i in range(m): for j in range(n): if i == 0 and j == 0: continue elif i == 0: res[i][j] = 1 elif j == 0: res[i][j] = 1 else: res[i][j] = res[i - 1][j] + res[i][j - 1] return res[-1][-1] 712. 两个字符串的最小ASCII删除和 状态：不会做 题目 给定两个字符串s1, s2，找到使两个字符串相等所需删除字符的ASCII值的最小和。 示例 1: 输入: s1 = “sea”, s2 = &quot;eat&quot; 输出: 231 解释: 在 “sea” 中删除 “s” 并将 “s” 的值(115)加入总和。 在 “eat” 中删除 “t” 并将 116 加入总和。 结束时，两个字符串相等，115 + 116 = 231 就是符合条件的最小和。 示例 2: 输入: s1 = “delete”, s2 = &quot;leet&quot; 输出: 403 解释: 在 “delete” 中删除 “dee” 字符串变成 “let”， 将 100[d]+101[e]+101[e] 加入总和。在 “leet” 中删除 “e” 将 101[e] 加入总和。 结束时，两个字符串都等于 “let”，结果即为 100+101+101+101 = 403 。 如果改为将两个字符串转换为 “lee” 或 “eet”，我们会得到 433 或 417 的结果，比答案更大。 注意: 0 &lt; s1.length, s2.length &lt;= 1000。 所有字符串中的字符ASCII值在[97, 122]之间。 最佳答案 这题是经典题目“最长公共子串LCS”的变形题目。 在弄懂LCS之后，这题就很好理解了。 LCS: 1234567891011121314151617181920初始化dp矩阵：----------d---e---l---e---t---e--|___|_0_|_0_|_0_|_0_|_0_|_0_|_0_||_l_|_0_|_0_|_0_|_0_|_0_|_0_|_0_||_e_|_0_|_0_|_0_|_0_|_0_|_0_|_0_||_e_|_0_|_0_|_0_|_0_|_0_|_0_|_0_||_t_|_0_|_0_|_0_|_0_|_0_|_0_|_0_|从s1=&quot;leet&quot;开始遍历对比s2=&quot;delete&quot;，1.如果相同，那么dp[i][j]=dp[i-1][j-1]+1;意味着，如果s1与s2最后一个元素相同，那么LCS（s1,s2）=LCS(s1[:-1],s2[:-1])+s1[-1]2.如果不同，那么dp[i][j]=max(dp[i-1][j],dp[i][j-1])意味着，如果s1与s2最后一个元素不同，那么LCS(s1,s2)=max(LCS(s1[:-1],s2),LCS(s1,s2[:-1]))----------d---e---l---e---t---e--|___|_0_|_0_|_0_|_0_|_0_|_0_|_0_||_l_|_0_|_0_|_0_|_1_|_1_|_1_|_1_||_e_|_0_|_0_|_1_|_1_|_2_|_2_|_2_||_e_|_0_|_0_|_1_|_1_|_2_|_2_|_3_||_t_|_0_|_0_|_1_|_1_|_2_|_3_|_3_| 标准代码 1234567891011121314151617class Solution: def minimumDeleteSum(self, s1, s2): """ :type s1: str :type s2: str :rtype: int """ l1, l2 = len(s1), len(s2) dp = [[0] * (l2 + 1) for _ in range(l1 + 1)] for i in range(l1): for j in range(l2): if s1[i] == s2[j]: dp[i + 1][j + 1] = dp[i][j] + ord(s1[i]) else: dp[i + 1][j + 1] = max(dp[i][j + 1], dp[i + 1][j]) result = sum(map(ord, s1 + s2)) - dp[l1][l2] * 2 return result 647. 回文子串 状态：排名23.26% 题目 给定一个字符串，你的任务是计算这个字符串中有多少个回文子串。 具有不同开始位置或结束位置的子串，即使是由相同的字符组成，也会被计为是不同的子串。 示例 1: 123输入: &quot;abc&quot;输出: 3解释: 三个回文子串: &quot;a&quot;, &quot;b&quot;, &quot;c&quot;. 示例 2: 123输入: &quot;aaa&quot;输出: 6说明: 6个回文子串: &quot;a&quot;, &quot;a&quot;, &quot;a&quot;, &quot;aa&quot;, &quot;aa&quot;, &quot;aaa&quot;. 注意: 输入的字符串长度不会超过1000。 version1 过程： 成绩： 解析 首先一定搞明白回文字符串的意思，回文即正着读反着读都一样。 所以第一次提交失败。 第二次暴力求解，成绩亟待提高。 代码 12345678910111213class Solution: def countSubstrings(self, s): """ :type s: str :rtype: int """ flag = 0 for i in range(len(s)): for j in range(i, len(s)): if s[i:j + 1] == s[i:j + 1][::-1]: flag += 1 return flag 303. 区域和检索 - 数组不可变 状态：排名41.91%，待提高 题目 给定一个整数数组 nums，求出数组从索引 i 到 j (i ≤ j) 范围内元素的总和，包含 i, j 两点。 示例： 1234给定 nums = [-2, 0, 3, -5, 2, -1]，求和函数为 sumRange()sumRange(0, 2) -&gt; 1sumRange(2, 5) -&gt; -1sumRange(0, 5) -&gt; -3 说明: 你可以假设数组不可变。 会多次调用 sumRange 方法。 version1 过程： 成绩： 解析 这题思路很简单。 代码 1234567891011121314151617class NumArray: def __init__(self, nums): """ :type nums: List[int] """ self.nums = nums def sumRange(self, i, j): """ :type i: int :type j: int :rtype: int """ return sum(self.nums[i:j+1])# Your NumArray object will be instantiated and called as such:# obj = NumArray(nums)# param_1 = obj.sumRange(i,j) 标准答案 这题主要是要用动态规划的思想，题目要求的sumRange(i,j)，是可以在遍历数组元素的时候进行叠加求和，一次性求出新的叠加数组。 代码 123456789101112131415161718class NumArray: def __init__(self, nums): """ :type nums: List[int] """ self.nums = nums def sumRange(self, i, j): """ :type i: int :type j: int :rtype: int """ return sum(self.nums[i:j+1])if __name__ == "__main__": a = NumArray(nums=[-2, 0, 3, -5, 2, -1]) print(a.sumRange(0, 5)) 343. 整数拆分 状态： 排名99% 题目 给定一个正整数 n，将其拆分为至少两个正整数的和，并使这些整数的乘积最大化。 返回你可以获得的最大乘积。 示例 1: 输入: 2 输出: 1 解释: 2 = 1 + 1, 1 × 1 = 1。 示例 2: 输入: 10 输出: 36 解释: 10 = 3 + 3 + 4, 3 × 3 × 4 = 36。 说明: 你可以假设 n 不小于 2 且不大于 58。 version1 过程： version2 过程： 成绩： 解析 第二次再写，硬生生地记住了结论，解题关键要尽可能多拆分为3，若剩下1，则要将3和1转换为2和2。 标准答案 这题主要还是没搞懂解题思路，解题的关键是神奇的质数2和质数3。 代码 12345678910111213141516171819from functools import reduceclass Solution: def integerBreak(self, n): """ :type n: int :rtype: int """ if n == 2: return 1 if n == 3: return 2 list_3 = [3] * int((n / 3)) # generate a list of 3 mod_3 = n % 3 if mod_3 == 1: # if a 1 is left, then add it to the first element to get a 4 list_3[0] += 1 if mod_3 == 2: # if a 2 is left, then put it into the list list_3.append(2) return reduce(lambda a, b: a * b, list_3) 638. 大礼包 状态：未通过，有思路但是有难点无法克服 题目 在LeetCode商店中， 有许多在售的物品。 然而，也有一些大礼包，每个大礼包以优惠的价格捆绑销售一组物品。 现给定每个物品的价格，每个大礼包包含物品的清单，以及待购物品清单。请输出确切完成待购清单的最低花费。 每个大礼包的由一个数组中的一组数据描述，最后一个数字代表大礼包的价格，其他数字分别表示内含的其他种类物品的数量。 任意大礼包可无限次购买。 示例 1: 1234567输入: [2,5], [[3,0,5],[1,2,10]], [3,2]输出: 14解释: 有A和B两种物品，价格分别为¥2和¥5。大礼包1，你可以以¥5的价格购买3A和0B。大礼包2， 你可以以¥10的价格购买1A和2B。你需要购买3个A和2个B， 所以你付了¥10购买了1A和2B（大礼包2），以及¥4购买2A。 示例 2: 1234567输入: [2,3,4], [[1,1,0,4],[2,2,1,9]], [1,2,1]输出: 11解释: A，B，C的价格分别为¥2，¥3，¥4.你可以用¥4购买1A和2B，也可以用¥9购买2A，2B和1C。你需要买1A，2B和1C，所以你付了¥4买了1A和1B（大礼包1），以及¥3购买1B， ¥4购买1C。你不可以购买超出待购清单的物品，尽管购买大礼包2更加便宜。 说明: 最多6种物品， 100种大礼包。 每种物品，你最多只需要购买6个。 你不可以购买超出待购清单的物品，即使更便宜。 version1 过程： 本地编译器上未调通，有思路，但是不知道如何解决不同大礼包优惠程度的对比。 标准答案 深度优先搜索，主要就是用大礼包或者原价购买的价格比较，不仅要比较不同大礼包之间的差别，还要比较与原价之间的价格。大礼包的比较肯定要用for循环，然后保存下来方便与后续比较。 代码 1234567891011121314151617181920class Solution: def shoppingOffers(self, price, special, needs): """ :type price: List[int] :type special: List[List[int]] :type needs: List[int] :rtype: int """ d = &#123;&#125; def dfs(cur): val = sum(cur[i] * price[i] for i in range(len(needs))) # cost without special for spec in special: tmp = [cur[j] - spec[j] for j in range(len(needs))] if min(tmp) &gt;= 0: # skip deals that exceed needs val = min(val, d.get(tuple(tmp), dfs(tmp)) + spec[-1]) # .get check the dictionary first for result, otherwise perform dfs. d[tuple(cur)] = val return val return dfs(needs) 312. 戳气球 状态：未通过，思路错误 题目 有 n 个气球，编号为0 到 n-1，每个气球上都标有一个数字，这些数字存在数组 nums 中。 现在要求你戳破所有的气球。 1每当你戳破一个气球 i 时，你可以获得 nums[left] * nums[i] * nums[right] 个硬币。 这里的 left 和 right 代表和 i 相邻的两个气球的序号。 注意当你戳破了气球 i 后，气球 left 和气球 right 就变成了相邻的气球。 求所能获得硬币的最大数量。 说明: 12你可以假设 nums[-1] = nums[n] = 1，但注意它们不是真实存在的所以并不能被戳破。 0 ≤ n ≤ 500, 0 ≤ nums[i] ≤ 100 示例: 1234输入: [3,1,5,8]输出: 167 解释: nums = [3,1,5,8] --&gt; [3,5,8] --&gt; [3,8] --&gt; [8] --&gt; [] coins = 3*1*5 + 3*5*8 + 1*3*8 + 1*8*1 = 167 version1 过程： 整个思考过程就是错误的。忧伤··· 标准答案 代码 1234567891011121314151617181920class Solution(object): def maxCoins(self, nums): """ :type nums: List[int] :rtype: int """ nums = [1] + nums + [1] n = len(nums) dp = [[0] * n for _ in xrange(n)] def calculate(i, j): if dp[i][j] or j == i + 1: # in memory or gap &lt; 2 return dp[i][j] coins = 0 for k in xrange(i+1, j): # find the last balloon coins = max(coins, nums[i] * nums[k] * nums[j] + calculate(i, k) + calculate(k, j)) dp[i][j] = coins return coins return calculate(0, n-1) 740.删除与获得点数 95.不同的二叉搜索树II 121.买卖股票的最佳时机 状态：未通过，超时 题目 给定一个数组，它的第 i 个元素是一支给定股票第 i 天的价格。 如果你最多只允许完成一笔交易（即买入和卖出一支股票），设计一个算法来计算你所能获取的最大利润。 注意你不能在买入股票前卖出股票。 示例 1: 1234输入: [7,1,5,3,6,4]输出: 5解释: 在第 2 天（股票价格 = 1）的时候买入，在第 5 天（股票价格 = 6）的时候卖出，最大利润 = 6-1 = 5 。 注意利润不能是 7-1 = 6, 因为卖出价格需要大于买入价格。 示例 2: 123输入: [7,6,4,3,1]输出: 0解释: 在这种情况下, 没有交易完成, 所以最大利润为 0。 version1 过程： 思路有，就是实现起来不够动态规划。所以会导致很慢，超时不通过。 标准答案 标准答案是只需要一次遍历，求出答案，复杂度是O(N)。而我第一次版本是不止一次遍历的，不仅是明显写出的第一次循环还是隐性的求min,max（其实也是遍历）。 代码 123456789101112class Solution: def maxProfit(self, prices): """ :type prices: List[int] :rtype: int """ max_profit, min_price = 0, float('inf') for price in prices: min_price = min(min_price, price) profit = price - min_price max_profit = max(max_profit, profit) return max_profit 931.下降路径最小和 状态：排名98% 题目 给定一个方形整数数组 A，我们想要得到通过 A 的下降路径的最小和。 下降路径可以从第一行中的任何元素开始，并从每一行中选择一个元素。在下一行选择的元素和当前行所选元素最多相隔一列。 示例： 123456789输入：[[1,2,3],[4,5,6],[7,8,9]]输出：12解释：可能的下降路径有：[1,4,7], [1,4,8], [1,5,7], [1,5,8], [1,5,9][2,4,7], [2,4,8], [2,5,7], [2,5,8], [2,5,9], [2,6,8], [2,6,9][3,5,7], [3,5,8], [3,5,9], [3,6,8], [3,6,9]和最小的下降路径是 [1,4,7]，所以答案是 12。 提示： 121 &lt;= A.length == A[0].length &lt;= 100-100 &lt;= A[i][j] &lt;= 100 version1 过程： 成绩： 这种类型的题目已经掌握了，笔试是不会怕了。 相似题目有120，62。 代码 12345678910111213141516171819202122class Solution: def minFallingPathSum(self, A): """ :type A: List[List[int]] :rtype: int """ if len(A) == 1: return sum(A[0]) if len(A[0]) == 1: res = 0 for row in range(len(A)): res += A[row][0] return res for i in range(1, len(A)): for j in range(len(A[0])): if j == 0: A[i][j] += min(A[i-1][j], A[i-1][j+1]) elif j == len(A[0])-1: A[i][j] += min(A[i-1][j], A[i-1][j-1]) else: A[i][j] += min(A[i-1][j], A[i-1][j-1], A[i-1][j+1]) return min(A[-1]) 70.爬楼梯 状态：未通过 题目 假设你正在爬楼梯。需要 n 阶你才能到达楼顶。 每次你可以爬 1 或 2 个台阶。你有多少种不同的方法可以爬到楼顶呢？ 注意：给定 n 是一个正整数。 示例 1： 12345输入： 2输出： 2解释： 有两种方法可以爬到楼顶。1. 1 阶 + 1 阶2. 2 阶 示例 2： 123456输入： 3输出： 3解释： 有三种方法可以爬到楼顶。1. 1 阶 + 1 阶 + 1 阶2. 1 阶 + 2 阶3. 2 阶 + 1 阶 标准答案 爬楼梯是一道经典的动态规划类型题目。 这道题目是逆推。比如，要想爬10级楼梯，可以1次爬1级，也可以1次爬2级。如果现在考虑，只剩最后一步，那么有可能是最后一步爬1级，也有可能是最后一步爬2级。如果最后一步爬1级，那么问题转换为爬9级台阶的方式，同理可知，如果最后一步爬2级，就等价于秋节爬8级台阶的方法。 数学表达式： F(10)=F(9)+F(8) F(9)=F(8)+F(7) … 代码 123456789101112class Solution: def climbStairs(self, n): """ :type n: int :rtype: int """ if n == 1: return 1 elif n == 2: return 2 else: return self.climbStairs(n-1) + self.climbStairs(n-2) 152. 乘积最大子序列 状态：未通过 题目 给定一个整数数组 nums ，找出一个序列中乘积最大的连续子序列（该序列至少包含一个数）。 示例 1: 123输入: [2,3,-2,4]输出: 6解释: 子数组 [2,3] 有最大乘积 6。 示例 2: 123输入: [-2,0,-1]输出: 0解释: 结果不能为 2, 因为 [-2,-1] 不是子数组。 标准答案 动态规划的题目做多了，直觉告诉我这题应该一次遍历即可得到答案。 连续子序列的最大值可能因为符号的变化，最大值瞬间变为最小值，最小值瞬间变为最大值，故这题的关键是记录当前遍历状态下的最大值与最小值。 代码 1234567891011class Solution: def maxProduct(self, nums): """ :type nums: List[int] :rtype: int """ maximum = big = small = nums[0] for n in nums[1:]: big, small = max(n, n * big, n * small), min(n, n * big, n * small) maximum = max(maximum, big) return maximum 122. 买卖股票的最佳时机 II 状态：未通过 题目 给定一个数组，它的第 i 个元素是一支给定股票第 i 天的价格。 设计一个算法来计算你所能获取的最大利润。你可以尽可能地完成更多的交易（多次买卖一支股票）。 注意：你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。 示例 1: 1234输入: [7,1,5,3,6,4]输出: 7解释: 在第 2 天（股票价格 = 1）的时候买入，在第 3 天（股票价格 = 5）的时候卖出, 这笔交易所能获得利润 = 5-1 = 4 。 随后，在第 4 天（股票价格 = 3）的时候买入，在第 5 天（股票价格 = 6）的时候卖出, 这笔交易所能获得利润 = 6-3 = 3 。 示例 2: 12345输入: [1,2,3,4,5]输出: 4解释: 在第 1 天（股票价格 = 1）的时候买入，在第 5 天 （股票价格 = 5）的时候卖出, 这笔交易所能获得利润 = 5-1 = 4 。 注意你不能在第 1 天和第 2 天接连购买股票，之后再将它们卖出。 因为这样属于同时参与了多笔交易，你必须在再次购买前出售掉之前的股票。 示例 3: 123输入: [7,6,4,3,1]输出: 0解释: 在这种情况下, 没有交易完成, 所以最大利润为 0。 标准答案 这题的题目背景与121.买卖股票的最佳时机非常相似。但是不要搞混淆，题目给出的条件一点点的差异也可能导致解法大大不同。这题没有不允许同一天操作买入与卖出的交易行为，而121题则明确提出不可以。 代码 1234567891011class Solution: def maxProfit(self, prices): """ :type prices: List[int] :rtype: int """ res = [] for i in range(len(prices)-1): if prices[i+1] &gt; prices[i]: res.append(prices[i+1]-prices[i]) return sum(res) 200. 岛屿的个数 状态：未通过 题目 给定一个由’1’（陆地）和 ‘0’（水）组成的的二维网格，计算岛屿的数量。 一个岛被水包围，并且它是通过水平方向或垂直方向上相邻的陆地连接而成的。 你可以假设网格的四个边均被水包围。 示例 1: 123456输入:11110110101100000000输出: 1 示例 2: 123456输入:11000110000010000011输出: 3 标准答案 方法一： 深度优先搜索，在每次遍历中尽可能深入地迭代遍历。 在目标函数中调用自建的dfs函数，dfs函数中递归调用dfs函数本身。 方法二： 并查集，利用树形结构，记录每个连通块的情况，而连通块的个数则代表岛屿的个数。 DFS代码 12345678910111213141516171819202122232425class Solution: def numIslands(self, grid): """ :type grid: List[List[str]] :rtype: int """ if not grid: return 0 count = 0 for i in range(len(grid)): for j in range(len(grid[0])): if grid[i][j] == '1': self.dfs(grid, i, j) count += 1 return count def dfs(self, grid, i, j): if i &lt; 0 or j &lt; 0 or i &gt;= len(grid) or j &gt;= len(grid[0]) or grid[i][j] != '1': return grid[i][j] = '#'#确保已经遍历过的陆地不会再走一遍，不然会一直死循环 self.dfs(grid, i + 1, j) self.dfs(grid, i - 1, j) self.dfs(grid, i, j + 1) self.dfs(grid, i, j - 1) 并查集 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657class UnionFind(object): def __init__(self, grid): m, n = len(grid), len(grid[0]) self.count = 0#记录岛屿的数量，节省一次遍历 self.parent = [-1] * (m*n) for i in range(m): for j in range(n): if grid[i][j] == '1': self.parent[i*n + j] = i*n + j self.count += 1 def find(self, i): if self.parent[i] != i: self.parent[i] = self.find(self.parent[i]) return self.parent[i] def union(self, x, y): rootx = self.find(x) rooty = self.find(y) if rootx != rooty: self.parent[rooty] = rootx self.count -= 1class Solution(object): def is_valid(self, grid, r, c): m, n = len(grid), len(grid[0]) if r &lt; 0 or c &lt; 0 or r &gt;= m or c &gt;= n: return False return True def numIslands(self, grid): """ :type grid: List[List[str]] :rtype: int """ if not grid or not grid[0]: return 0 uf = UnionFind(grid) directions = [(0,1), (0,-1), (-1,0), (1,0)] m, n = len(grid), len(grid[0]) for i in range(m): for j in range(n): if grid[i][j] == '1': for d in directions: nr, nc = i + d[0], j + d[1] if self.is_valid(grid, nr, nc) and grid[nr][nc] == '1': uf.union(i*n+j, nr*n+nc) return uf.countif __name__ == "__main__": a = Solution() print(a.numIslands(grid=[['1','1','1','1','0'], ['1','1','0','1','0'], ['1','1','0','0','0'], ['0','0','0','0','0']])) 695. 岛屿的最大面积 状态：排名53.56% 题目 给定一个包含了一些 0 和 1的非空二维数组 grid , 一个 岛屿 是由四个方向 (水平或垂直) 的 1 (代表土地) 构成的组合。你可以假设二维矩阵的四个边缘都被水包围着。 找到给定的二维数组中最大的岛屿面积。(如果没有岛屿，则返回面积为0。) 示例 1: 123456789[[0,0,1,0,0,0,0,1,0,0,0,0,0], [0,0,0,0,0,0,0,1,1,1,0,0,0], [0,1,1,0,1,0,0,0,0,0,0,0,0], [0,1,0,0,1,1,0,0,1,0,1,0,0], [0,1,0,0,1,1,0,0,1,1,1,0,0], [0,0,0,0,0,0,0,0,0,0,1,0,0], [0,0,0,0,0,0,0,1,1,1,0,0,0], [0,0,0,0,0,0,0,1,1,0,0,0,0]]对于上面这个给定矩阵应返回 6。注意答案不应该是11，因为岛屿只能包含水平或垂直的四个方向的‘1’。 示例 2: 123[[0,0,0,0,0,0,0,0]]对于上面这个给定的矩阵, 返回 0。注意: 给定的矩阵grid 的长度和宽度都不超过 50。 version1 过程： 成绩： 与200. 岛屿的个数类似，采用深度优先搜索的思想，200那题是计算岛屿的个数，这题计算岛屿的大小，大同小异。 代码 123456789101112131415161718192021222324252627282930313233class Solution: def maxAreaOfIsland(self, grid): """ :type grid: List[List[int]] :rtype: int """ res = [0] for i in range(len(grid)): for j in range(len(grid[0])): area = 0 tmp = self.dfs(grid, i, j, area) if tmp: res.append(tmp) return max(res) def dfs(self, grid, i, j, area): if i &lt; 0 or j &lt; 0 or i &gt;= len(grid) or j &gt;= len(grid[0]) or grid[i][j] != 1: return grid[i][j] = '#' area = 1 down = self.dfs(grid, i + 1, j, area) if down: area += down up = self.dfs(grid, i-1, j, area) if up: area += up right = self.dfs(grid, i, j+1, area) if right: area += right left = self.dfs(grid, i, j-1, area) if left: area += left return area 300. 最长上升子序列 状态：不会 题目 给定一个无序的整数数组，找到其中最长上升子序列的长度。 示例: 123输入: [10,9,2,5,3,7,101,9,18]输出: 4 解释: 最长的上升子序列是 [2,3,7,101]，它的长度是 4。 说明: 可能会有多种最长上升子序列的组合，你只需要输出对应的长度即可。 你算法的时间复杂度应该为 O(n2) 。 进阶: 你能将算法的时间复杂度降低到 O(n log n) 吗? 标准答案 动态规划，设置两个指针i,j以及一个长度与给定数组相同的数组T，核心公式：T[i]=max(T[i],T[j]+1)。 具体讲解见Youtube：https://www.youtube.com/watch?v=CE2b_-XfVDk 代码 123456789101112131415161718192021222324class Solution: def lengthOfLIS(self, nums): """ :type nums: List[int] :rtype: int """ res = [] for i in range(len(nums)): tmp = self.find_bigger(cur=nums[i], rest=nums[i+1:]) if tmp!= None: res.append(tmp+1) return max(res) def find_bigger(self, cur, rest): for i in range(len(rest)): if rest[i] &gt; cur: tmpp = self.find_bigger(rest[i], rest[i+1:]) if tmpp != None: return tmpp+1 elif i == len(rest)-1: return 0if __name__ == "__main__": a = Solution() print(a.lengthOfLIS(nums=[10,9,2,5,3,7,101,9,18])) 416. 分割等和子集 状态：不会 题目 给定一个只包含正整数的非空数组。是否可以将这个数组分割成两个子集，使得两个子集的元素和相等。 注意: 每个数组中的元素不会超过 100 数组的大小不会超过 200 示例 1: 123输入: [1, 5, 11, 5]输出: true解释: 数组可以分割成 [1, 5, 5] 和 [11]. 示例 2: 123输入: [1, 2, 3, 5]输出: false解释: 数组不能分割成两个元素和相等的子集. 标准答案 0/1背包问题，详细讲解见： https://www.youtube.com/watch?v=8LusJS5-AGo 这题背包的重量为sum/2,比背包问题简单，没有价值信息，更不用求价值最大值。 代码 12345678910111213141516171819202122232425class Solution: def canPartition(self, nums): """ :type nums: List[int] :rtype: bool """ total = sum(nums) if total % 2 == 1: return False else: total = int(total / 2) dp = [[0 for i in range(total + 1)] for j in range(len(nums))] for i in range(nums[0], total + 1): dp[0][i] = nums[0] for i in range(1, len(nums)): for j in range(nums[i], total + 1): dp[i][j] = max(dp[i - 1][j], dp[i - 1][j - nums[i]] + nums[i]) if dp[len(nums) - 1][total] != total: return False else: return Trueif __name__ == "__main__": a = Solution() print(a.canPartition(nums=[1,2,3,4,5,6,7])) 322. 零钱兑换 状态：不会 题目 给定不同面额的硬币 coins 和一个总金额 amount。 编写一个函数来计算可以凑成总金额所需的最少的硬币个数。 如果没有任何一种硬币组合能组成总金额，返回 -1。 示例 1: 123输入: coins = [1, 2, 5], amount = 11输出: 3 解释: 11 = 5 + 5 + 1 示例 2: 12输入: coins = [2], amount = 3输出: -1 说明: 你可以认为每种硬币的数量是无限的。 标准答案 经典0/1背包问题的变种类型——完全背包，与01背包不同在于每种物品可以不止使用一次，物品个数是无限的。 解题关键在于当未计算或者使用该硬币，硬币总数量下降的就更新dp[i]。 代码 12345678910111213141516171819class Solution: def coinChange(self, coins, amount): """ :type coins: List[int] :type amount: int :rtype: int """ dp = [-1] * (amount + 1) dp[0] = 0 for i in range(1, amount + 1): for j in range(0, len(coins)): if i &gt;= coins[j] and dp[i - coins[j]] != -1: if dp[i] == -1 or dp[i] &gt; dp[i - coins[j]] + 1: dp[i] = dp[i - coins[j]] + 1 return dp[amount] if __name__ == "__main__": a = Solution() print(a.coinChange(coins = [1, 2, 5], amount = 11)) 377. 组合总和 Ⅳ 状态：不会 题目 给定一个由正整数组成且不存在重复数字的数组，找出和为给定目标正整数的组合的个数。 示例: 1234567891011nums = [1, 2, 3]target = 4所有可能的组合为：(1, 1, 1, 1)(1, 1, 2)(1, 2, 1)(1, 3)(2, 1, 1)(2, 2)(3, 1) 请注意，顺序不同的序列被视作不同的组合。 因此输出为 7。 标准答案 经典0/1背包问题的变种类型——完全背包，与Leetcode322相似，都是物品可以无限次使用，但是dp数组里记录的是不同组合个数。 代码 123456789101112131415161718class Solution: def combinationSum4(self, nums, target): """ :type nums: List[int] :type target: int :rtype: int """ dp = [0] * (target + 1) dp[0] = 1 # if num == target for i in range(1, target + 1): for num in nums: if i &gt;= num: dp[i] += dp[i - num] return dp[target]if __name__ == "__main__": a = Solution() print(a.combinationSum4(nums = [1, 2, 3], target = 4)) 474. 一和零 状态：不会 题目 在计算机界中，我们总是追求用有限的资源获取最大的收益。 现在，假设你分别支配着 m 个 0 和 n 个 1。另外，还有一个仅包含 0 和 1 字符串的数组。 你的任务是使用给定的 m 个 0 和 n 个 1 ，找到能拼出存在于数组中的字符串的最大数量。每个 0 和 1 至多被使用一次。 注意: 给定 0 和 1 的数量都不会超过 100。 给定字符串数组的长度不会超过 600。 示例 1: 输入: Array = {“10”, “0001”, “111001”, “1”, “0”}, m = 5, n = 3 输出: 4 解释: 总共 4 个字符串可以通过 5 个 0 和 3 个 1 拼出，即 “10”,“0001”,“1”,“0” 。 示例 2: 输入: Array = {“10”, “0”, “1”}, m = 1, n = 1 输出: 2 解释: 你可以拼出 “10”，但之后就没有剩余数字了。更好的选择是拼出 “0” 和 “1” 。 标准答案 经典0/1背包问题的变种类型——多维背包问题，不仅考虑物品的重量，而是要衡量物品的重量和体积，并且这里求的不是背包的最大价值，而是可能性中包含的最大字符串个数。 代码 12345678910111213141516171819202122class Solution: def findMaxForm(self, strs, m, n): """ :type strs: List[str] :type m: int :type n: int :rtype: int """ dp = [[0] * (n + 1) for _ in range(m + 1)] for item in strs: z = item.count('0') o = item.count('1') for x in range(m, -1, -1): for y in range(n, -1, -1): if x &gt;= z and y &gt;= o: dp[x][y] = max(1 + dp[x - z][y - o], dp[x][y]) return dp[m][n]if __name__ == "__main__": a = Solution() print(a.findMaxForm(strs=["10", "0001", "111001", "1", "0"], m = 5, n = 3)) 139. 单词拆分 状态：不会 题目 给定一个非空字符串 s 和一个包含非空单词列表的字典 wordDict，判定 s 是否可以被空格拆分为一个或多个在字典中出现的单词。 说明： 拆分时可以重复使用字典中的单词。 你可以假设字典中没有重复的单词。 示例 1： 123输入: s = &quot;leetcode&quot;, wordDict = [&quot;leet&quot;, &quot;code&quot;]输出: true解释: 返回 true 因为 &quot;leetcode&quot; 可以被拆分成 &quot;leet code&quot;。 示例 2： 1234输入: s = &quot;applepenapple&quot;, wordDict = [&quot;apple&quot;, &quot;pen&quot;]输出: true解释: 返回 true 因为 &quot;applepenapple&quot; 可以被拆分成 &quot;apple pen apple&quot;。 注意你可以重复使用字典中的单词。 示例 3： 12输入: s = &quot;catsandog&quot;, wordDict = [&quot;cats&quot;, &quot;dog&quot;, &quot;sand&quot;, &quot;and&quot;, &quot;cat&quot;]输出: false 标准答案 属于完全背包问题,考察的标准不再是体重，价值之类的数值型标准了，而是字符串。dp数组记录当前位置i是否可分。 代码 12345678910111213141516171819class Solution: def wordBreak(self, s, wordDict): """ :type s: str :type wordDict: List[str] :rtype: bool """ dp = [False] * (len(s) + 1) # dp[i] means s[:i+1] can be segmented into words in the wordDicts dp[0] = True for i in range(len(s)): for j in range(i+1, len(s)): if dp[i] and s[i: j] in wordDict: dp[j] = True return dp[-1]if __name__ == "__main__": a = Solution() print(a.wordBreak(s="catsandog", wordDict=["cats", "dog", "sand", "and", "cat"])) 494. 目标和 状态：不会 题目 给定一个非负整数数组，a1, a2, …, an, 和一个目标数，S。现在你有两个符号 + 和 -。 对于数组中的任意一个整数，你都可以从 + 或 -中选择一个符号添加在前面。 返回可以使最终数组和为目标数 S 的所有添加符号的方法数。 示例 1: 12345678910输入: nums: [1, 1, 1, 1, 1], S: 3输出: 5解释: -1+1+1+1+1 = 3+1-1+1+1+1 = 3+1+1-1+1+1 = 3+1+1+1-1+1 = 3+1+1+1+1-1 = 3一共有5种方法让最终目标和为3。 注意: 数组的长度不会超过20，并且数组中的值全为正数。 初始的数组的和不会超过1000。 保证返回的最终结果为32位整数。 标准答案 这题要根据公式推导转换为背包问题 在nums中，有部分正数和负数。p表示所有正数的集合，q表示所有负数的集合，那么有sum§ - sum(q) = S， sum§ + sum(q) = sum(all) 以上两个公式转换可得： sum§ = (sum(all) + S)/2 那么，这个问题转换为单纯的背包价值问题。选择将不同价值的物品放入背包与否。 代码 12345678910111213141516171819202122class Solution: def findTargetSumWays(self, nums, S): """ :type nums: List[int] :type S: int :rtype: int """ s = sum(nums) N = s + S if N % 2 or S &gt; s: return 0 N = N // 2 dp = [0 for _ in range(N + 1)] dp[0] = 1 for num in nums: for i in range(N, num - 1, -1): dp[i] += dp[i - num] return dp[-1]if __name__ == "__main__": a = Solution() print(a.findTargetSumWays(nums=[1, 1, 1, 1, 1], S=3)) 547. 朋友圈 状态：不会 题目 班上有 N 名学生。其中有些人是朋友，有些则不是。他们的友谊具有是传递性。 如果已知 A 是 B 的朋友，B 是 C 的朋友，那么我们可以认为 A 也是 C 的朋友。 所谓的朋友圈，是指所有朋友的集合。 给定一个 N * N 的矩阵 M，表示班级中学生之间的朋友关系。 如果M[i][j] = 1，表示已知第 i 个和 j 个学生互为朋友关系，否则为不知道。 你必须输出所有学生中的已知的朋友圈总数。 示例 1: 1234567输入: [[1,1,0], [1,1,0], [0,0,1]]输出: 2 说明：已知学生0和学生1互为朋友，他们在一个朋友圈。第2个学生自己在一个朋友圈。所以返回2。 示例 2: 123456输入: [[1,1,0], [1,1,1], [0,1,1]]输出: 1说明：已知学生0和学生1互为朋友，学生1和学生2互为朋友，所以学生0和学生2也是朋友，所以他们三个在一个朋友圈，返回1。 标准答案 这题有两种解题思路，一个是DFS，另一个是并查集。 DFS： 依次遍历每个人，查看当前这个人所有的关系网，如果这个人有新朋友，添加到已查看集合中去，并再次查看这个新朋友的关系网，依次循环往复。 DFS代码 12345678910111213141516171819202122232425class Solution: def findCircleNum(self, M): """ :type M: List[List[int]] :rtype: int """ N = len(M) seen = set() def dfs(node): for nei, adj in enumerate(M[node]): if adj and nei not in seen: seen.add(nei) dfs(nei) ans = 0 for i in range(N): if i not in seen: dfs(i) ans += 1 return ansif __name__ == "__main__": a = Solution() print(a.findCircleNum(M=[[1,1,0], [1,1,0], [0,0,1]])) 并查集代码 1234567891011121314151617181920212223242526272829303132333435363738394041424344class UnionFind(object): def __init__(self, grid): self.n = len(grid) self.parent = [-1] * self.n for idx in range(self.n): self.parent[idx] = idx def find(self, i): if self.parent[i] != i: self.parent[i] = self.find(self.parent[i]) return self.parent[i] def union(self, x, y): rootx = self.find(x) rooty = self.find(y) if rootx != rooty: self.parent[rooty] = rootx def diff_groups(self): diff_groups = set() for i in range(self.n): diff_groups.add(self.find(i)) return len(diff_groups)class Solution(object): def findCircleNum(self, M): &quot;&quot;&quot; :type M: List[List[int]] :rtype: int &quot;&quot;&quot; n = len(M) uf = UnionFind(M) for i in range(n): for j in range(n): if M[i][j] == 1: uf.union(i, j) return uf.diff_groups()if __name__ == &quot;__main__&quot;: a = Solution() M = [[1, 1, 0], [1, 1, 0], [0, 0, 1]] print(a.findCircleNum(M=M)) 128. 最长连续序列 状态：第二遍通过11.11% 题目 给定一个未排序的整数数组，找出最长连续序列的长度。 要求算法的时间复杂度为 O(n)。 示例: 123输入: [100, 4, 200, 1, 3, 2]输出: 4解释: 最长连续序列是 [1, 2, 3, 4]。它的长度为 4。 version2 过程： 成绩： 代码 12345678910111213141516171819202122232425262728class Solution: def longestConsecutive(self, nums): """ :type nums: List[int] :rtype: int """ if nums == []: return 0 nums=sorted(list(set(nums))) res = [] for i in range(len(nums)): tmp = nums[:i+1] if res: tmp_res = res[-1] else: tmp_res = 1 if len(tmp) == 1: tmp_res = 1 res.append(tmp_res) elif res[-1] &gt;= 1: if tmp[-1] == tmp[-2]+1: tmp_res += 1 res[-1] = tmp_res elif tmp[-1] == tmp[-2]: continue else: res.append(1) return max(res) 标准答案 首先对数组去重即集合，遍历集合中的每个元素，并弹出该元素，找出比这个元素小1或者大1的元素，并分别更新连续值标记。 标准代码 123456789101112131415161718192021222324class Solution: def longestConsecutive(self, nums): """ :type nums: List[int] :rtype: int """ num = set(nums) maxLen = 0 while num: n = num.pop() i = n + 1 l1 = 0 l2 = 0 while i in num: num.remove(i) i += 1 l1 += 1 i = n - 1 while i in num: num.remove(i) i -= 1 l2 += 1 maxLen = max(maxLen, l1 + l2 + 1) return maxLen 130. 被围绕的区域 状态：不会 题目 给定一个二维的矩阵，包含 ‘X’ 和 ‘O’（字母 O）。 找到所有被 ‘X’ 围绕的区域，并将这些区域里所有的 ‘O’ 用 ‘X’ 填充。 示例: 1234X X X XX O O XX X O XX O X X 运行你的函数后，矩阵变为： 1234X X X XX X X XX X X XX O X X 解释: 被围绕的区间不会存在于边界上，换句话说，任何边界上的 ‘O’ 都不会被填充为 ‘X’。 任何不在边界上，或不与边界上的 ‘O’ 相连的 ‘O’ 最终都会被填充为 ‘X’。 如果两个元素在水平或垂直方向相邻，则称它们是“相连”的。 标准答案 这一题与200. 岛屿的个数以及695. 岛屿的最大面积背景类似，解题关键在于找到边界，题目中的关键信息是把除边界以外的‘O’改成‘X’，那么就应该找到边界‘O’，不仅是四周的‘O’，还包括与边界‘O’相连的‘O’，这里就用到了深度优先搜索。 标准代码 1234567891011121314151617181920212223242526272829303132 class Solution: def solve(self, board): """ :type board: List[List[str]] :rtype: void Do not return anything, modify board in-place instead. """ alive, v = set(), set() for r in range(len(board)): for c in range(len(board[r])): if r == 0 or r == len(board) - 1 or c == 0 or c == len(board[0]) - 1: self.traverse(board, r, c, alive) for r in range(len(board)): for c in range(len(board[r])): if board[r][c] == 'O' and (r, c) not in alive: board[r][c] = 'X' for i in board: print(i) def traverse(self, board, r, c, alive): if (r, c) in alive or r &lt; 0 or r &gt; len(board) - 1 or c &lt; 0 or c &gt; len(board[0]) - 1 or board[r][c] != 'O': return else: alive.add((r, c)) self.traverse(board, r + 1, c, alive) self.traverse(board, r, c + 1, alive) self.traverse(board, r - 1, c, alive) self.traverse(board, r, c - 1, alive)if __name__ == "__main__": a = Solution() a.solve(board=[['X', 'X', 'X', 'X'], ['X', 'O', 'O', 'X'], ['X', 'X', 'O', 'X'], ['X', 'O', 'X', 'X']]) 3. 无重复字符的最长子串 状态：不会 题目 给定一个字符串，请你找出其中不含有重复字符的 最长子串 的长度。 示例 1: 123输入: &quot;abcabcbb&quot;输出: 3 解释: 因为无重复字符的最长子串是 &quot;abc&quot;，所以其长度为 3。 示例 2: 123输入: &quot;bbbbb&quot;输出: 1解释: 因为无重复字符的最长子串是 &quot;b&quot;，所以其长度为 1。 示例 3: 1234输入: &quot;pwwkew&quot;输出: 3解释: 因为无重复字符的最长子串是 &quot;wke&quot;，所以其长度为 3。 请注意，你的答案必须是 子串 的长度，&quot;pwke&quot; 是一个子序列，不是子串。 标准答案 题目要求找到最大的不重复子串，运用双指针方法，详细解释见 https://zhuanlan.zhihu.com/p/36074066 代码 12345678910111213141516171819class Solution: def lengthOfLongestSubstring(self, s): """ :type s: str :rtype: int """ dict = &#123;&#125; begin, res = -1, 0 for end in range(len(s)): if s[end] in dict and begin &lt; dict[s[end]]: begin = dict[s[end]] else: res = max(res, end-begin)#end-begin记录目前不重复子串的长度，res是目前最大不重复子串的长度 dict[s[end]] = end return resif __name__ == "__main__": a = Solution() print(a.lengthOfLongestSubstring(s="pwwkew")) 684. 冗余连接 状态：不会 题目 在本问题中, 树指的是一个连通且无环的无向图。 输入一个图，该图由一个有着N个节点 (节点值不重复1, 2, …, N) 的树及一条附加的边构成。 附加的边的两个顶点包含在1到N中间，这条附加的边不属于树中已存在的边。 结果图是一个以边组成的二维数组。每一个边的元素是一对[u, v] ，满足 u &lt; v，表示连接顶点u 和v的无向图的边。 返回一条可以删去的边，使得结果图是一个有着N个节点的树。如果有多个答案，则返回二维数组中最后出现的边。 答案边[u, v] 应满足相同的格式 u &lt; v。 示例 1： 123456输入: [[1,2], [1,3], [2,3]]输出: [2,3]解释: 给定的无向图为: 1 / \2 - 3 示例 2： 123456输入: [[1,2], [2,3], [3,4], [1,4], [1,5]]输出: [1,4]解释: 给定的无向图为:5 - 1 - 2 | | 4 - 3 注意: 输入的二维数组大小在 3 到 1000。 二维数组中的整数在1到N之间，其中N是输入数组的大小。 标准答案 题目看着就很烦，他想表达的意思是找出使得图连通的最后一条边，删去这个边，输入的图就不再连通了，这一题参考博客 http://wulc.me/2017/10/12/LeetCode 解题报告(684,685,721)-并查集介绍及应用/ 可以更好地理解并查集这种数据结构，并提到了路径压缩和按等级合并，这两个步骤可以降低算法的时间复杂度。 代码 1234567891011121314151617181920212223242526272829303132333435363738394041class UnionFindSet(object): def __init__(self): self.parents = list(range(1001)) self.rank = [0] * 1001 def find(self, val): """find with path compression""" if self.parents[val] != val: self.parents[val] = self.find(self.parents[val]) return self.parents[val] def union(self, v1, v2): """union by rank, check whether union two vertics will lead to a cycle""" p1, p2 = self.find(v1), self.find(v2) if p1 == p2: return True elif self.rank[p1] &gt; self.rank[p2]: self.parents[p2] = p1 elif self.rank[p1] &lt; self.rank[p2]: self.parents[p1] = p2 else: self.rank[p2] += 1 self.parents[p1] = p2 return Falseclass Solution(object): def findRedundantConnection(self, edges): """ :type edges: List[List[int]] :rtype: List[int] """ ufs = UnionFindSet() for edge in edges: if ufs.union(edge[0], edge[1]): return edgeif __name__ == "__main__": a = Solution() print(a.findRedundantConnection(edges=[[1,2], [2,3], [3,4], [1,4], [1,5]])) 685. 冗余连接 II 状态：不会 题目 在本问题中，有根树指满足以下条件的有向图。 该树只有一个根节点，所有其他节点都是该根节点的后继。 每一个节点只有一个父节点，除了根节点没有父节点。 输入一个有向图，该图由一个有着N个节点 (节点值不重复1, 2, …, N) 的树及一条附加的边构成。 附加的边的两个顶点包含在1到N中间，这条附加的边不属于树中已存在的边。 结果图是一个以边组成的二维数组。 每一个边的元素是一对[u, v]，用以表示有向图中连接顶点 u and v和顶点的边，其中父节点u是子节点v的一个父节点。 返回一条能删除的边，使得剩下的图是有N个节点的有根树。若有多个答案，返回最后出现在给定二维数组的答案。 示例 1: 1234567输入: [[1,2], [1,3], [2,3]]输出: [2,3]解释: 给定的有向图如下: 1 / \v v2 --&gt;3 示例 2: 1234567输入: [[1,2], [2,3], [3,4], [4,1], [1,5]]输出: [4,1]解释: 给定的有向图如下:5 &lt;- 1 -&gt; 2 ^ | | v 4 &lt;- 3 注意: 二维数组大小的在3到1000范围内。 二维数组中的每个整数在1到N之间，其中 N 是二维数组的大小。 标准答案 这一题与Leetcode 684相似，不过难度升级，从无向图变为有向图，要返回的边使得删除这条边之后输入的有向图变为一颗合格树。 而 合格树要求每个节点只有一个父节点，根据这个要求可以先筛选一遍，看图中是否存在多个父节点的点，那么要删除的边就在里面。 参考博客： http://wulc.me/2017/10/12/LeetCode 解题报告(684,685,721)-并查集介绍及应用/ 代码 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859class UnionFindSet(object): def __init__(self): self.parents = list(range(1001)) self.rank = [0] * 1001 def find(self, val): """find with path compression""" if self.parents[val] != val: self.parents[val] = self.find(self.parents[val]) return self.parents[val] def union(self, v1, v2): """union by rank, check whether union two vertics will lead to a cycle""" p1, p2 = self.find(v1), self.find(v2) if p1 == p2: return True elif self.rank[p1] &gt; self.rank[p2]: self.parents[p2] = p1 elif self.rank[p1] &lt; self.rank[p2]: self.parents[p1] = p2 else: self.rank[p2] += 1 self.parents[p1] = p2 return Falseclass Solution(object): def findRedundantDirectedConnection(self, edges): """ :type edges: List[List[int]] :rtype: List[int] """ redundant_edges = None count = &#123;&#125; for e in edges: if e[1] not in count: count[e[1]] = [] count[e[1]].append(e) if len(count[e[1]]) == 2: redundant_edges = count[e[1]] break if redundant_edges: ufs = UnionFindSet() for edge in edges: if edge == redundant_edges[1]: continue if ufs.union(edge[0], edge[1]): return redundant_edges[0] return redundant_edges[1] else: ufs = UnionFindSet() for edge in edges: if ufs.union(edge[0], edge[1]): return edgeif __name__ == "__main__": a = Solution() print(a.findRedundantDirectedConnection(edges=[[1,2], [1,3], [2,3]])) 721. 账户合并 状态：不会 题目 给定一个列表 accounts，每个元素 accounts[i] 是一个字符串列表， 其中第一个元素 accounts[i][0] 是 名称 (name)，其余元素是 emails 表示该帐户的邮箱地址。 现在，我们想合并这些帐户。如果两个帐户都有一些共同的邮件地址，则两个帐户必定属于同一个人。 请注意，即使两个帐户具有相同的名称，它们也可能属于不同的人，因为人们可能具有相同的名称。 一个人最初可以拥有任意数量的帐户，但其所有帐户都具有相同的名称。 合并帐户后，按以下格式返回帐户： 每个帐户的第一个元素是名称，其余元素是按顺序排列的邮箱地址。accounts 本身可以以任意顺序返回。 例子 1: 12345678910Input: accounts = [[&quot;John&quot;, &quot;johnsmith@mail.com&quot;, &quot;john00@mail.com&quot;], [&quot;John&quot;, &quot;johnnybravo@mail.com&quot;], [&quot;John&quot;, &quot;johnsmith@mail.com&quot;, &quot;john_newyork@mail.com&quot;], [&quot;Mary&quot;, &quot;mary@mail.com&quot;]]Output: [[&quot;John&quot;, &apos;john00@mail.com&apos;, &apos;john_newyork@mail.com&apos;, &apos;johnsmith@mail.com&apos;], [&quot;John&quot;, &quot;johnnybravo@mail.com&quot;], [&quot;Mary&quot;, &quot;mary@mail.com&quot;]]Explanation: 第一个和第三个 John 是同一个人，因为他们有共同的电子邮件 &quot;johnsmith@mail.com&quot;。 第二个 John 和 Mary 是不同的人，因为他们的电子邮件地址没有被其他帐户使用。 我们可以以任何顺序返回这些列表，例如答案[[&apos;Mary&apos;，&apos;mary@mail.com&apos;]，[&apos;John&apos;，&apos;johnnybravo@mail.com&apos;]， [&apos;John&apos;，&apos;john00@mail.com&apos;，&apos;john_newyork@mail.com&apos;，&apos;johnsmith@mail.com&apos;]]仍然会被接受。 注意： accounts的长度将在[1，1000]的范围内。 accounts[i]的长度将在[1，10]的范围内。 accounts[i][j]的长度将在[1，30]的范围内。 标准答案 使用并查集或者DFS，这道题目里用到了路径压缩(找到u所在的树根v以后，把从u到v的路径上所有点的父亲都设置为v)，注意parent是父节点并不是根节点。怎么去并，去并谁也是要想清楚的，比如这一题我们要合并的是账号，那么遍历账号，根据邮箱一样这个筛选条件去合并。 代码 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152from collections import defaultdictclass UnionFind(): def __init__(self, n): self.parent = [i for i in range(n)] def find(self, x): while self.parent[x] != x: self.parent[x] = self.parent[self.parent[x]] x = self.parent[x] return x def union(self, x, y): rootx = self.find(x) rooty = self.find(y) if rootx != rooty: self.parent[rooty] = rootxclass Solution: def accountsMerge(self, accounts): """ :type accounts: List[List[str]] :rtype: List[List[str]] """ n = len(accounts) uf = UnionFind(n) dict = &#123;&#125; for i, a in enumerate(accounts): for email in a[1:]: if email in dict: r1, r2 = uf.find(i), uf.find(dict[email]) uf.parent[r2] = r1 else: dict[email] = i dict_res = defaultdict(set) for k in range(n): dict_res[uf.find(k)] |= set(accounts[k][1:]) res = [] for k,v in dict_res.items(): res.append([accounts[k][0]]+sorted(v)) return resif __name__ == "__main__": a = Solution() print(a.accountsMerge(accounts=[["David","David0@m.co","David1@m.co"],\ ["David","David3@m.co","David4@m.co"],\ ["David","David4@m.co","David5@m.co"],\ ["David","David2@m.co","David3@m.co"],\ ["David","David1@m.co","David2@m.co"]])) 763. 划分字母区间 状态：不会 题目 字符串 S 由小写字母组成。 我们要把这个字符串划分为尽可能多的片段，同一个字母只会出现在其中的一个片段。 返回一个表示每个字符串片段的长度的列表。 示例 1: 123456输入: S = &quot;ababcbacadefegdehijhklij&quot;输出: [9,7,8]解释:划分结果为 &quot;ababcbaca&quot;, &quot;defegde&quot;, &quot;hijhklij&quot;。每个字母最多出现在一个片段中。像 &quot;ababcbacadefegde&quot;, &quot;hijhklij&quot; 的划分是错误的，因为划分的片段数较少。 注意: 12S的长度在[1, 500]之间。S只包含小写字母&apos;a&apos;到&apos;z&apos;。 标准答案 记录每个字符出现的最后一个索引，遍历字符串时，将每个字符与记录索引对比从而求得每个字符区间。 代码 123456789101112131415161718192021222324class Solution: def partitionLabels(self, S): """ :type S: str :rtype: List[int] """ dic = dict() for i, ch in enumerate(S): dic[ch] = i cnt = [-1] cur = 0 for i, ch in enumerate(S): cur = max(cur, dic[ch]) if i == cur: cnt.append(cur) cur = i + 1 re = [] for i in range(1, len(cnt)): re.append(cnt[i] - cnt[i - 1]) return reif __name__ == "__main__": a = Solution() print(a.partitionLabels(S = "ababcbacadefegdehijhklij")) 93. 复原IP地址 状态：不会 题目 给定一个只包含数字的字符串，复原它并返回所有可能的 IP 地址格式。 示例: 12输入: "25525511135"输出: ["255.255.11.135", "255.255.111.35"] 标准答案 DFS 代码 123456789101112131415161718192021222324252627class Solution: def restoreIpAddresses(self, s): """ :type s: str :rtype: List[str] """ res = [] self.dfs(s, 0, "", res) return res def dfs(self, s, index, path, res): if index == 4: if not s: res.append(path[:-1]) return for i in range(1, 4): if i &lt;= len(s): if i == 1: self.dfs(s[1:], index + 1, path + s[0] + '.', res) elif i == 2 and s[0] != '0': self.dfs(s[2:], index + 1, path + s[:2] + '.', res) elif i == 3 and s[0] != '0' and int(s[:3]) &lt; 256: self.dfs(s[3:], index + 1, path + s[:3] + '.', res)if __name__ == "__main__": a = Solution() print(a.restoreIpAddresses(s="25525511135")) 393. UTF-8 编码验证 状态：空间复杂度未通过 题目 UTF-8 中的一个字符可能的长度为 1 到 4 字节，遵循以下的规则： 对于 1 字节的字符，字节的第一位设为0，后面7位为这个符号的unicode码。 对于 n 字节的字符 (n &gt; 1)，第一个字节的前 n 位都设为1，第 n+1 位设为0，后面字节的前两位一律设为10。 剩下的没有提及的二进制位，全部为这个符号的unicode码。 这是 UTF-8 编码的工作方式： Char. number range UTF-8 octet sequence 0000 0000-0000 007F 0xxxxxxx 0000 0080-0000 07FF 110xxxxx 10xxxxxx 0000 0800-0000 FFFF 1110xxxx 10xxxxxx 10xxxxxx 0001 0000-0010 FFFF 11110xxx 10xxxxxx 10xxxxxx 10xxxxxx 给定一个表示数据的整数数组，返回它是否为有效的 utf-8 编码。 注意: 输入是整数数组。只有每个整数的最低 8 个有效位用来存储数据。这意味着每个整数只表示 1 字节的数据。 示例 1: 123data = [197, 130, 1], 表示 8 位的序列: 11000101 10000010 00000001.返回 true 。这是有效的 utf-8 编码，为一个2字节字符，跟着一个1字节字符。 示例 2: 12345data = [235, 140, 4], 表示 8 位的序列: 11101011 10001100 00000100.返回 false 。前 3 位都是 1 ，第 4 位为 0 表示它是一个3字节字符。下一个字节是开头为 10 的延续字节，这是正确的。但第二个延续字节不以 10 开头，所以是不符合规则的。 代码 1234567891011121314151617181920212223242526272829303132333435363738394041424344class Solution: def validUtf8(self, data): """ :type data: List[int] :rtype: bool """ if not data: return True if self.Binary(data[0])[2] == '0': if len(data) == 1: return True else: return self.validUtf8(data[1:]) else: cB = self.countB(data[0]) if cB == 1 or cB &gt; 4: return False if len(data) &gt;= cB: for i in range(1, cB): if self.Binary(data[i])[2:4] != '10': return False return self.validUtf8(data[cB:]) else: return False def Binary(self, num): b_num_len = len(bin(num)) if b_num_len != 10: return '0b'+'0'*(10-b_num_len)+bin(num)[2:] else: return bin(num) def countB(self, num): cnt = 0 for b in self.Binary(num)[2:]: if b == '1': cnt += 1 else: return cnt return cntif __name__ == "__main__": a = Solution() print(a.validUtf8(data=[250,145,145,145,145])) 851. 喧闹和富有 状态：不会 题目 在一组 N 个人（编号为 0, 1, 2, …, N-1）中，每个人都有不同数目的钱，以及不同程度的安静（quietness）。 为了方便起见，我们将编号为 x 的人简称为 &quot;person x &quot;。 如果能够肯定 person x 比 person y 更有钱的话，我们会说 richer[i] = [x, y] 。注意 richer 可能只是有效观察的一个子集。 另外，如果 person x 的安静程度为 q ，我们会说 quiet[x] = q 。 现在，返回答案 answer ，其中 answer[x] = y 的前提是，在所有拥有的钱不少于 person x 的人中，person y 是最安静的人（也就是安静值 quiet[y] 最小的人）。 示例： 12345678910111213输入：richer = [[1,0],[2,1],[3,1],[3,7],[4,3],[5,3],[6,3]], quiet = [3,2,5,4,6,1,7,0]输出：[5,5,2,5,4,5,6,7]解释： answer[0] = 5，person 5 比 person 3 有更多的钱，person 3 比 person 1 有更多的钱，person 1 比 person 0 有更多的钱。唯一较为安静（有较低的安静值 quiet[x]）的人是 person 7，但是目前还不清楚他是否比 person 0 更有钱。answer[7] = 7，在所有拥有的钱肯定不少于 person 7 的人中(这可能包括 person 3，4，5，6 以及 7)，最安静(有较低安静值 quiet[x])的人是 person 7。其他的答案也可以用类似的推理来解释。 提示： 1 &lt;= quiet.length = N &lt;= 500 0 &lt;= quiet[i] &lt; N，所有 quiet[i] 都不相同。 0 &lt;= richer.length &lt;= N * (N-1) / 2 0 &lt;= richer[i][j] &lt; N richer[i][0] != richer[i][1] richer[i] 都是不同的。 对 richer 的观察在逻辑上是一致的。 标准答案 综合运用动态规划和记忆存储，这道题最佳答案秒在对安静数组进行排序，导致首先遍历最安静的人，那么这个人对应的答案就是自己，因为符合比自己富有（包括自己），并且最安静的要求。 紧接着遍历比这个人穷的人，并且标记每个穷人的答案就是这个人，因为符合相对富有且最安静的要求。 代码 1234567891011121314151617181920212223242526272829303132333435import collectionsclass Solution: def loudAndRich(self, richer, quiet): """ :type richer: List[List[int]] :type quiet: List[int] :rtype: List[int] """ graph = collections.defaultdict(list) for a, b in richer: graph[a].append(b) qi = [[q, i] for i, q in enumerate(quiet)] # !! look at me qi.sort() res = [-1] * len(quiet) def search(i, t): res[i] = t for adj in graph[i]: if res[adj] == -1: search(adj, t) for q, i in qi: if res[i] == -1: search(i, i) return resif __name__ == "__main__": a = Solution() print(a.loudAndRich(richer=[[0,1],[1,2]], quiet = [0,1,2])) 5. 最长回文子串 状态：不会 题目 给定一个字符串 s，找到 s 中最长的回文子串。你可以假设 s 的最大长度为 1000。 示例 1： 123输入: &quot;babad&quot; 输出: &quot;bab&quot; 注意: &quot;aba&quot; 也是一个有效答案。 示例 2： 12输入: &quot;cbbd&quot; 输出: &quot;bb&quot; 标准答案 回文子串一共有两种类型： 1.aba 2.abba 按照这两种类型的组成特点，依次从内到外遍历。利用记忆存储当前状态下的最长回文子串。 代码 1234567891011121314151617181920212223class Solution(object): def longestPalindrome(self, s): &quot;&quot;&quot; :type s: str :rtype: str &quot;&quot;&quot; res = &quot;&quot; for i in xrange(len(s)): # odd case, like &quot;aba&quot; tmp = self.helper(s, i, i) if len(tmp) &gt; len(res): res = tmp # even case, like &quot;abba&quot; tmp = self.helper(s, i, i+1) if len(tmp) &gt; len(res): res = tmp return res # get the longest palindrome, l, r are the middle indexes # from inner to outer def helper(self, s, l, r): while l &gt;= 0 and r &lt; len(s) and s[l] == s[r]: l -= 1; r += 1 return s[l+1:r] 63. 不同路径 II 状态：排名85.07% 题目 一个机器人位于一个 m x n 网格的左上角 （起始点在下图中标记为“Start” ）。 机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为“Finish”）。 现在考虑网格中有障碍物。那么从左上角到右下角将会有多少条不同的路径？ 网格中的障碍物和空位置分别用 1 和 0 来表示。 说明：m 和 n 的值均不超过 100。 示例 1: 123456789101112输入:[ [0,0,0], [0,1,0], [0,0,0]]输出: 2解释:3x3 网格的正中间有一个障碍物。从左上角到右下角一共有 2 条不同的路径：1. 向右 -&gt; 向右 -&gt; 向下 -&gt; 向下2. 向下 -&gt; 向下 -&gt; 向右 -&gt; 向右 标准答案 62. 不同路径的衍生版本，主要难点在于边界条件，在for循环之后要特别考虑有一些特殊情况容易漏掉。 代码 1234567891011121314151617181920212223242526272829303132333435363738394041class Solution(object): def uniquePathsWithObstacles(self, obstacleGrid): &quot;&quot;&quot; :type obstacleGrid: List[List[int]] :rtype: int &quot;&quot;&quot; if obstacleGrid[0][0] == 1: return 0 m = len(obstacleGrid) n = len(obstacleGrid[0]) if m == 1: if 1 in obstacleGrid[0]: return 0 else: return 1 if n == 1: for row in obstacleGrid: if 1 in row: return 0 return 1 res = [[0 for i in range(n)] for j in range(m)] res[0][0] = 1 for i in range(m): for j in range(n): if i == 0 and j == 0: continue if obstacleGrid[i][j] == 1: res[i][j] = 0 elif i == 0 and j &gt; 0: res[i][j] = res[i][j-1] elif j == 0 and i &gt; 0: res[i][j] = res[i-1][j] else: res[i][j] = res[i - 1][j] + res[i][j-1] return res[-1][-1]if __name__ == &quot;__main__&quot;: a = Solution() print(a.uniquePathsWithObstacles(obstacleGrid=[[1,0],[0,0]])) 39. 组合总和 状态：不会 题目 给定一个无重复元素的数组candidates和一个目标数target，找出candidates中所有可以使数字和为target的组合。 candidates中的数字可以无限制重复被选取。 说明： 所有数字（包括target）都是正整数。 解集不能包含重复的组合。 示例 1: 123456输入: candidates = [2,3,6,7], target = 7,所求解集为:[ [7], [2,2,3]] 示例 2: 1234567输入: candidates = [2,3,5], target = 8,所求解集为:[ [2,2,2,2], [2,3,3], [3,5]] 标准答案 主要还是递归，不过递归中加入更多的限制条件。 参考：回溯算法+剪枝 代码 12345678910111213141516171819202122232425262728293031323334353637383940414243import java.util.List;import java.util.Stack;import java.util.ArrayList;import java.util.Arrays;public class Solution &#123; private List&lt;List&lt;Integer&gt;&gt; res = new ArrayList&lt;&gt;(); private int[] candidates; private int len; private void findCombinationSum(int residue, int start, Stack&lt;Integer&gt; pre) &#123; if (residue == 0) &#123; res.add(new ArrayList&lt;&gt;(pre)); return; &#125; for (int i = start; i &lt; len &amp;&amp; residue - candidates[i] &gt;= 0; i++) &#123; pre.add(candidates[i]); findCombinationSum(residue-candidates[i], i, pre); pre.pop(); &#125; &#125; public List&lt;List&lt;Integer&gt;&gt; combinationSum(int[] candidates, int target)&#123; int len = candidates.length; if (len == 0) &#123; return res; &#125; Arrays.sort(candidates); this.len = len; this.candidates = candidates; findCombinationSum(target, 0, new Stack&lt;&gt;()); return res; &#125; public static void main(String[] args) &#123; int[] candidates = &#123;2, 3, 6, 7&#125;; int target = 7; Solution solution = new Solution(); List&lt;List&lt;Integer&gt;&gt; combinationSum = solution.combinationSum(candidates, target); System.out.println(combinationSum); &#125; 40. 组合总和II 状态：不会 题目 给定一个数组candidates和一个目标数target，找出candidates中所有可以使数字和为target的组合。 candidates中的每个数字在每个组合中只能使用一次。 说明： 所有数字（包括目标数）都是正整数。 解集不能包含重复的组合。 示例 1: 12345678输入: candidates = [10,1,2,7,6,1,5], target = 8,所求解集为:[ [1, 7], [1, 2, 5], [2, 6], [1, 1, 6]] 示例 2: 123456输入: candidates = [2,5,2,1,2], target = 5,所求解集为:[ [1,2,2], [5]] 标准答案 39. 组合总和的衍生版本，主要不同在于每个数字只能使用一次。 参考自liweiwei1419的详细解答。 代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445import java.util.ArrayList;import java.util.Arrays;import java.util.List;import java.util.Stack;public class Solution &#123; private List&lt;List&lt;Integer&gt;&gt; res = new ArrayList(); private int[] candidates; private int target; private int len; private void findCombinationSum(int residue, int start, Stack&lt;Integer&gt;pre) &#123; if(residue == 0) &#123; res.add(new ArrayList&lt;&gt;(pre)); return; &#125; for(int i = start; i &lt; len &amp;&amp; residue - candidates[i] &gt;= 0; i++) &#123; if(i &gt; start &amp;&amp; candidates[i] == candidates[i-1]) &#123; continue; &#125; pre.add(candidates[i]); findCombinationSum(residue-candidates[i], i+1, pre); pre.pop(); &#125; &#125; public List&lt;List&lt;Integer&gt;&gt; combinationSum2(int[] candidates, int target) &#123; this.len = candidates.length; this.candidates = candidates; if(len == 0) &#123; return res; &#125; Arrays.sort(candidates); findCombinationSum(target, 0, new Stack&lt;&gt;()); return res; &#125; public static void main(String[] args) &#123; int[] candidates = &#123;2, 5, 2, 1, 2&#125;; int target = 5; Solution solution = new Solution(); List&lt;List&lt;Integer&gt;&gt; combinationSum2 = solution.combinationSum2(candidates, target); System.out.println(combinationSum2); &#125;&#125;]]></content>
      <categories>
        <category>IT应聘</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode作战计划]]></title>
    <url>%2F2019%2F12%2F14%2FLeetCode%E4%BD%9C%E6%88%98%E8%AE%A1%E5%88%92%2F</url>
    <content type="text"><![CDATA[规划 论文初稿完成，目前处于投递期刊状态😐看看各大公司招聘预告😱7月中旬开始校招，想想真是没时间喘息啊🙅是时候好好规划下了 规划Version1 预期4周的时间完成LeetCode绝大部分题型，熟悉总结解题规律，到7月中旬就可以尝试去参加笔试面试了😝 123406/19--06/24: 数组(10)、动态规划(10)06/25--07/01: 字符串(10)、数学(10)07/02--07/08: 哈希表(10)、树(10)07/09--07/15: 深度优先搜索(10)、二分查找(5) 目前的计划表就是这样，后期看情况调整，每周日来此汇报进度，并针对每种题型单独写博客整理解题思路。 按照上面的计划执行LeetCode一周后，每周做两组题型对我来说，难度颇大，没办法按时完成任务😔参考网上意见后决定暂时放弃LeetCode路线，LeetCode适合原本就是编程大神的人或者工作过一段时间的，并不适合小白类型的选手😲 决定换牛客网了，补充下基础知识，再去做算法题。牛客网有数据结构、算法等基础知识相关的选择题，做一做选择题复习下基础知识，还有招聘真题，牛客网应该更适合我循序渐进得准备笔试。 规划Version2 2018/6/25 12306/25--07/01: [数据结构]树、栈；[算法]排序(5)07/02--07/08: [数据结构]图、链表；[算法]复杂度(5)07/09--07/15: [数据结构]哈希、队列；[算法]查找(5) 规划Version3 感觉在写这第三个版本计划时，就是分分钟打脸的写照😑 之前规划7月中旬出去找实习，却被突然的中文核心等待一个月退稿而落幕。整个7月都在修改翻译论文投会议，也不知道有没有机会中。不管结果怎么样，小论文在研究生期间就这样了，也算是尽力了吧，整整从18年1月到7月，除去寒假过年，半年时间都在做论文这件事情。 目前找工作的进度最快也要到月底了，2周的时间，集中火力做前200道LeetCode中easy题目，快点出去面试，积攒面经，希望努力能找个大公司工作吧 规划Version4 永远有更打脸的😂整个秋招结束了仍然不会做几道算法题也是很失败了，现在准备抓住冬天的尾巴，再来准备最后一波春招。 在亲自参加一次应届生招聘季之后，体会到竞争的残酷以及自己的菜，在面试过程中，公司不会按照我之前的规划那样考察简单的数据结构题目，他们更喜欢考察经典的算法，比如动态规划、并查集、双指针等等。 很后悔没有参加实习招聘季了，走了很多弯路，抱怨是没用的，只能继续努力了。 现在每天一题的进度在做Leetcode，更侧重面试考察的经典算法题目，但这也只是通往面试的一个资格考试，后面还有机器学习算法的复习等等······ 数据结构 划分依据 数据类型 举例 集 合 无逻辑关系 逻辑 线性结构 一维数组、队列、栈 非线性结构 树、图、网 顺序存储结构 存储 链式存储结构 索引存储结构 散列存储结构 数组 日期：2018/06/22 16:15 一共13道题目，每道题目中往往结合固定几种方法解题，规律性较强，总结题目、标签对应如下： 题号 数组 哈希表 双指针 二分查找 分治算法 1 ★ ★ 4 ★ ★ ★ 11 ★ ★ 15 ★ ★ 16 ★ ★ 18 ★ ★ ★ 26 ★ ★ 283 ★ ★ 448 ★ 485 ★ 561 ★ 566 ★ 766 ★ 由此可以看出，数组类型的题目常与双指针、哈希表方法相结合。 统计完成情况： 13题中通过5题，正确率只有38%😭其中6道双指针题目，只会其中1题，双指针类型题目错误率占比38%😶也就是说数组题目中基本碰到双指针就基本都不会😶😶😶 题号 完成情况 1 ★ 4 ★ 11 题目旨意模糊，答案为返回最大容量 15 不会去重 16 无法将想法转换为编程语言 18 复杂 26 题目旨意模糊，不需要删除重复项，只要没有引用到即可 283 ★ 448 ★ 485 思路 561 ★ 566 特别函数 766 思路 特殊函数 第566题用到的两个函数，平常用的比较少： 1.降低数组维度 1sum([[1,2], [3,4]], []) 输出： 1[1,2,3,4] 2.压缩函数zip() 常规考虑 1.对部分数组题目进行排序操作，可以减少程序运行时间，降低复杂度。 1nums.sort() 树 日期：2018/06/27 20:57 转战牛客网后的第一次总结，牛客网上可以更好地巩固复习基础知识，选择题的正确率在55%左右。 基础知识 树形结构属于非线性结构、层次结构，可以顺序存储或者链式存储，操作有遍历和查找。属于“一对多”的数据类型。 森林指m棵互不相交的树的集合。 树中的关键概念： 有序树/无序树 如果将树中结点的各子树看成从左至右是有次序的（即不能互换），则称该树为有序树，否则称为无序树。 结点的层次 从根结点开始计算起，根为第一层，根的孩子为第二层，依次类推。树中结点的最大层次称为树的深度（Depth）或高度。 度 即结点的子树个数 度为0的结点为叶子结点 度为1的结点有1个分支 度为2的结点有2个分支 二叉树中不存在度大于2的结点 总结点数总比总度数多1 二叉树 二叉树（Binary Tree）的特点是每个结点至多具有两棵子树（即在二叉树中不存在度大于2的结点），并且子树之间有左右之分。 二叉树的性质： 在二叉树的第i层上至多有2i-1个结点（i≥1）。 深度为k的二叉树至多有2k-1个结点（k≥1）。 对任何一棵二叉树，如果其终端结点数为n0，度为2的结点数为n2，则n0=n2+1。 分类： 满二叉树 完全二叉树 叶子结点只能出现在最下层和次下层，且最下层的叶子结点集中在树的左部。 哈夫曼树(最优二叉树) 二叉树的度数与结点数： 假设总度数：k，叶子结点、度为1和度为2的结点个数分别即为$n_0,n_1,n_2$ 度：$k = n_2 \times 2 + n_1$ 结点：$k+1 = n_2 + n_1 + n_0$ 综合二式：$n_0 = n_2 + 1$ 二叉树的高度与结点数： 高度为h的二叉树，每层最多有$2^{h-1}$个结点。 对于高度为h满二叉树，其总结点数$2^h-1$。 具有N个结点的完全二叉树的高度h为$(\log_2 N)+1$ 二叉查找树（左&lt;中&lt;右） 若它的左子树不为空，则左子树上所有结点的值均小于它的根结点的值； 若它的右子树不为空，则右子树上所有结点的值均大于它的根结点的值； 它的左、右子树也分别为二叉查找树。 二叉查找树的基本操作是查找，插入，删除，遍历。 查找 查找某个节点时，先从根节点入手，如果该元素值小于根节点，则转向左子节点，否则转向右子节点，以此类推，直到找到该节点，或者到最后一个叶子节点依然没有找到，则证明树中没有该节点。 插入 插入一个新节点首先要确定插入的位置，关键思路是确定新节点父节点所在的位置。 删除 删除BST中的一个节点是最麻烦的操作，总结一下大概下面两种方法： 当删除点没有左孩子 只需要将该节点的父节点和当前节点的右孩子相连即可 删除节点10： 删除点有左孩子 先找到当前节点的左子树的最右节点，因为一个节点的左子树的最右节点也比右子树的最左节点小，把最右节点复制给删除点，然后删除最右节点。 删除节点20： 哈夫曼树(最优二叉树) 带权路径最短的二叉树。$$WPL=\sum_{i=1}^{n} {W_i}{I_i}$$其中，二叉树共有n个叶子结点，$W_i$:第i个叶子结点的权，$I_i$:根到第i个叶子结点的路径长度。 哈夫曼编码 需要编码的字符集合为{$C_1,C_2,…,C_n$}，各个字符在电文出现的次数集合为{$w_1,w_2,…,w_n$}，用$C_1,C_2,…,C_n$作为叶子，$w_1,w_2,…,w_n$作为各叶子的权构造一棵哈夫曼树。 哈夫曼树中，左分支上标0，右分支上标1，$C_i$的编码顺序为从根到该叶子结点$C_i$的顺序。 二叉树的遍历 遍历 顺序 先序 根→左子树→右子树 中序 左子树→根→右子树 后序 左子树→右子树→根 层次 从上到下，从左到右 遍历经常出的选择题型： 已知两种遍历顺序，例如中序和后序，要求确定一棵二叉树。 首先后序可以确定根结点，结合中序，区分左子树和右子树。再分别针对左子树和右子树，集合中序和后序，慢慢还原一棵二叉树。 编程的题目还没有得到有效训练，LeetCode由于对树有内部编码，与本地自己实现的编程有差异。 几种转换 树转换为二叉树 由于普通的树是无序的，将其转换为二叉树的步骤： 加线：所有兄弟结点之间加一条线 抹线：对树中的每一个结点，只保留它与第1个孩子结点之间的连线，删除它与其它孩子结点的连线 旋转：把虚线改为实线从水平方向向下旋转45°形成二叉树。 森林转换为二叉树 森林由若干棵树组成。 先把每棵树转换为二叉树 第一棵二叉树不动，从第二棵二叉树开始，依次把后一棵二叉树的根结点作为前一棵二叉树的根结点的右孩子结点，用线连接起来。当所有的二叉树连起来后得到的二叉树就是由森林转换得到的。 栈 日期：2018/07/03 23:00 基础知识 栈和队列都是特殊的线性表，只能有部分操作的线性表。 特点：插入和删除操作都在线性表的一端(栈顶)进行，即按“后进先出”的规则进行操作。 top指针永远指向栈顶： 空栈：top=-1 满栈：top=n(n为数组大小) 每压入1个元素进栈，则指针+1 存储 顺序栈 必须预先分配固定大小内存空间。 静态分配内存容易出现浪费空间或者上溢的情况。 链栈 动态结点分配消除存储空间上的限制，避免“栈上溢”错误。 出栈顺序 入栈顺序:ABCDEF，如果没有特别指明，可能指示： A入栈，A出栈，B入栈，B出栈等 前缀表达式 前缀表达式的计算机求值特点： 从右至左扫描表达式 遇到数字时，将数字压入堆栈 遇到运算符时，弹出栈顶的两个数，用运算符对它们做相应的计算，并将结果入栈 重复上述过程直至表达式最左端 最后运算得出的值即为表达式的结果(中缀结果) 汉诺塔(Hanoi) 涉及递归与栈的知识。 题目：4个圆盘的Hanoi塔,总的移动次数为多少？ 设f(n)为n个圆盘的hanoi塔总的移动次数， 其递推方程为f(n)=f(n-1)+1+ f(n-1)=2*f(n-1)+1。 理解就是先把上面n-1个圆盘移到第二个柱子上(共f(n-1)步）， 再把最后一个圆盘移到第三个柱子(共1步）， 再把第二柱子上的圆盘移动到第三个柱子上（共f(n-1)步）。 而f（1）=1；于是f(2)=3,f(3)=7,f(4)=15。 进一步，根据递推方程其实可以得出f(n) = 2^n - 1。 复杂度 时间复杂度 用栈顶指针表示栈顶，栈的插入和删除操作均在栈顶进行。 因此对于顺序存储和链式存储的栈，进行插入和删除运算的时间复杂度均为O(1)。 空间复杂度 卡特兰数 题目：若一序列的进栈顺序为A,B,C,D,E,问存在多少种可能的出栈序列？ $$f(n)=\frac{C_{2n}^n}{n+1}$$ 如上题，答案应为42。 哈希 日期：2018/08/06 16:04 基本知识 哈希表就是一种以 键-值(key-indexed) 存储数据的结构，输入待查找的值即key，即可查找到其对应的值。 像python中的字典就是基于哈希表实现的。 使用哈希函数将被查找的键转换为数组的索引。在理想的情况下，不同的键会被转换为不同的索引值，但是在有些情况下我们需要处理多个键被哈希到同一个索引值的情况。所以哈希查找的第二个步骤就是处理冲突 处理哈希碰撞冲突。 有很多处理哈希碰撞冲突的方法，本文后面会介绍拉链法和线性探测法。 哈希表是一个在时间和空间上做出权衡的经典例子。 如果没有内存限制，那么可以直接将键作为数组的索引。那么所有的查找时间复杂度为O(1)； 如果没有时间限制，那么我们可以使用无序数组并进行顺序查找，这样只需要很少的内存。 哈希表使用了适度的时间和空间来在这两个极端之间找到了平衡。只需要调整哈希函数算法即可在时间和空间上做出取舍。 哈希函数 哈希查找第一步就是使用哈希函数将键映射成索引。这种映射函数就是哈希函数。 哈希函数需要易于计算并且能够均匀分布所有键。 比如举个简单的例子，使用手机号码后三位就比前三位作为key更好，因为前三位手机号码的重复率很高。再比如使用身份证号码出生年月位数要比使用前几位数要更好。 在实际中，我们的键并不都是数字，有可能是字符串，还有可能是几个值的组合等，所以我们需要实现自己的哈希函数。 直接定址法 直接定址法的优点很明显，就是它不会产生重复的hash值。但由于它与键值本身有关系，所以当键值分布很散的时候，会浪费大量的存储空间。所以一般是不会用到直接定址法的。 1hash(k)= a*k+b 避免哈希冲突 定义一个hash函数hash(k)=k mod 10，假设key:[15,1,24,32,55,64,42,93,82,76] 0 1 2 3 4 5 6 7 8 9 1 32 93 24 15 76 42 64 55 82 开放定址法 $$hash_{i}=(hash(key)+d_{i}) mod m, i=1,2,…,k(k \leq m-1)$$ 其中，hash(key)是哈希函数，di是增量序列，i为已冲突的次数。 线性探测法 $$d_{i}=1,2,…,(m-1)$$ 即$d_{i}=i$，或者其它线性函数。相当于逐个探测存放地址的表，直到查找到一个空单元，然后放置在该单元。 对于[15,1,24,32,55,64,42,93,82,76]: 可以看到，在55之前都还没冲突： | 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 | |—|---|—|---|—|---|—|---|—|---| | | 1 | 32 | | 24| 15| | | | | 此时插入55，与15冲突，应用线性探测，此时i=1，可以得到： | 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 | |—|---|—|---|—|---|—|---|—|---| | | 1 | 32 | | 24| 15|55 | | | | 再插入64，冲突不少，要取到i=3： | 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 | |—|---|—|---|—|---|—|---|—|---| | | 1 | 32 | | 24| 15|55 | 64| | | 插入42，i=1： | 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 | |—|---|—|---|—|---|—|---|—|---| | | 1 | 32 | 42| 24| 15|55 | 64| | | 插入93，i=5： | 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 | |—|---|—|---|—|---|—|---|—|---| | | 1 | 32 | 42| 24| 15|55 | 64| 93| | 插入82，i=7： | 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 | |—|---|—|---|—|---|—|---|—|---| | | 1 | 32 | 42| 24| 15|55 | 64| 93| 82| 插入76，i=4： | 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 | |—|---|—|---|—|---|—|---|—|---| |76 | 1 | 32 | 42| 24| 15|55 | 64| 93| 82| 发现越到后面，冲突的越来越离谱。所以，表的大小选择也很重要，此例中选择了10作为表的大小，所以容易产生冲突。一般来讲，越是质数，mod取余就越可能分布的均匀。 平方探测 伪随机探测 链表法 拉链法解决冲突时，需要使用指针，指示下一个元素的存储位置。 各链表上的结点空间是动态申请的,故链表法更适合于造表前无法确定表长的情况。 拉链法的缺点是：指针需要额外的空间，故当结点规模较小时，开放定址法较为节省空间 数据结构总结 Hash操作能根据散列值直接定位数据的存储地址，设计良好的hash表能在常数级时间下找到需要的数据，但是更适合于内存中的查找。 B+树是一种是一种树状的数据结构，适合做索引，对磁盘数据来说，索引查找是比较高效的 STL_Map的内部实现是一颗红黑树，但是只是一颗在内存中建立二叉树树，不能用于磁盘操作，而其内存查找性能也比不上Hash查找。 算法 排序 日期：2018/07/04 21:31 分类 插入排序 不到最后一轮排序，存在完全变换序列位置的可能性。 直接插入排序 稳定排序方式。 折半插入排序(二分插入排序) 不太理解，也是稳定的排序方式。 希尔排序(缩小增量排序) 不稳定的排序方式。 交换排序 冒泡排序 冒泡排序最多要交换n(n-1)/2次。 两两比较和交换，是一种稳定的排序方式。 快速排序(划分排序) 以序列第一个元素为基准，两端各一个指针。 速度最快，但序列有序的情况下，反而插入排序更快。 但是一种不稳定的排序方式。 选择排序 简单选择排序 每一趟选出最小的，是一种不稳定的排序方式。 - 树形选择排序 从叶子节点开始，兄弟节点之间两两比赛，胜者上升到父节点。 是一种不稳定的排序方式。 堆排序 大根堆：从上到下-从大到小 小根堆：从上到下-从小到大 是一种不稳定的排序方式。 归并排序 最常见的是二路归并排序。 是一种要求内存最大、稳定的排序方式。 基数排序 多关键字排序 是一种稳定的排序方式。 链式基数排序 是一种稳定的排序方式。 外部排序 基本方法 多路归并排序 置换-选择排序 归纳表 图的遍历算法 深度优先搜索(Deep First Search,DFS) 对连通图进行遍历的算法。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849class Gragh(): def __init__(self,nodes,sides): ''' nodes 表示点 sides 表示边 ''' # self.sequense是字典，key是点，value是与key相连接的点 self.sequense = &#123;&#125; # self.side是临时变量，主要用于保存与指定点相连接的点 self.side=[] for node in nodes: for side in sides: u,v=side # 指定点与另一个点在同一个边中，则说明这个点与指定点是相连接的点，则需要将这个点放到self.side中 if node ==u: self.side.append(v) elif node == v: self.side.append(u) self.sequense[node] = self.side self.side=[] #print self.sequense ''' # Depth-First-Search 深度优先算法，是一种用于遍历或搜索树或图的算法。沿着树的深度遍历树的节点，尽可能深的搜索树的分支。 当节点v的所在边都己被探寻过，搜索将回溯到发现节点v的那条边的起始节点。 这一过程一直进行到已发现从源节点可达的所有节点为止。如果还存在未被发现的节点， 则选择其中一个作为源节点并重复以上过程，整个进程反复进行直到所有节点都被访问为止。属于盲目搜索。 ''' def DFS(self,node0): #queue本质上是堆栈，用来存放需要进行遍历的数据 #order里面存放的是具体的访问路径 queue,order=[],[] #首先将初始遍历的节点放到queue中，表示将要从这个点开始遍历 queue.append(node0) while queue: #从queue中pop出点v，然后从v点开始遍历了，所以可以将这个点pop出，然后将其放入order中 #这里才是最有用的地方，pop（）表示弹出栈顶，由于下面的for循环不断的访问子节点，并将子节点压入堆栈， #也就保证了每次的栈顶弹出的顺序是下面的节点 v = queue.pop() order.append(v) #这里开始遍历v的子节点 for w in self.sequense[v]: #w既不属于queue也不属于order，意味着这个点没被访问过，所以讲起放到queue中，然后后续进行访问 if w not in order and w not in queue: queue.append(w) return order 广度优先搜索(Breadth First Search,BFS) 动态规划 最长公共子序列 参考：https://blog.csdn.net/hrn1216/article/details/51534607 用一个表记录已经解决的子问题的答案，避免大量的重复计算，节约时间。不管该子问题以后是否被用到，只要它被计算过，就将其结果填入表中。这就是动态规划法的基本思路。 背包问题 背包九讲：https://github.com/tianyicui/pack/blob/master/V2.pdf 并查集 并查集（Union-Find）是解决动态连通性问题的一类非常高效的算法。 动态连通性 举例： 1[(4, 3), (3, 8), (6, 5), (9, 4), (2, 1), (8, 9), (5, 0), (7, 2), (6, 1), (6, 7)] 将这些点对依次表达出来，找出互相连通的部分。 步骤 为了找出图的连通性，一个简单的思路就是分组，就是将相互连通的点看成是一个组，如果查询的点不在一个组，那么这个点对就是不连通的。 主要分为“并”和“查”两个步骤： 还是以上述的10个点为例，首先以自身初始化每个点的组别， element 0 1 2 3 4 5 6 7 8 9 group number 0 1 2 3 4 5 6 7 8 9 “并”操作，以点对(4,3)为例。发现所在组别不一样，将点4和点3的组别都变为3（或者都变为4），然后产生如下的表， element 0 1 2 3 4 5 6 7 8 9 group number 0 1 2 3 3 5 6 7 8 9 “查”操作，就是查找点对所在组别是否一致。 并查集适合用树这一数据结构，因为树的根节点可以用来表示这个树所有结点的组别。 用树结构实现并查集的算法思路可以如下描述，假设现在要添加多个路径（点对）： 初始化：每个点看做一棵树，当然这是一棵只有根节点的树，存储了这个节点本身的值作为组别（你也可以令其他不会产生冲突的记号做组别）； 查询：对于点对(a,b)，通过a和b向其根节点回溯（当然初始时就是它们本身），判断其所在组别； 合并：若不在同一组别，令其中一个点（比如a吧）所在树的根节点成为另一个点（比如b）的根节点的孩子。这样即便再查询到a，通过上面的查询过程，程序也会最终判断得到的是现在b的根节点所在的组别，相当于是改变了a所在组的全部元素的组别； 代码 以下是一个并查集结构： 1234567891011121314151617class UnionFind(object): def __init__(self, grid):#初始化 self.n = len(grid) self.parent = [-1] * self.n for idx in range(self.n): self.parent[idx] = idx def find(self, i):#查 if self.parent[i] != i: self.parent[i] = self.find(self.parent[i]) return self.parent[i] def union(self, x, y):#并 rootx = self.find(x) rooty = self.find(y) if rootx != rooty: self.parent[rooty] = rootx Leetcode题目 96.不同的二叉搜索树 状态：不会，重做 题目 给定一个整数 n，求以 1 … n 为节点组成的二叉搜索树有多少种？ 示例: 输入: 3 输出: 5 解释: 给定 n = 3, 一共有 5 种不同结构的二叉搜索树: 123451 1 2 3 3 \ \ / \ / / 3 2 1 3 2 1 / \ / \2 3 1 2 解析 动态规划 以1,2,...,n为节点组成的BST有G[n]种， G[n]=F(1,n)+F(2,n)+...+F(i,n)+...+F(n,n) 其中，F(i,n)表示以i为根节点组成的BST个数， 然而，F(i,n)=G[i-1] * G[n-i] 注意，G[0]=1 以n=3为例，G[3]=F(1,3)+F(2,3)+F(3,3), 123F(1,3)=G[0] * G[2]F(2,3)=G[1] * G[1]F(3,3)=G[2] * G[0] 代码 123456789101112131415161718class Solution(object): def numTrees(self, n): """ :type n: int :rtype: int """ G = [0] * (n+1) G[0] = 1 for i in range(1, n+1): for j in range(i): G[i] += G[j] * G[i-1-j] return G[n]if __name__ == '__main__': a = Solution() print(a.numTrees(n=3)) 413. 等差数列划分 状态：亟待优化 题目 如果一个数列至少有三个元素，并且任意两个相邻元素之差相同，则称该数列为等差数列。 例如，以下数列为等差数列: 1, 3, 5, 7, 9 7, 7, 7, 7 3, -1, -5, -9 以下数列不是等差数列。 1, 1, 2, 5, 7 数组 A 包含 N 个数，且索引从0开始。数组 A 的一个子数组划分为数组 (P, Q)，P 与 Q 是整数且满足 0&lt;=P&lt;Q&lt;N 。 如果满足以下条件，则称子数组(P, Q)为等差数组： 元素 A[P], A[p + 1], …, A[Q - 1], A[Q] 是等差的。并且 P + 1 &lt; Q 。 函数要返回数组 A 中所有为等差数组的子数组个数。 示例: A = [1, 2, 3, 4] 返回: 3, A 中有三个子等差数组: [1, 2, 3], [2, 3, 4] 以及自身 [1, 2, 3, 4]。 version1 过程： 成绩： 解析 审题一定要清楚： 给定的数组A不一定是等差数列，不要让示例先入为止； 等差子数列，题目中明确要求：元素 A[P], A[p + 1], …, A[Q - 1], A[Q] 是等差的。并且 P + 1 &lt; Q 。即表明，子数列是在原数列中不间隔选出的，且至少3个元素。 基于以上分析，先枚举出子数列的所有情形，再判断该子数列是否为等差，但是超时的缘故，在枚举子数列的过程中，若判定该子数列不等差，那么可以包含该子数列的数列肯定也不等差。优化这一判断条件后才勉强通过时间限制。 代码 12345678910111213141516171819202122232425class Solution(object): def numberOfArithmeticSlices(self, A): """ :type A: List[int] :rtype: int """ if len(A) &lt; 3: return 0 else: res = 0 for i in range(len(A)): for j in range(i + 3, len(A) + 1): li = A[i:j] k = li[1] - li[0]#等差 flag = 0 for m in range(1, len(li)): if li[m] == li[m-1] + k: flag += 1 else: break if flag == len(li) - 1: res += 1 else: break return res 标准答案 以A=[1,2,3,4,5,6]为例： 10=1+2+3+4 在枚举子数列时，判断A[i-2],A[i-1],A[i]是否为等差数列，若是则根据前一个循环是否也是等差决定是否叠加。 12345678910111213141516171819class Solution(object): def numberOfArithmeticSlices(self, A): """ :param A: List[int] :return: int """ N = len(A) if N &lt;= 2: return 0 count = 0 streak = 0 for i in range(2, N): if A[i] - A[i-1] == A[i-1] - A[i-2]: streak += 1#以A[i]结尾的等差子数列的个数 count += streak else: streak = 0 return count 120. 三角形最小路径和 状态：排名85%，未考虑空间复杂度 题目 给定一个三角形，找出自顶向下的最小路径和。每一步只能移动到下一行中相邻的结点上。 例如，给定三角形： 123456[ [2], [3,4], [6,5,7], [4,1,8,3]] 自顶向下的最小路径和为 11（即，2 + 3 + 5 + 1 = 11）。 说明： 如果你可以只使用 O(n) 的额外空间（n 为三角形的总行数）来解决这个问题，那么你的算法会很加分。 version1 过程： 成绩： 解析 参考之前矩阵的题目，从最左上角开始，每次只能往下或者往右走，最佳的解题思路就是算出每走一步后的结果，依次迭代。 那么，这里的思路也是一样的，这里的限制条件是只能走相邻的点。 代码 123456789101112131415161718192021class Solution(object): def minimumTotal(self, triangle): """ :type triangle: List[List[int]] :rtype: int """ if len(triangle) == 1: return triangle[0][0] elif len(triangle) == 2: return triangle[0][0] + min(triangle[1]) else: triangle[1][0], triangle[1][1] = triangle[1][0] + triangle[0][0], triangle[1][1] + triangle[0][0] for row in range(2, len(triangle)): for idx in range(row + 1): if idx == 0: triangle[row][idx] += triangle[row - 1][idx] elif idx == row: triangle[row][idx] += triangle[row - 1][idx - 1] else: triangle[row][idx] += min(triangle[row - 1][idx], triangle[row - 1][idx - 1]) return min(triangle[-1]) 标准答案 关键在于空间复杂度： 我的解法是至上而下的，需要修改数组中的每一个元素。现在有一种解法是至下而上，只写存最后一行的内层数组空间，这种解法更节约空间。 代码 12345678910111213class Solution(object): def minimumTotal(self, triangle): """ :type triangle: List[List[int]] :rtype: int """ if not triangle: return res = triangle[-1] for i in range(len(triangle) - 2, -1, -1): for j in range(len(triangle[i])): res[j] = min(res[j], res[j + 1]) + triangle[i][j] return res[0] 62. 不同路径 状态：排名95.86% 题目 一个机器人位于一个 m x n 网格的左上角 （起始点在下图中标记为“Start” ）。 机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为“Finish”）。 问总共有多少条不同的路径？ 例如，上图是一个7 x 3 的网格。有多少可能的路径？ 说明：m 和 n 的值均不超过 100。 示例 1: 1234567输入: m = 3, n = 2输出: 3解释:从左上角开始，总共有 3 条路径可以到达右下角。1. 向右 -&gt; 向右 -&gt; 向下2. 向右 -&gt; 向下 -&gt; 向右3. 向下 -&gt; 向右 -&gt; 向右 示例 2: 12输入: m = 7, n = 3输出: 28 version1 过程： 成绩： 解析 第一次提交失败：未考虑周全矩阵的形式。 思路和之前矩阵求最小路径和以及三角形最小路径和是一样的，计算每个节点的路径可能数，最终答案即为最后一个点的值。 代码 12345678910111213141516171819202122class Solution: def uniquePaths(self, m, n): """ :type m: int :type n: int :rtype: int """ if m == 1 or n == 1: return 1 else: res = [[0 for i in range(n)] for i in range(m)] for i in range(m): for j in range(n): if i == 0 and j == 0: continue elif i == 0: res[i][j] = 1 elif j == 0: res[i][j] = 1 else: res[i][j] = res[i - 1][j] + res[i][j - 1] return res[-1][-1] 712. 两个字符串的最小ASCII删除和 状态：不会做 题目 给定两个字符串s1, s2，找到使两个字符串相等所需删除字符的ASCII值的最小和。 示例 1: 输入: s1 = “sea”, s2 = &quot;eat&quot; 输出: 231 解释: 在 “sea” 中删除 “s” 并将 “s” 的值(115)加入总和。 在 “eat” 中删除 “t” 并将 116 加入总和。 结束时，两个字符串相等，115 + 116 = 231 就是符合条件的最小和。 示例 2: 输入: s1 = “delete”, s2 = &quot;leet&quot; 输出: 403 解释: 在 “delete” 中删除 “dee” 字符串变成 “let”， 将 100[d]+101[e]+101[e] 加入总和。在 “leet” 中删除 “e” 将 101[e] 加入总和。 结束时，两个字符串都等于 “let”，结果即为 100+101+101+101 = 403 。 如果改为将两个字符串转换为 “lee” 或 “eet”，我们会得到 433 或 417 的结果，比答案更大。 注意: 0 &lt; s1.length, s2.length &lt;= 1000。 所有字符串中的字符ASCII值在[97, 122]之间。 最佳答案 这题是经典题目“最长公共子串LCS”的变形题目。 在弄懂LCS之后，这题就很好理解了。 LCS: 1234567891011121314151617181920初始化dp矩阵：----------d---e---l---e---t---e--|___|_0_|_0_|_0_|_0_|_0_|_0_|_0_||_l_|_0_|_0_|_0_|_0_|_0_|_0_|_0_||_e_|_0_|_0_|_0_|_0_|_0_|_0_|_0_||_e_|_0_|_0_|_0_|_0_|_0_|_0_|_0_||_t_|_0_|_0_|_0_|_0_|_0_|_0_|_0_|从s1=&quot;leet&quot;开始遍历对比s2=&quot;delete&quot;，1.如果相同，那么dp[i][j]=dp[i-1][j-1]+1;意味着，如果s1与s2最后一个元素相同，那么LCS（s1,s2）=LCS(s1[:-1],s2[:-1])+s1[-1]2.如果不同，那么dp[i][j]=max(dp[i-1][j],dp[i][j-1])意味着，如果s1与s2最后一个元素不同，那么LCS(s1,s2)=max(LCS(s1[:-1],s2),LCS(s1,s2[:-1]))----------d---e---l---e---t---e--|___|_0_|_0_|_0_|_0_|_0_|_0_|_0_||_l_|_0_|_0_|_0_|_1_|_1_|_1_|_1_||_e_|_0_|_0_|_1_|_1_|_2_|_2_|_2_||_e_|_0_|_0_|_1_|_1_|_2_|_2_|_3_||_t_|_0_|_0_|_1_|_1_|_2_|_3_|_3_| 标准代码 1234567891011121314151617class Solution: def minimumDeleteSum(self, s1, s2): """ :type s1: str :type s2: str :rtype: int """ l1, l2 = len(s1), len(s2) dp = [[0] * (l2 + 1) for _ in range(l1 + 1)] for i in range(l1): for j in range(l2): if s1[i] == s2[j]: dp[i + 1][j + 1] = dp[i][j] + ord(s1[i]) else: dp[i + 1][j + 1] = max(dp[i][j + 1], dp[i + 1][j]) result = sum(map(ord, s1 + s2)) - dp[l1][l2] * 2 return result 647. 回文子串 状态：排名23.26% 题目 给定一个字符串，你的任务是计算这个字符串中有多少个回文子串。 具有不同开始位置或结束位置的子串，即使是由相同的字符组成，也会被计为是不同的子串。 示例 1: 123输入: &quot;abc&quot;输出: 3解释: 三个回文子串: &quot;a&quot;, &quot;b&quot;, &quot;c&quot;. 示例 2: 123输入: &quot;aaa&quot;输出: 6说明: 6个回文子串: &quot;a&quot;, &quot;a&quot;, &quot;a&quot;, &quot;aa&quot;, &quot;aa&quot;, &quot;aaa&quot;. 注意: 输入的字符串长度不会超过1000。 version1 过程： 成绩： 解析 首先一定搞明白回文字符串的意思，回文即正着读反着读都一样。 所以第一次提交失败。 第二次暴力求解，成绩亟待提高。 代码 12345678910111213class Solution: def countSubstrings(self, s): """ :type s: str :rtype: int """ flag = 0 for i in range(len(s)): for j in range(i, len(s)): if s[i:j + 1] == s[i:j + 1][::-1]: flag += 1 return flag 303. 区域和检索 - 数组不可变 状态：排名41.91%，待提高 题目 给定一个整数数组 nums，求出数组从索引 i 到 j (i ≤ j) 范围内元素的总和，包含 i, j 两点。 示例： 1234给定 nums = [-2, 0, 3, -5, 2, -1]，求和函数为 sumRange()sumRange(0, 2) -&gt; 1sumRange(2, 5) -&gt; -1sumRange(0, 5) -&gt; -3 说明: 你可以假设数组不可变。 会多次调用 sumRange 方法。 version1 过程： 成绩： 解析 这题思路很简单。 代码 1234567891011121314151617class NumArray: def __init__(self, nums): """ :type nums: List[int] """ self.nums = nums def sumRange(self, i, j): """ :type i: int :type j: int :rtype: int """ return sum(self.nums[i:j+1])# Your NumArray object will be instantiated and called as such:# obj = NumArray(nums)# param_1 = obj.sumRange(i,j) 标准答案 这题主要是要用动态规划的思想，题目要求的sumRange(i,j)，是可以在遍历数组元素的时候进行叠加求和，一次性求出新的叠加数组。 代码 123456789101112131415161718class NumArray: def __init__(self, nums): """ :type nums: List[int] """ self.nums = nums def sumRange(self, i, j): """ :type i: int :type j: int :rtype: int """ return sum(self.nums[i:j+1])if __name__ == "__main__": a = NumArray(nums=[-2, 0, 3, -5, 2, -1]) print(a.sumRange(0, 5)) 343. 整数拆分 状态： 排名99% 题目 给定一个正整数 n，将其拆分为至少两个正整数的和，并使这些整数的乘积最大化。 返回你可以获得的最大乘积。 示例 1: 输入: 2 输出: 1 解释: 2 = 1 + 1, 1 × 1 = 1。 示例 2: 输入: 10 输出: 36 解释: 10 = 3 + 3 + 4, 3 × 3 × 4 = 36。 说明: 你可以假设 n 不小于 2 且不大于 58。 version1 过程： version2 过程： 成绩： 解析 第二次再写，硬生生地记住了结论，解题关键要尽可能多拆分为3，若剩下1，则要将3和1转换为2和2。 标准答案 这题主要还是没搞懂解题思路，解题的关键是神奇的质数2和质数3。 代码 12345678910111213141516171819from functools import reduceclass Solution: def integerBreak(self, n): """ :type n: int :rtype: int """ if n == 2: return 1 if n == 3: return 2 list_3 = [3] * int((n / 3)) # generate a list of 3 mod_3 = n % 3 if mod_3 == 1: # if a 1 is left, then add it to the first element to get a 4 list_3[0] += 1 if mod_3 == 2: # if a 2 is left, then put it into the list list_3.append(2) return reduce(lambda a, b: a * b, list_3) 638. 大礼包 状态：未通过，有思路但是有难点无法克服 题目 在LeetCode商店中， 有许多在售的物品。 然而，也有一些大礼包，每个大礼包以优惠的价格捆绑销售一组物品。 现给定每个物品的价格，每个大礼包包含物品的清单，以及待购物品清单。请输出确切完成待购清单的最低花费。 每个大礼包的由一个数组中的一组数据描述，最后一个数字代表大礼包的价格，其他数字分别表示内含的其他种类物品的数量。 任意大礼包可无限次购买。 示例 1: 1234567输入: [2,5], [[3,0,5],[1,2,10]], [3,2]输出: 14解释: 有A和B两种物品，价格分别为¥2和¥5。大礼包1，你可以以¥5的价格购买3A和0B。大礼包2， 你可以以¥10的价格购买1A和2B。你需要购买3个A和2个B， 所以你付了¥10购买了1A和2B（大礼包2），以及¥4购买2A。 示例 2: 1234567输入: [2,3,4], [[1,1,0,4],[2,2,1,9]], [1,2,1]输出: 11解释: A，B，C的价格分别为¥2，¥3，¥4.你可以用¥4购买1A和2B，也可以用¥9购买2A，2B和1C。你需要买1A，2B和1C，所以你付了¥4买了1A和1B（大礼包1），以及¥3购买1B， ¥4购买1C。你不可以购买超出待购清单的物品，尽管购买大礼包2更加便宜。 说明: 最多6种物品， 100种大礼包。 每种物品，你最多只需要购买6个。 你不可以购买超出待购清单的物品，即使更便宜。 version1 过程： 本地编译器上未调通，有思路，但是不知道如何解决不同大礼包优惠程度的对比。 标准答案 深度优先搜索，主要就是用大礼包或者原价购买的价格比较，不仅要比较不同大礼包之间的差别，还要比较与原价之间的价格。大礼包的比较肯定要用for循环，然后保存下来方便与后续比较。 代码 1234567891011121314151617181920class Solution: def shoppingOffers(self, price, special, needs): """ :type price: List[int] :type special: List[List[int]] :type needs: List[int] :rtype: int """ d = &#123;&#125; def dfs(cur): val = sum(cur[i] * price[i] for i in range(len(needs))) # cost without special for spec in special: tmp = [cur[j] - spec[j] for j in range(len(needs))] if min(tmp) &gt;= 0: # skip deals that exceed needs val = min(val, d.get(tuple(tmp), dfs(tmp)) + spec[-1]) # .get check the dictionary first for result, otherwise perform dfs. d[tuple(cur)] = val return val return dfs(needs) 312. 戳气球 状态：未通过，思路错误 题目 有 n 个气球，编号为0 到 n-1，每个气球上都标有一个数字，这些数字存在数组 nums 中。 现在要求你戳破所有的气球。 1每当你戳破一个气球 i 时，你可以获得 nums[left] * nums[i] * nums[right] 个硬币。 这里的 left 和 right 代表和 i 相邻的两个气球的序号。 注意当你戳破了气球 i 后，气球 left 和气球 right 就变成了相邻的气球。 求所能获得硬币的最大数量。 说明: 12你可以假设 nums[-1] = nums[n] = 1，但注意它们不是真实存在的所以并不能被戳破。 0 ≤ n ≤ 500, 0 ≤ nums[i] ≤ 100 示例: 1234输入: [3,1,5,8]输出: 167 解释: nums = [3,1,5,8] --&gt; [3,5,8] --&gt; [3,8] --&gt; [8] --&gt; [] coins = 3*1*5 + 3*5*8 + 1*3*8 + 1*8*1 = 167 version1 过程： 整个思考过程就是错误的。忧伤··· 标准答案 代码 1234567891011121314151617181920class Solution(object): def maxCoins(self, nums): """ :type nums: List[int] :rtype: int """ nums = [1] + nums + [1] n = len(nums) dp = [[0] * n for _ in xrange(n)] def calculate(i, j): if dp[i][j] or j == i + 1: # in memory or gap &lt; 2 return dp[i][j] coins = 0 for k in xrange(i+1, j): # find the last balloon coins = max(coins, nums[i] * nums[k] * nums[j] + calculate(i, k) + calculate(k, j)) dp[i][j] = coins return coins return calculate(0, n-1) 740.删除与获得点数 95.不同的二叉搜索树II 121.买卖股票的最佳时机 状态：未通过，超时 题目 给定一个数组，它的第 i 个元素是一支给定股票第 i 天的价格。 如果你最多只允许完成一笔交易（即买入和卖出一支股票），设计一个算法来计算你所能获取的最大利润。 注意你不能在买入股票前卖出股票。 示例 1: 1234输入: [7,1,5,3,6,4]输出: 5解释: 在第 2 天（股票价格 = 1）的时候买入，在第 5 天（股票价格 = 6）的时候卖出，最大利润 = 6-1 = 5 。 注意利润不能是 7-1 = 6, 因为卖出价格需要大于买入价格。 示例 2: 123输入: [7,6,4,3,1]输出: 0解释: 在这种情况下, 没有交易完成, 所以最大利润为 0。 version1 过程： 思路有，就是实现起来不够动态规划。所以会导致很慢，超时不通过。 标准答案 标准答案是只需要一次遍历，求出答案，复杂度是O(N)。而我第一次版本是不止一次遍历的，不仅是明显写出的第一次循环还是隐性的求min,max（其实也是遍历）。 代码 123456789101112class Solution: def maxProfit(self, prices): """ :type prices: List[int] :rtype: int """ max_profit, min_price = 0, float('inf') for price in prices: min_price = min(min_price, price) profit = price - min_price max_profit = max(max_profit, profit) return max_profit 931.下降路径最小和 状态：排名98% 题目 给定一个方形整数数组 A，我们想要得到通过 A 的下降路径的最小和。 下降路径可以从第一行中的任何元素开始，并从每一行中选择一个元素。在下一行选择的元素和当前行所选元素最多相隔一列。 示例： 123456789输入：[[1,2,3],[4,5,6],[7,8,9]]输出：12解释：可能的下降路径有：[1,4,7], [1,4,8], [1,5,7], [1,5,8], [1,5,9][2,4,7], [2,4,8], [2,5,7], [2,5,8], [2,5,9], [2,6,8], [2,6,9][3,5,7], [3,5,8], [3,5,9], [3,6,8], [3,6,9]和最小的下降路径是 [1,4,7]，所以答案是 12。 提示： 121 &lt;= A.length == A[0].length &lt;= 100-100 &lt;= A[i][j] &lt;= 100 version1 过程： 成绩： 这种类型的题目已经掌握了，笔试是不会怕了。 相似题目有120，62。 代码 12345678910111213141516171819202122class Solution: def minFallingPathSum(self, A): """ :type A: List[List[int]] :rtype: int """ if len(A) == 1: return sum(A[0]) if len(A[0]) == 1: res = 0 for row in range(len(A)): res += A[row][0] return res for i in range(1, len(A)): for j in range(len(A[0])): if j == 0: A[i][j] += min(A[i-1][j], A[i-1][j+1]) elif j == len(A[0])-1: A[i][j] += min(A[i-1][j], A[i-1][j-1]) else: A[i][j] += min(A[i-1][j], A[i-1][j-1], A[i-1][j+1]) return min(A[-1]) 70.爬楼梯 状态：未通过 题目 假设你正在爬楼梯。需要 n 阶你才能到达楼顶。 每次你可以爬 1 或 2 个台阶。你有多少种不同的方法可以爬到楼顶呢？ 注意：给定 n 是一个正整数。 示例 1： 12345输入： 2输出： 2解释： 有两种方法可以爬到楼顶。1. 1 阶 + 1 阶2. 2 阶 示例 2： 123456输入： 3输出： 3解释： 有三种方法可以爬到楼顶。1. 1 阶 + 1 阶 + 1 阶2. 1 阶 + 2 阶3. 2 阶 + 1 阶 标准答案 爬楼梯是一道经典的动态规划类型题目。 这道题目是逆推。比如，要想爬10级楼梯，可以1次爬1级，也可以1次爬2级。如果现在考虑，只剩最后一步，那么有可能是最后一步爬1级，也有可能是最后一步爬2级。如果最后一步爬1级，那么问题转换为爬9级台阶的方式，同理可知，如果最后一步爬2级，就等价于秋节爬8级台阶的方法。 数学表达式： F(10)=F(9)+F(8) F(9)=F(8)+F(7) … 代码 123456789101112class Solution: def climbStairs(self, n): """ :type n: int :rtype: int """ if n == 1: return 1 elif n == 2: return 2 else: return self.climbStairs(n-1) + self.climbStairs(n-2) 152. 乘积最大子序列 状态：未通过 题目 给定一个整数数组 nums ，找出一个序列中乘积最大的连续子序列（该序列至少包含一个数）。 示例 1: 123输入: [2,3,-2,4]输出: 6解释: 子数组 [2,3] 有最大乘积 6。 示例 2: 123输入: [-2,0,-1]输出: 0解释: 结果不能为 2, 因为 [-2,-1] 不是子数组。 标准答案 动态规划的题目做多了，直觉告诉我这题应该一次遍历即可得到答案。 连续子序列的最大值可能因为符号的变化，最大值瞬间变为最小值，最小值瞬间变为最大值，故这题的关键是记录当前遍历状态下的最大值与最小值。 代码 1234567891011class Solution: def maxProduct(self, nums): """ :type nums: List[int] :rtype: int """ maximum = big = small = nums[0] for n in nums[1:]: big, small = max(n, n * big, n * small), min(n, n * big, n * small) maximum = max(maximum, big) return maximum 122. 买卖股票的最佳时机 II 状态：未通过 题目 给定一个数组，它的第 i 个元素是一支给定股票第 i 天的价格。 设计一个算法来计算你所能获取的最大利润。你可以尽可能地完成更多的交易（多次买卖一支股票）。 注意：你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。 示例 1: 1234输入: [7,1,5,3,6,4]输出: 7解释: 在第 2 天（股票价格 = 1）的时候买入，在第 3 天（股票价格 = 5）的时候卖出, 这笔交易所能获得利润 = 5-1 = 4 。 随后，在第 4 天（股票价格 = 3）的时候买入，在第 5 天（股票价格 = 6）的时候卖出, 这笔交易所能获得利润 = 6-3 = 3 。 示例 2: 12345输入: [1,2,3,4,5]输出: 4解释: 在第 1 天（股票价格 = 1）的时候买入，在第 5 天 （股票价格 = 5）的时候卖出, 这笔交易所能获得利润 = 5-1 = 4 。 注意你不能在第 1 天和第 2 天接连购买股票，之后再将它们卖出。 因为这样属于同时参与了多笔交易，你必须在再次购买前出售掉之前的股票。 示例 3: 123输入: [7,6,4,3,1]输出: 0解释: 在这种情况下, 没有交易完成, 所以最大利润为 0。 标准答案 这题的题目背景与121.买卖股票的最佳时机非常相似。但是不要搞混淆，题目给出的条件一点点的差异也可能导致解法大大不同。这题没有不允许同一天操作买入与卖出的交易行为，而121题则明确提出不可以。 代码 1234567891011class Solution: def maxProfit(self, prices): """ :type prices: List[int] :rtype: int """ res = [] for i in range(len(prices)-1): if prices[i+1] &gt; prices[i]: res.append(prices[i+1]-prices[i]) return sum(res) 200. 岛屿的个数 状态：未通过 题目 给定一个由’1’（陆地）和 ‘0’（水）组成的的二维网格，计算岛屿的数量。 一个岛被水包围，并且它是通过水平方向或垂直方向上相邻的陆地连接而成的。 你可以假设网格的四个边均被水包围。 示例 1: 123456输入:11110110101100000000输出: 1 示例 2: 123456输入:11000110000010000011输出: 3 标准答案 方法一： 深度优先搜索，在每次遍历中尽可能深入地迭代遍历。 在目标函数中调用自建的dfs函数，dfs函数中递归调用dfs函数本身。 方法二： 并查集，利用树形结构，记录每个连通块的情况，而连通块的个数则代表岛屿的个数。 DFS代码 12345678910111213141516171819202122232425class Solution: def numIslands(self, grid): """ :type grid: List[List[str]] :rtype: int """ if not grid: return 0 count = 0 for i in range(len(grid)): for j in range(len(grid[0])): if grid[i][j] == '1': self.dfs(grid, i, j) count += 1 return count def dfs(self, grid, i, j): if i &lt; 0 or j &lt; 0 or i &gt;= len(grid) or j &gt;= len(grid[0]) or grid[i][j] != '1': return grid[i][j] = '#'#确保已经遍历过的陆地不会再走一遍，不然会一直死循环 self.dfs(grid, i + 1, j) self.dfs(grid, i - 1, j) self.dfs(grid, i, j + 1) self.dfs(grid, i, j - 1) 并查集 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657class UnionFind(object): def __init__(self, grid): m, n = len(grid), len(grid[0]) self.count = 0#记录岛屿的数量，节省一次遍历 self.parent = [-1] * (m*n) for i in range(m): for j in range(n): if grid[i][j] == '1': self.parent[i*n + j] = i*n + j self.count += 1 def find(self, i): if self.parent[i] != i: self.parent[i] = self.find(self.parent[i]) return self.parent[i] def union(self, x, y): rootx = self.find(x) rooty = self.find(y) if rootx != rooty: self.parent[rooty] = rootx self.count -= 1class Solution(object): def is_valid(self, grid, r, c): m, n = len(grid), len(grid[0]) if r &lt; 0 or c &lt; 0 or r &gt;= m or c &gt;= n: return False return True def numIslands(self, grid): """ :type grid: List[List[str]] :rtype: int """ if not grid or not grid[0]: return 0 uf = UnionFind(grid) directions = [(0,1), (0,-1), (-1,0), (1,0)] m, n = len(grid), len(grid[0]) for i in range(m): for j in range(n): if grid[i][j] == '1': for d in directions: nr, nc = i + d[0], j + d[1] if self.is_valid(grid, nr, nc) and grid[nr][nc] == '1': uf.union(i*n+j, nr*n+nc) return uf.countif __name__ == "__main__": a = Solution() print(a.numIslands(grid=[['1','1','1','1','0'], ['1','1','0','1','0'], ['1','1','0','0','0'], ['0','0','0','0','0']])) 695. 岛屿的最大面积 状态：排名53.56% 题目 给定一个包含了一些 0 和 1的非空二维数组 grid , 一个 岛屿 是由四个方向 (水平或垂直) 的 1 (代表土地) 构成的组合。你可以假设二维矩阵的四个边缘都被水包围着。 找到给定的二维数组中最大的岛屿面积。(如果没有岛屿，则返回面积为0。) 示例 1: 123456789[[0,0,1,0,0,0,0,1,0,0,0,0,0], [0,0,0,0,0,0,0,1,1,1,0,0,0], [0,1,1,0,1,0,0,0,0,0,0,0,0], [0,1,0,0,1,1,0,0,1,0,1,0,0], [0,1,0,0,1,1,0,0,1,1,1,0,0], [0,0,0,0,0,0,0,0,0,0,1,0,0], [0,0,0,0,0,0,0,1,1,1,0,0,0], [0,0,0,0,0,0,0,1,1,0,0,0,0]]对于上面这个给定矩阵应返回 6。注意答案不应该是11，因为岛屿只能包含水平或垂直的四个方向的‘1’。 示例 2: 123[[0,0,0,0,0,0,0,0]]对于上面这个给定的矩阵, 返回 0。注意: 给定的矩阵grid 的长度和宽度都不超过 50。 version1 过程： 成绩： 与200. 岛屿的个数类似，采用深度优先搜索的思想，200那题是计算岛屿的个数，这题计算岛屿的大小，大同小异。 代码 123456789101112131415161718192021222324252627282930313233class Solution: def maxAreaOfIsland(self, grid): """ :type grid: List[List[int]] :rtype: int """ res = [0] for i in range(len(grid)): for j in range(len(grid[0])): area = 0 tmp = self.dfs(grid, i, j, area) if tmp: res.append(tmp) return max(res) def dfs(self, grid, i, j, area): if i &lt; 0 or j &lt; 0 or i &gt;= len(grid) or j &gt;= len(grid[0]) or grid[i][j] != 1: return grid[i][j] = '#' area = 1 down = self.dfs(grid, i + 1, j, area) if down: area += down up = self.dfs(grid, i-1, j, area) if up: area += up right = self.dfs(grid, i, j+1, area) if right: area += right left = self.dfs(grid, i, j-1, area) if left: area += left return area 300. 最长上升子序列 状态：不会 题目 给定一个无序的整数数组，找到其中最长上升子序列的长度。 示例: 123输入: [10,9,2,5,3,7,101,9,18]输出: 4 解释: 最长的上升子序列是 [2,3,7,101]，它的长度是 4。 说明: 可能会有多种最长上升子序列的组合，你只需要输出对应的长度即可。 你算法的时间复杂度应该为 O(n2) 。 进阶: 你能将算法的时间复杂度降低到 O(n log n) 吗? 标准答案 动态规划，设置两个指针i,j以及一个长度与给定数组相同的数组T，核心公式：T[i]=max(T[i],T[j]+1)。 具体讲解见Youtube：https://www.youtube.com/watch?v=CE2b_-XfVDk 代码 123456789101112131415161718192021222324class Solution: def lengthOfLIS(self, nums): """ :type nums: List[int] :rtype: int """ res = [] for i in range(len(nums)): tmp = self.find_bigger(cur=nums[i], rest=nums[i+1:]) if tmp!= None: res.append(tmp+1) return max(res) def find_bigger(self, cur, rest): for i in range(len(rest)): if rest[i] &gt; cur: tmpp = self.find_bigger(rest[i], rest[i+1:]) if tmpp != None: return tmpp+1 elif i == len(rest)-1: return 0if __name__ == "__main__": a = Solution() print(a.lengthOfLIS(nums=[10,9,2,5,3,7,101,9,18])) 416. 分割等和子集 状态：不会 题目 给定一个只包含正整数的非空数组。是否可以将这个数组分割成两个子集，使得两个子集的元素和相等。 注意: 每个数组中的元素不会超过 100 数组的大小不会超过 200 示例 1: 123输入: [1, 5, 11, 5]输出: true解释: 数组可以分割成 [1, 5, 5] 和 [11]. 示例 2: 123输入: [1, 2, 3, 5]输出: false解释: 数组不能分割成两个元素和相等的子集. 标准答案 0/1背包问题，详细讲解见： https://www.youtube.com/watch?v=8LusJS5-AGo 这题背包的重量为sum/2,比背包问题简单，没有价值信息，更不用求价值最大值。 代码 12345678910111213141516171819202122232425class Solution: def canPartition(self, nums): """ :type nums: List[int] :rtype: bool """ total = sum(nums) if total % 2 == 1: return False else: total = int(total / 2) dp = [[0 for i in range(total + 1)] for j in range(len(nums))] for i in range(nums[0], total + 1): dp[0][i] = nums[0] for i in range(1, len(nums)): for j in range(nums[i], total + 1): dp[i][j] = max(dp[i - 1][j], dp[i - 1][j - nums[i]] + nums[i]) if dp[len(nums) - 1][total] != total: return False else: return Trueif __name__ == "__main__": a = Solution() print(a.canPartition(nums=[1,2,3,4,5,6,7])) 322. 零钱兑换 状态：不会 题目 给定不同面额的硬币 coins 和一个总金额 amount。 编写一个函数来计算可以凑成总金额所需的最少的硬币个数。 如果没有任何一种硬币组合能组成总金额，返回 -1。 示例 1: 123输入: coins = [1, 2, 5], amount = 11输出: 3 解释: 11 = 5 + 5 + 1 示例 2: 12输入: coins = [2], amount = 3输出: -1 说明: 你可以认为每种硬币的数量是无限的。 标准答案 经典0/1背包问题的变种类型——完全背包，与01背包不同在于每种物品可以不止使用一次，物品个数是无限的。 解题关键在于当未计算或者使用该硬币，硬币总数量下降的就更新dp[i]。 代码 12345678910111213141516171819class Solution: def coinChange(self, coins, amount): """ :type coins: List[int] :type amount: int :rtype: int """ dp = [-1] * (amount + 1) dp[0] = 0 for i in range(1, amount + 1): for j in range(0, len(coins)): if i &gt;= coins[j] and dp[i - coins[j]] != -1: if dp[i] == -1 or dp[i] &gt; dp[i - coins[j]] + 1: dp[i] = dp[i - coins[j]] + 1 return dp[amount] if __name__ == "__main__": a = Solution() print(a.coinChange(coins = [1, 2, 5], amount = 11)) 377. 组合总和 Ⅳ 状态：不会 题目 给定一个由正整数组成且不存在重复数字的数组，找出和为给定目标正整数的组合的个数。 示例: 1234567891011nums = [1, 2, 3]target = 4所有可能的组合为：(1, 1, 1, 1)(1, 1, 2)(1, 2, 1)(1, 3)(2, 1, 1)(2, 2)(3, 1) 请注意，顺序不同的序列被视作不同的组合。 因此输出为 7。 标准答案 经典0/1背包问题的变种类型——完全背包，与Leetcode322相似，都是物品可以无限次使用，但是dp数组里记录的是不同组合个数。 代码 123456789101112131415161718class Solution: def combinationSum4(self, nums, target): """ :type nums: List[int] :type target: int :rtype: int """ dp = [0] * (target + 1) dp[0] = 1 # if num == target for i in range(1, target + 1): for num in nums: if i &gt;= num: dp[i] += dp[i - num] return dp[target]if __name__ == "__main__": a = Solution() print(a.combinationSum4(nums = [1, 2, 3], target = 4)) 474. 一和零 状态：不会 题目 在计算机界中，我们总是追求用有限的资源获取最大的收益。 现在，假设你分别支配着 m 个 0 和 n 个 1。另外，还有一个仅包含 0 和 1 字符串的数组。 你的任务是使用给定的 m 个 0 和 n 个 1 ，找到能拼出存在于数组中的字符串的最大数量。每个 0 和 1 至多被使用一次。 注意: 给定 0 和 1 的数量都不会超过 100。 给定字符串数组的长度不会超过 600。 示例 1: 输入: Array = {“10”, “0001”, “111001”, “1”, “0”}, m = 5, n = 3 输出: 4 解释: 总共 4 个字符串可以通过 5 个 0 和 3 个 1 拼出，即 “10”,“0001”,“1”,“0” 。 示例 2: 输入: Array = {“10”, “0”, “1”}, m = 1, n = 1 输出: 2 解释: 你可以拼出 “10”，但之后就没有剩余数字了。更好的选择是拼出 “0” 和 “1” 。 标准答案 经典0/1背包问题的变种类型——多维背包问题，不仅考虑物品的重量，而是要衡量物品的重量和体积，并且这里求的不是背包的最大价值，而是可能性中包含的最大字符串个数。 代码 12345678910111213141516171819202122class Solution: def findMaxForm(self, strs, m, n): """ :type strs: List[str] :type m: int :type n: int :rtype: int """ dp = [[0] * (n + 1) for _ in range(m + 1)] for item in strs: z = item.count('0') o = item.count('1') for x in range(m, -1, -1): for y in range(n, -1, -1): if x &gt;= z and y &gt;= o: dp[x][y] = max(1 + dp[x - z][y - o], dp[x][y]) return dp[m][n]if __name__ == "__main__": a = Solution() print(a.findMaxForm(strs=["10", "0001", "111001", "1", "0"], m = 5, n = 3)) 139. 单词拆分 状态：不会 题目 给定一个非空字符串 s 和一个包含非空单词列表的字典 wordDict，判定 s 是否可以被空格拆分为一个或多个在字典中出现的单词。 说明： 拆分时可以重复使用字典中的单词。 你可以假设字典中没有重复的单词。 示例 1： 123输入: s = &quot;leetcode&quot;, wordDict = [&quot;leet&quot;, &quot;code&quot;]输出: true解释: 返回 true 因为 &quot;leetcode&quot; 可以被拆分成 &quot;leet code&quot;。 示例 2： 1234输入: s = &quot;applepenapple&quot;, wordDict = [&quot;apple&quot;, &quot;pen&quot;]输出: true解释: 返回 true 因为 &quot;applepenapple&quot; 可以被拆分成 &quot;apple pen apple&quot;。 注意你可以重复使用字典中的单词。 示例 3： 12输入: s = &quot;catsandog&quot;, wordDict = [&quot;cats&quot;, &quot;dog&quot;, &quot;sand&quot;, &quot;and&quot;, &quot;cat&quot;]输出: false 标准答案 属于完全背包问题,考察的标准不再是体重，价值之类的数值型标准了，而是字符串。dp数组记录当前位置i是否可分。 代码 12345678910111213141516171819class Solution: def wordBreak(self, s, wordDict): """ :type s: str :type wordDict: List[str] :rtype: bool """ dp = [False] * (len(s) + 1) # dp[i] means s[:i+1] can be segmented into words in the wordDicts dp[0] = True for i in range(len(s)): for j in range(i+1, len(s)): if dp[i] and s[i: j] in wordDict: dp[j] = True return dp[-1]if __name__ == "__main__": a = Solution() print(a.wordBreak(s="catsandog", wordDict=["cats", "dog", "sand", "and", "cat"])) 494. 目标和 状态：不会 题目 给定一个非负整数数组，a1, a2, …, an, 和一个目标数，S。现在你有两个符号 + 和 -。 对于数组中的任意一个整数，你都可以从 + 或 -中选择一个符号添加在前面。 返回可以使最终数组和为目标数 S 的所有添加符号的方法数。 示例 1: 12345678910输入: nums: [1, 1, 1, 1, 1], S: 3输出: 5解释: -1+1+1+1+1 = 3+1-1+1+1+1 = 3+1+1-1+1+1 = 3+1+1+1-1+1 = 3+1+1+1+1-1 = 3一共有5种方法让最终目标和为3。 注意: 数组的长度不会超过20，并且数组中的值全为正数。 初始的数组的和不会超过1000。 保证返回的最终结果为32位整数。 标准答案 这题要根据公式推导转换为背包问题 在nums中，有部分正数和负数。p表示所有正数的集合，q表示所有负数的集合，那么有sum§ - sum(q) = S， sum§ + sum(q) = sum(all) 以上两个公式转换可得： sum§ = (sum(all) + S)/2 那么，这个问题转换为单纯的背包价值问题。选择将不同价值的物品放入背包与否。 代码 12345678910111213141516171819202122class Solution: def findTargetSumWays(self, nums, S): """ :type nums: List[int] :type S: int :rtype: int """ s = sum(nums) N = s + S if N % 2 or S &gt; s: return 0 N = N // 2 dp = [0 for _ in range(N + 1)] dp[0] = 1 for num in nums: for i in range(N, num - 1, -1): dp[i] += dp[i - num] return dp[-1]if __name__ == "__main__": a = Solution() print(a.findTargetSumWays(nums=[1, 1, 1, 1, 1], S=3)) 547. 朋友圈 状态：不会 题目 班上有 N 名学生。其中有些人是朋友，有些则不是。他们的友谊具有是传递性。 如果已知 A 是 B 的朋友，B 是 C 的朋友，那么我们可以认为 A 也是 C 的朋友。 所谓的朋友圈，是指所有朋友的集合。 给定一个 N * N 的矩阵 M，表示班级中学生之间的朋友关系。 如果M[i][j] = 1，表示已知第 i 个和 j 个学生互为朋友关系，否则为不知道。 你必须输出所有学生中的已知的朋友圈总数。 示例 1: 1234567输入: [[1,1,0], [1,1,0], [0,0,1]]输出: 2 说明：已知学生0和学生1互为朋友，他们在一个朋友圈。第2个学生自己在一个朋友圈。所以返回2。 示例 2: 123456输入: [[1,1,0], [1,1,1], [0,1,1]]输出: 1说明：已知学生0和学生1互为朋友，学生1和学生2互为朋友，所以学生0和学生2也是朋友，所以他们三个在一个朋友圈，返回1。 标准答案 这题有两种解题思路，一个是DFS，另一个是并查集。 DFS： 依次遍历每个人，查看当前这个人所有的关系网，如果这个人有新朋友，添加到已查看集合中去，并再次查看这个新朋友的关系网，依次循环往复。 DFS代码 12345678910111213141516171819202122232425class Solution: def findCircleNum(self, M): """ :type M: List[List[int]] :rtype: int """ N = len(M) seen = set() def dfs(node): for nei, adj in enumerate(M[node]): if adj and nei not in seen: seen.add(nei) dfs(nei) ans = 0 for i in range(N): if i not in seen: dfs(i) ans += 1 return ansif __name__ == "__main__": a = Solution() print(a.findCircleNum(M=[[1,1,0], [1,1,0], [0,0,1]])) 并查集代码 1234567891011121314151617181920212223242526272829303132333435363738394041424344class UnionFind(object): def __init__(self, grid): self.n = len(grid) self.parent = [-1] * self.n for idx in range(self.n): self.parent[idx] = idx def find(self, i): if self.parent[i] != i: self.parent[i] = self.find(self.parent[i]) return self.parent[i] def union(self, x, y): rootx = self.find(x) rooty = self.find(y) if rootx != rooty: self.parent[rooty] = rootx def diff_groups(self): diff_groups = set() for i in range(self.n): diff_groups.add(self.find(i)) return len(diff_groups)class Solution(object): def findCircleNum(self, M): &quot;&quot;&quot; :type M: List[List[int]] :rtype: int &quot;&quot;&quot; n = len(M) uf = UnionFind(M) for i in range(n): for j in range(n): if M[i][j] == 1: uf.union(i, j) return uf.diff_groups()if __name__ == &quot;__main__&quot;: a = Solution() M = [[1, 1, 0], [1, 1, 0], [0, 0, 1]] print(a.findCircleNum(M=M)) 128. 最长连续序列 状态：第二遍通过11.11% 题目 给定一个未排序的整数数组，找出最长连续序列的长度。 要求算法的时间复杂度为 O(n)。 示例: 123输入: [100, 4, 200, 1, 3, 2]输出: 4解释: 最长连续序列是 [1, 2, 3, 4]。它的长度为 4。 version2 过程： 成绩： 代码 12345678910111213141516171819202122232425262728class Solution: def longestConsecutive(self, nums): """ :type nums: List[int] :rtype: int """ if nums == []: return 0 nums=sorted(list(set(nums))) res = [] for i in range(len(nums)): tmp = nums[:i+1] if res: tmp_res = res[-1] else: tmp_res = 1 if len(tmp) == 1: tmp_res = 1 res.append(tmp_res) elif res[-1] &gt;= 1: if tmp[-1] == tmp[-2]+1: tmp_res += 1 res[-1] = tmp_res elif tmp[-1] == tmp[-2]: continue else: res.append(1) return max(res) 标准答案 首先对数组去重即集合，遍历集合中的每个元素，并弹出该元素，找出比这个元素小1或者大1的元素，并分别更新连续值标记。 标准代码 123456789101112131415161718192021222324class Solution: def longestConsecutive(self, nums): """ :type nums: List[int] :rtype: int """ num = set(nums) maxLen = 0 while num: n = num.pop() i = n + 1 l1 = 0 l2 = 0 while i in num: num.remove(i) i += 1 l1 += 1 i = n - 1 while i in num: num.remove(i) i -= 1 l2 += 1 maxLen = max(maxLen, l1 + l2 + 1) return maxLen 130. 被围绕的区域 状态：不会 题目 给定一个二维的矩阵，包含 ‘X’ 和 ‘O’（字母 O）。 找到所有被 ‘X’ 围绕的区域，并将这些区域里所有的 ‘O’ 用 ‘X’ 填充。 示例: 1234X X X XX O O XX X O XX O X X 运行你的函数后，矩阵变为： 1234X X X XX X X XX X X XX O X X 解释: 被围绕的区间不会存在于边界上，换句话说，任何边界上的 ‘O’ 都不会被填充为 ‘X’。 任何不在边界上，或不与边界上的 ‘O’ 相连的 ‘O’ 最终都会被填充为 ‘X’。 如果两个元素在水平或垂直方向相邻，则称它们是“相连”的。 标准答案 这一题与200. 岛屿的个数以及695. 岛屿的最大面积背景类似，解题关键在于找到边界，题目中的关键信息是把除边界以外的‘O’改成‘X’，那么就应该找到边界‘O’，不仅是四周的‘O’，还包括与边界‘O’相连的‘O’，这里就用到了深度优先搜索。 标准代码 1234567891011121314151617181920212223242526272829303132 class Solution: def solve(self, board): """ :type board: List[List[str]] :rtype: void Do not return anything, modify board in-place instead. """ alive, v = set(), set() for r in range(len(board)): for c in range(len(board[r])): if r == 0 or r == len(board) - 1 or c == 0 or c == len(board[0]) - 1: self.traverse(board, r, c, alive) for r in range(len(board)): for c in range(len(board[r])): if board[r][c] == 'O' and (r, c) not in alive: board[r][c] = 'X' for i in board: print(i) def traverse(self, board, r, c, alive): if (r, c) in alive or r &lt; 0 or r &gt; len(board) - 1 or c &lt; 0 or c &gt; len(board[0]) - 1 or board[r][c] != 'O': return else: alive.add((r, c)) self.traverse(board, r + 1, c, alive) self.traverse(board, r, c + 1, alive) self.traverse(board, r - 1, c, alive) self.traverse(board, r, c - 1, alive)if __name__ == "__main__": a = Solution() a.solve(board=[['X', 'X', 'X', 'X'], ['X', 'O', 'O', 'X'], ['X', 'X', 'O', 'X'], ['X', 'O', 'X', 'X']]) 3. 无重复字符的最长子串 状态：不会 题目 给定一个字符串，请你找出其中不含有重复字符的 最长子串 的长度。 示例 1: 123输入: &quot;abcabcbb&quot;输出: 3 解释: 因为无重复字符的最长子串是 &quot;abc&quot;，所以其长度为 3。 示例 2: 123输入: &quot;bbbbb&quot;输出: 1解释: 因为无重复字符的最长子串是 &quot;b&quot;，所以其长度为 1。 示例 3: 1234输入: &quot;pwwkew&quot;输出: 3解释: 因为无重复字符的最长子串是 &quot;wke&quot;，所以其长度为 3。 请注意，你的答案必须是 子串 的长度，&quot;pwke&quot; 是一个子序列，不是子串。 标准答案 题目要求找到最大的不重复子串，运用双指针方法，详细解释见 https://zhuanlan.zhihu.com/p/36074066 代码 12345678910111213141516171819class Solution: def lengthOfLongestSubstring(self, s): """ :type s: str :rtype: int """ dict = &#123;&#125; begin, res = -1, 0 for end in range(len(s)): if s[end] in dict and begin &lt; dict[s[end]]: begin = dict[s[end]] else: res = max(res, end-begin)#end-begin记录目前不重复子串的长度，res是目前最大不重复子串的长度 dict[s[end]] = end return resif __name__ == "__main__": a = Solution() print(a.lengthOfLongestSubstring(s="pwwkew")) 684. 冗余连接 状态：不会 题目 在本问题中, 树指的是一个连通且无环的无向图。 输入一个图，该图由一个有着N个节点 (节点值不重复1, 2, …, N) 的树及一条附加的边构成。 附加的边的两个顶点包含在1到N中间，这条附加的边不属于树中已存在的边。 结果图是一个以边组成的二维数组。每一个边的元素是一对[u, v] ，满足 u &lt; v，表示连接顶点u 和v的无向图的边。 返回一条可以删去的边，使得结果图是一个有着N个节点的树。如果有多个答案，则返回二维数组中最后出现的边。 答案边[u, v] 应满足相同的格式 u &lt; v。 示例 1： 123456输入: [[1,2], [1,3], [2,3]]输出: [2,3]解释: 给定的无向图为: 1 / \2 - 3 示例 2： 123456输入: [[1,2], [2,3], [3,4], [1,4], [1,5]]输出: [1,4]解释: 给定的无向图为:5 - 1 - 2 | | 4 - 3 注意: 输入的二维数组大小在 3 到 1000。 二维数组中的整数在1到N之间，其中N是输入数组的大小。 标准答案 题目看着就很烦，他想表达的意思是找出使得图连通的最后一条边，删去这个边，输入的图就不再连通了，这一题参考博客 http://wulc.me/2017/10/12/LeetCode 解题报告(684,685,721)-并查集介绍及应用/ 可以更好地理解并查集这种数据结构，并提到了路径压缩和按等级合并，这两个步骤可以降低算法的时间复杂度。 代码 1234567891011121314151617181920212223242526272829303132333435363738394041class UnionFindSet(object): def __init__(self): self.parents = list(range(1001)) self.rank = [0] * 1001 def find(self, val): """find with path compression""" if self.parents[val] != val: self.parents[val] = self.find(self.parents[val]) return self.parents[val] def union(self, v1, v2): """union by rank, check whether union two vertics will lead to a cycle""" p1, p2 = self.find(v1), self.find(v2) if p1 == p2: return True elif self.rank[p1] &gt; self.rank[p2]: self.parents[p2] = p1 elif self.rank[p1] &lt; self.rank[p2]: self.parents[p1] = p2 else: self.rank[p2] += 1 self.parents[p1] = p2 return Falseclass Solution(object): def findRedundantConnection(self, edges): """ :type edges: List[List[int]] :rtype: List[int] """ ufs = UnionFindSet() for edge in edges: if ufs.union(edge[0], edge[1]): return edgeif __name__ == "__main__": a = Solution() print(a.findRedundantConnection(edges=[[1,2], [2,3], [3,4], [1,4], [1,5]])) 685. 冗余连接 II 状态：不会 题目 在本问题中，有根树指满足以下条件的有向图。 该树只有一个根节点，所有其他节点都是该根节点的后继。 每一个节点只有一个父节点，除了根节点没有父节点。 输入一个有向图，该图由一个有着N个节点 (节点值不重复1, 2, …, N) 的树及一条附加的边构成。 附加的边的两个顶点包含在1到N中间，这条附加的边不属于树中已存在的边。 结果图是一个以边组成的二维数组。 每一个边的元素是一对[u, v]，用以表示有向图中连接顶点 u and v和顶点的边，其中父节点u是子节点v的一个父节点。 返回一条能删除的边，使得剩下的图是有N个节点的有根树。若有多个答案，返回最后出现在给定二维数组的答案。 示例 1: 1234567输入: [[1,2], [1,3], [2,3]]输出: [2,3]解释: 给定的有向图如下: 1 / \v v2 --&gt;3 示例 2: 1234567输入: [[1,2], [2,3], [3,4], [4,1], [1,5]]输出: [4,1]解释: 给定的有向图如下:5 &lt;- 1 -&gt; 2 ^ | | v 4 &lt;- 3 注意: 二维数组大小的在3到1000范围内。 二维数组中的每个整数在1到N之间，其中 N 是二维数组的大小。 标准答案 这一题与Leetcode 684相似，不过难度升级，从无向图变为有向图，要返回的边使得删除这条边之后输入的有向图变为一颗合格树。 而 合格树要求每个节点只有一个父节点，根据这个要求可以先筛选一遍，看图中是否存在多个父节点的点，那么要删除的边就在里面。 参考博客： http://wulc.me/2017/10/12/LeetCode 解题报告(684,685,721)-并查集介绍及应用/ 代码 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859class UnionFindSet(object): def __init__(self): self.parents = list(range(1001)) self.rank = [0] * 1001 def find(self, val): """find with path compression""" if self.parents[val] != val: self.parents[val] = self.find(self.parents[val]) return self.parents[val] def union(self, v1, v2): """union by rank, check whether union two vertics will lead to a cycle""" p1, p2 = self.find(v1), self.find(v2) if p1 == p2: return True elif self.rank[p1] &gt; self.rank[p2]: self.parents[p2] = p1 elif self.rank[p1] &lt; self.rank[p2]: self.parents[p1] = p2 else: self.rank[p2] += 1 self.parents[p1] = p2 return Falseclass Solution(object): def findRedundantDirectedConnection(self, edges): """ :type edges: List[List[int]] :rtype: List[int] """ redundant_edges = None count = &#123;&#125; for e in edges: if e[1] not in count: count[e[1]] = [] count[e[1]].append(e) if len(count[e[1]]) == 2: redundant_edges = count[e[1]] break if redundant_edges: ufs = UnionFindSet() for edge in edges: if edge == redundant_edges[1]: continue if ufs.union(edge[0], edge[1]): return redundant_edges[0] return redundant_edges[1] else: ufs = UnionFindSet() for edge in edges: if ufs.union(edge[0], edge[1]): return edgeif __name__ == "__main__": a = Solution() print(a.findRedundantDirectedConnection(edges=[[1,2], [1,3], [2,3]])) 721. 账户合并 状态：不会 题目 给定一个列表 accounts，每个元素 accounts[i] 是一个字符串列表， 其中第一个元素 accounts[i][0] 是 名称 (name)，其余元素是 emails 表示该帐户的邮箱地址。 现在，我们想合并这些帐户。如果两个帐户都有一些共同的邮件地址，则两个帐户必定属于同一个人。 请注意，即使两个帐户具有相同的名称，它们也可能属于不同的人，因为人们可能具有相同的名称。 一个人最初可以拥有任意数量的帐户，但其所有帐户都具有相同的名称。 合并帐户后，按以下格式返回帐户： 每个帐户的第一个元素是名称，其余元素是按顺序排列的邮箱地址。accounts 本身可以以任意顺序返回。 例子 1: 12345678910Input: accounts = [[&quot;John&quot;, &quot;johnsmith@mail.com&quot;, &quot;john00@mail.com&quot;], [&quot;John&quot;, &quot;johnnybravo@mail.com&quot;], [&quot;John&quot;, &quot;johnsmith@mail.com&quot;, &quot;john_newyork@mail.com&quot;], [&quot;Mary&quot;, &quot;mary@mail.com&quot;]]Output: [[&quot;John&quot;, &apos;john00@mail.com&apos;, &apos;john_newyork@mail.com&apos;, &apos;johnsmith@mail.com&apos;], [&quot;John&quot;, &quot;johnnybravo@mail.com&quot;], [&quot;Mary&quot;, &quot;mary@mail.com&quot;]]Explanation: 第一个和第三个 John 是同一个人，因为他们有共同的电子邮件 &quot;johnsmith@mail.com&quot;。 第二个 John 和 Mary 是不同的人，因为他们的电子邮件地址没有被其他帐户使用。 我们可以以任何顺序返回这些列表，例如答案[[&apos;Mary&apos;，&apos;mary@mail.com&apos;]，[&apos;John&apos;，&apos;johnnybravo@mail.com&apos;]， [&apos;John&apos;，&apos;john00@mail.com&apos;，&apos;john_newyork@mail.com&apos;，&apos;johnsmith@mail.com&apos;]]仍然会被接受。 注意： accounts的长度将在[1，1000]的范围内。 accounts[i]的长度将在[1，10]的范围内。 accounts[i][j]的长度将在[1，30]的范围内。 标准答案 使用并查集或者DFS，这道题目里用到了路径压缩(找到u所在的树根v以后，把从u到v的路径上所有点的父亲都设置为v)，注意parent是父节点并不是根节点。怎么去并，去并谁也是要想清楚的，比如这一题我们要合并的是账号，那么遍历账号，根据邮箱一样这个筛选条件去合并。 代码 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152from collections import defaultdictclass UnionFind(): def __init__(self, n): self.parent = [i for i in range(n)] def find(self, x): while self.parent[x] != x: self.parent[x] = self.parent[self.parent[x]] x = self.parent[x] return x def union(self, x, y): rootx = self.find(x) rooty = self.find(y) if rootx != rooty: self.parent[rooty] = rootxclass Solution: def accountsMerge(self, accounts): """ :type accounts: List[List[str]] :rtype: List[List[str]] """ n = len(accounts) uf = UnionFind(n) dict = &#123;&#125; for i, a in enumerate(accounts): for email in a[1:]: if email in dict: r1, r2 = uf.find(i), uf.find(dict[email]) uf.parent[r2] = r1 else: dict[email] = i dict_res = defaultdict(set) for k in range(n): dict_res[uf.find(k)] |= set(accounts[k][1:]) res = [] for k,v in dict_res.items(): res.append([accounts[k][0]]+sorted(v)) return resif __name__ == "__main__": a = Solution() print(a.accountsMerge(accounts=[["David","David0@m.co","David1@m.co"],\ ["David","David3@m.co","David4@m.co"],\ ["David","David4@m.co","David5@m.co"],\ ["David","David2@m.co","David3@m.co"],\ ["David","David1@m.co","David2@m.co"]])) 763. 划分字母区间 状态：不会 题目 字符串 S 由小写字母组成。 我们要把这个字符串划分为尽可能多的片段，同一个字母只会出现在其中的一个片段。 返回一个表示每个字符串片段的长度的列表。 示例 1: 123456输入: S = &quot;ababcbacadefegdehijhklij&quot;输出: [9,7,8]解释:划分结果为 &quot;ababcbaca&quot;, &quot;defegde&quot;, &quot;hijhklij&quot;。每个字母最多出现在一个片段中。像 &quot;ababcbacadefegde&quot;, &quot;hijhklij&quot; 的划分是错误的，因为划分的片段数较少。 注意: 12S的长度在[1, 500]之间。S只包含小写字母&apos;a&apos;到&apos;z&apos;。 标准答案 记录每个字符出现的最后一个索引，遍历字符串时，将每个字符与记录索引对比从而求得每个字符区间。 代码 123456789101112131415161718192021222324class Solution: def partitionLabels(self, S): """ :type S: str :rtype: List[int] """ dic = dict() for i, ch in enumerate(S): dic[ch] = i cnt = [-1] cur = 0 for i, ch in enumerate(S): cur = max(cur, dic[ch]) if i == cur: cnt.append(cur) cur = i + 1 re = [] for i in range(1, len(cnt)): re.append(cnt[i] - cnt[i - 1]) return reif __name__ == "__main__": a = Solution() print(a.partitionLabels(S = "ababcbacadefegdehijhklij")) 93. 复原IP地址 状态：不会 题目 给定一个只包含数字的字符串，复原它并返回所有可能的 IP 地址格式。 示例: 12输入: "25525511135"输出: ["255.255.11.135", "255.255.111.35"] 标准答案 DFS 代码 123456789101112131415161718192021222324252627class Solution: def restoreIpAddresses(self, s): """ :type s: str :rtype: List[str] """ res = [] self.dfs(s, 0, "", res) return res def dfs(self, s, index, path, res): if index == 4: if not s: res.append(path[:-1]) return for i in range(1, 4): if i &lt;= len(s): if i == 1: self.dfs(s[1:], index + 1, path + s[0] + '.', res) elif i == 2 and s[0] != '0': self.dfs(s[2:], index + 1, path + s[:2] + '.', res) elif i == 3 and s[0] != '0' and int(s[:3]) &lt; 256: self.dfs(s[3:], index + 1, path + s[:3] + '.', res)if __name__ == "__main__": a = Solution() print(a.restoreIpAddresses(s="25525511135")) 393. UTF-8 编码验证 状态：空间复杂度未通过 题目 UTF-8 中的一个字符可能的长度为 1 到 4 字节，遵循以下的规则： 对于 1 字节的字符，字节的第一位设为0，后面7位为这个符号的unicode码。 对于 n 字节的字符 (n &gt; 1)，第一个字节的前 n 位都设为1，第 n+1 位设为0，后面字节的前两位一律设为10。 剩下的没有提及的二进制位，全部为这个符号的unicode码。 这是 UTF-8 编码的工作方式： Char. number range UTF-8 octet sequence 0000 0000-0000 007F 0xxxxxxx 0000 0080-0000 07FF 110xxxxx 10xxxxxx 0000 0800-0000 FFFF 1110xxxx 10xxxxxx 10xxxxxx 0001 0000-0010 FFFF 11110xxx 10xxxxxx 10xxxxxx 10xxxxxx 给定一个表示数据的整数数组，返回它是否为有效的 utf-8 编码。 注意: 输入是整数数组。只有每个整数的最低 8 个有效位用来存储数据。这意味着每个整数只表示 1 字节的数据。 示例 1: 123data = [197, 130, 1], 表示 8 位的序列: 11000101 10000010 00000001.返回 true 。这是有效的 utf-8 编码，为一个2字节字符，跟着一个1字节字符。 示例 2: 12345data = [235, 140, 4], 表示 8 位的序列: 11101011 10001100 00000100.返回 false 。前 3 位都是 1 ，第 4 位为 0 表示它是一个3字节字符。下一个字节是开头为 10 的延续字节，这是正确的。但第二个延续字节不以 10 开头，所以是不符合规则的。 代码 1234567891011121314151617181920212223242526272829303132333435363738394041424344class Solution: def validUtf8(self, data): """ :type data: List[int] :rtype: bool """ if not data: return True if self.Binary(data[0])[2] == '0': if len(data) == 1: return True else: return self.validUtf8(data[1:]) else: cB = self.countB(data[0]) if cB == 1 or cB &gt; 4: return False if len(data) &gt;= cB: for i in range(1, cB): if self.Binary(data[i])[2:4] != '10': return False return self.validUtf8(data[cB:]) else: return False def Binary(self, num): b_num_len = len(bin(num)) if b_num_len != 10: return '0b'+'0'*(10-b_num_len)+bin(num)[2:] else: return bin(num) def countB(self, num): cnt = 0 for b in self.Binary(num)[2:]: if b == '1': cnt += 1 else: return cnt return cntif __name__ == "__main__": a = Solution() print(a.validUtf8(data=[250,145,145,145,145])) 851. 喧闹和富有 状态：不会 题目 在一组 N 个人（编号为 0, 1, 2, …, N-1）中，每个人都有不同数目的钱，以及不同程度的安静（quietness）。 为了方便起见，我们将编号为 x 的人简称为 &quot;person x &quot;。 如果能够肯定 person x 比 person y 更有钱的话，我们会说 richer[i] = [x, y] 。注意 richer 可能只是有效观察的一个子集。 另外，如果 person x 的安静程度为 q ，我们会说 quiet[x] = q 。 现在，返回答案 answer ，其中 answer[x] = y 的前提是，在所有拥有的钱不少于 person x 的人中，person y 是最安静的人（也就是安静值 quiet[y] 最小的人）。 示例： 12345678910111213输入：richer = [[1,0],[2,1],[3,1],[3,7],[4,3],[5,3],[6,3]], quiet = [3,2,5,4,6,1,7,0]输出：[5,5,2,5,4,5,6,7]解释： answer[0] = 5，person 5 比 person 3 有更多的钱，person 3 比 person 1 有更多的钱，person 1 比 person 0 有更多的钱。唯一较为安静（有较低的安静值 quiet[x]）的人是 person 7，但是目前还不清楚他是否比 person 0 更有钱。answer[7] = 7，在所有拥有的钱肯定不少于 person 7 的人中(这可能包括 person 3，4，5，6 以及 7)，最安静(有较低安静值 quiet[x])的人是 person 7。其他的答案也可以用类似的推理来解释。 提示： 1 &lt;= quiet.length = N &lt;= 500 0 &lt;= quiet[i] &lt; N，所有 quiet[i] 都不相同。 0 &lt;= richer.length &lt;= N * (N-1) / 2 0 &lt;= richer[i][j] &lt; N richer[i][0] != richer[i][1] richer[i] 都是不同的。 对 richer 的观察在逻辑上是一致的。 标准答案 综合运用动态规划和记忆存储，这道题最佳答案秒在对安静数组进行排序，导致首先遍历最安静的人，那么这个人对应的答案就是自己，因为符合比自己富有（包括自己），并且最安静的要求。 紧接着遍历比这个人穷的人，并且标记每个穷人的答案就是这个人，因为符合相对富有且最安静的要求。 代码 1234567891011121314151617181920212223242526272829303132333435import collectionsclass Solution: def loudAndRich(self, richer, quiet): """ :type richer: List[List[int]] :type quiet: List[int] :rtype: List[int] """ graph = collections.defaultdict(list) for a, b in richer: graph[a].append(b) qi = [[q, i] for i, q in enumerate(quiet)] # !! look at me qi.sort() res = [-1] * len(quiet) def search(i, t): res[i] = t for adj in graph[i]: if res[adj] == -1: search(adj, t) for q, i in qi: if res[i] == -1: search(i, i) return resif __name__ == "__main__": a = Solution() print(a.loudAndRich(richer=[[0,1],[1,2]], quiet = [0,1,2])) 5. 最长回文子串 状态：不会 题目 给定一个字符串 s，找到 s 中最长的回文子串。你可以假设 s 的最大长度为 1000。 示例 1： 123输入: &quot;babad&quot; 输出: &quot;bab&quot; 注意: &quot;aba&quot; 也是一个有效答案。 示例 2： 12输入: &quot;cbbd&quot; 输出: &quot;bb&quot; 标准答案 回文子串一共有两种类型： 1.aba 2.abba 按照这两种类型的组成特点，依次从内到外遍历。利用记忆存储当前状态下的最长回文子串。 代码 1234567891011121314151617181920212223class Solution(object): def longestPalindrome(self, s): &quot;&quot;&quot; :type s: str :rtype: str &quot;&quot;&quot; res = &quot;&quot; for i in xrange(len(s)): # odd case, like &quot;aba&quot; tmp = self.helper(s, i, i) if len(tmp) &gt; len(res): res = tmp # even case, like &quot;abba&quot; tmp = self.helper(s, i, i+1) if len(tmp) &gt; len(res): res = tmp return res # get the longest palindrome, l, r are the middle indexes # from inner to outer def helper(self, s, l, r): while l &gt;= 0 and r &lt; len(s) and s[l] == s[r]: l -= 1; r += 1 return s[l+1:r] 63. 不同路径 II 状态：排名85.07% 题目 一个机器人位于一个 m x n 网格的左上角 （起始点在下图中标记为“Start” ）。 机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为“Finish”）。 现在考虑网格中有障碍物。那么从左上角到右下角将会有多少条不同的路径？ 网格中的障碍物和空位置分别用 1 和 0 来表示。 说明：m 和 n 的值均不超过 100。 示例 1: 123456789101112输入:[ [0,0,0], [0,1,0], [0,0,0]]输出: 2解释:3x3 网格的正中间有一个障碍物。从左上角到右下角一共有 2 条不同的路径：1. 向右 -&gt; 向右 -&gt; 向下 -&gt; 向下2. 向下 -&gt; 向下 -&gt; 向右 -&gt; 向右 标准答案 62. 不同路径的衍生版本，主要难点在于边界条件，在for循环之后要特别考虑有一些特殊情况容易漏掉。 代码 1234567891011121314151617181920212223242526272829303132333435363738394041class Solution(object): def uniquePathsWithObstacles(self, obstacleGrid): &quot;&quot;&quot; :type obstacleGrid: List[List[int]] :rtype: int &quot;&quot;&quot; if obstacleGrid[0][0] == 1: return 0 m = len(obstacleGrid) n = len(obstacleGrid[0]) if m == 1: if 1 in obstacleGrid[0]: return 0 else: return 1 if n == 1: for row in obstacleGrid: if 1 in row: return 0 return 1 res = [[0 for i in range(n)] for j in range(m)] res[0][0] = 1 for i in range(m): for j in range(n): if i == 0 and j == 0: continue if obstacleGrid[i][j] == 1: res[i][j] = 0 elif i == 0 and j &gt; 0: res[i][j] = res[i][j-1] elif j == 0 and i &gt; 0: res[i][j] = res[i-1][j] else: res[i][j] = res[i - 1][j] + res[i][j-1] return res[-1][-1]if __name__ == &quot;__main__&quot;: a = Solution() print(a.uniquePathsWithObstacles(obstacleGrid=[[1,0],[0,0]])) 39. 组合总和 状态：不会 题目 给定一个无重复元素的数组candidates和一个目标数target，找出candidates中所有可以使数字和为target的组合。 candidates中的数字可以无限制重复被选取。 说明： 所有数字（包括target）都是正整数。 解集不能包含重复的组合。 示例 1: 123456输入: candidates = [2,3,6,7], target = 7,所求解集为:[ [7], [2,2,3]] 示例 2: 1234567输入: candidates = [2,3,5], target = 8,所求解集为:[ [2,2,2,2], [2,3,3], [3,5]] 标准答案 主要还是递归，不过递归中加入更多的限制条件。 参考：回溯算法+剪枝 代码 12345678910111213141516171819202122232425262728293031323334353637383940414243import java.util.List;import java.util.Stack;import java.util.ArrayList;import java.util.Arrays;public class Solution &#123; private List&lt;List&lt;Integer&gt;&gt; res = new ArrayList&lt;&gt;(); private int[] candidates; private int len; private void findCombinationSum(int residue, int start, Stack&lt;Integer&gt; pre) &#123; if (residue == 0) &#123; res.add(new ArrayList&lt;&gt;(pre)); return; &#125; for (int i = start; i &lt; len &amp;&amp; residue - candidates[i] &gt;= 0; i++) &#123; pre.add(candidates[i]); findCombinationSum(residue-candidates[i], i, pre); pre.pop(); &#125; &#125; public List&lt;List&lt;Integer&gt;&gt; combinationSum(int[] candidates, int target)&#123; int len = candidates.length; if (len == 0) &#123; return res; &#125; Arrays.sort(candidates); this.len = len; this.candidates = candidates; findCombinationSum(target, 0, new Stack&lt;&gt;()); return res; &#125; public static void main(String[] args) &#123; int[] candidates = &#123;2, 3, 6, 7&#125;; int target = 7; Solution solution = new Solution(); List&lt;List&lt;Integer&gt;&gt; combinationSum = solution.combinationSum(candidates, target); System.out.println(combinationSum); &#125; 40. 组合总和 状态：不会 题目 题型总结 探索连通性 以下题目都是探索区域的连通性或以此为基础，均可用DFS或者并查集解决。 DFS在尽可能深的探索完毕后返回即代表一个连通区域探索完毕，而并查集利用树的结构记录连通区域，以方便计算连通区域的个数。 题目： Leetcode 200【岛屿】 Leetcode 695【岛屿】 Leetcode 547【朋友圈】 Leetcode 684【冗余连接】 Leetcode 685【冗余连接】 Leetcode 721【账号合并】]]></content>
      <categories>
        <category>IT应聘</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JAVA数据库操作神器——iBATIS]]></title>
    <url>%2F2019%2F12%2F09%2FJAVA%E6%95%B0%E6%8D%AE%E5%BA%93%E6%93%8D%E4%BD%9C%E7%A5%9E%E5%99%A8%E2%80%94%E2%80%94Ibatis%2F</url>
    <content type="text"><![CDATA[iBATIS 由于工作的原因，编程语言从python变成了java，刚开始接触java的时候，感觉跟python不同最直接明显的一点是：看不懂的配置文件太多了，不知道是用来的干嘛的😂 其中就包括跟数据库相关的配置文件，再加上这两个月工作上涉及到的java数据库操作，所以想系统总结下自己对java数据库操作的认识。 但是为什么要使用iBATIS呢？ 传统的JDBC(Java Database Connectivity)方式会造成代码重复，sql语言散落在项目的各个角落，不利于后期的维护。 数据库连接创建、释放频繁造成系统资源浪费，从而影响系统性能。如果使用数据库连接池可解决此问题。 iBATIS让程序员将更多的精力集中于代码本身。 iBATIS是一款优秀的持久层框架，它支持定制化 SQL、存储过程以及高级映射。MyBatis避免了几乎所有的JDBC 代码和手动设置参数以及获取结果集。MyBatis可以使用简单的XML或注解来配置和映射原生信息，将接口和 Java的POJOs(Plain Old Java Objects,普通的Java对象)映射成数据库中的记录。]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>iBATIS</tag>
        <tag>java数据库</tag>
        <tag>持久层框架</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[关键路径和关键活动的计算]]></title>
    <url>%2F2019%2F11%2F03%2F%E5%85%B3%E9%94%AE%E8%B7%AF%E5%BE%84%E5%92%8C%E5%85%B3%E9%94%AE%E6%B4%BB%E5%8A%A8%E7%9A%84%E8%AE%A1%E7%AE%97%2F</url>
    <content type="text"><![CDATA[AOE网 AOE一般用来估算工程的完成时间。 若在带权的有向图中，以顶点表示事件，以有向边表示活动，边上的权值表示活动的开销（如该活动持续的时间），则此带权的有向图称为AOE网。 关键路径 关键路径就是活动图中路径最长的一条路径。例如下图,v0-&gt;v2-&gt;v3是关键路径。 相关计算 参考视频： https://www.bilibili.com/video/av17396966/?spm_id_from=333.788.videocard.0 该视频详细讲解了有关AOE网络计算的内容，包括关键路径的确定，事件的最早发生时间、事件的最晚发生时间、活动的最早发生时间、活动的最晚发生时间。]]></content>
      <categories>
        <category>软考</category>
      </categories>
      <tags>
        <tag>AOE网</tag>
        <tag>关键路径</tag>
        <tag>关键活动</tag>
        <tag>网络图计算</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo和Next版本更新]]></title>
    <url>%2F2019%2F06%2F15%2FHexo%E5%92%8CNext%E7%89%88%E6%9C%AC%E6%9B%B4%E6%96%B0%2F</url>
    <content type="text"><![CDATA[更新Hexo 查看本地hexo过期package: 1npm outdated 2. 更新Hexo目下的`package.json文件`对应版本至最新: 3. 执行更新操作： 1npm update 查看更新后的版本： 1hexo version 检查是否还需更新的package: 1npm outdated Refer: 感谢starlin的精彩博文😉]]></content>
      <categories>
        <category>教程</category>
      </categories>
      <tags>
        <tag>Github Pages</tag>
        <tag>Hexo</tag>
        <tag>Next</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[校招笔试记录]]></title>
    <url>%2F2018%2F09%2F06%2F%E6%A0%A1%E6%8B%9B%E7%BC%96%E7%A8%8B%E9%A2%98%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[字节跳动 参考：https://www.nowcoder.com/discuss/98693 校招第一批笔试 世界杯开幕式 思路 深度优先搜索，这题与leetcode两题的区别在于，这题算上了斜对角，虽然学会leetcode200后，基本这类题目都能做出来，但是感觉还是要调试好久，尤其是要计算最大面积/最大球队群体人数。 代码 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849class Solution(): def world_cup(self, grid): P = 0 Q_list = [] for i in range(len(grid)): for j in range(len(grid[0])): Q = 0 Q = self.dfs(grid, i, j, Q) if Q: Q_list.append(Q) P += 1 return (P, max(Q_list)) def dfs(self, grid, i, j, Q): Q = 0 if i &lt; 0 or j &lt; 0 or i &gt;= len(grid) or j &gt;= len(grid[0]) or grid[i][j] != 1: return grid[i][j] = '#' Q += 1 up = self.dfs(grid, i - 1, j, Q) if up: Q += up up_right = self.dfs(grid, i - 1, j + 1, Q) if up_right: Q += up_right up_left = self.dfs(grid, i - 1, j - 1, Q) if up_left: Q += up_left down = self.dfs(grid, i+1, j, Q) if down: Q += down down_right = self.dfs(grid, i + 1, j + 1, Q) if down_right: Q += down_right down_left = self.dfs(grid, i + 1, j - 1, Q) if down_left: Q += down_left right = self.dfs(grid, i, j+1, Q) if right: Q += right left = self.dfs(grid, i, j-1, Q) if left: Q += left return Qif __name__ == "__main__": a = Solution() grid = [[0,0,0,0,0,0,0,0,0,0], [0,0,0,1,1,0,1,0,0,0], [0,1,0,0,0,0,0,1,0,1], [1,0,0,0,0,0,0,0,1,1], [0,0,0,1,1,1,0,0,0,1], [0,0,0,0,0,0,1,0,1,1], [0,1,1,0,0,0,0,0,0,0], [0,0,0,1,0,1,0,0,0,0], [0,0,1,0,0,1,0,0,0,0], [0,1,0,0,0,0,0,0,0,0]] print(a.world_cup(grid)) 参考： leetcode200. 岛屿的个数 https://leetcode-cn.com/problems/number-of-islands/ leetcode695. 岛屿的最大面积 https://leetcode-cn.com/problems/max-area-of-island/ 文章病句标识 思路 最关键在于先对所有区间进行排序，再对排序后的区间列表进行遍历，有交叉的区间进行合并操作，反之则添加进最终列表，思路与Leetcode56一模一样，只是换了一个题目背景。 代码 123456789101112131415161718192021import sysdef modify_article(): worker = int(sys.stdin.readline().strip()) sentence = [] for i in range(worker): input_line = sys.stdin.readline().strip() for rag in input_line.split(';'): rag_int = list(map(int, rag.split(','))) sentence.append(rag_int) out = [] for i in sorted(sentence, key=lambda x: x[0]): if out and i[0] &lt;= out[-1][1]: out[-1][1] = max(out[-1][1], i[1]) else: out.append(i) print(out)modify_article() 参考： leetcode56. 合并区间 https://leetcode-cn.com/problems/merge-intervals/ 团队积分 思路 背包问题的变种，很难理解，除了经典的01背包问题较好理解，其他各种变型都不太好理解，需要花整段时间去好好研究下《背包九讲》。 代码 1234567891011121314151617181920212223242526272829303132333435363738import sysclass Solution(): def CardGame(self): n = int(sys.stdin.readline().strip()) card = [] for i in range(n): card.append(list(map(int, sys.stdin.readline().strip().split(' ')))) x = [] y = [] for single_card in card: x.append(single_card[0]) y.append(single_card[1]) mx = max(x) # 获取最大值，作为差的边界 dp = [[0] * (mx + 1) for _ in range(n + 1)] # 初始化dp for i in range(1, n + 1): for j in range(mx + 1): tmp1, tmp2 = 0, 0 if j - x[i - 1] &gt;= 0: # 这张卡牌给小a tmp1 = dp[i - 1][j - x[i - 1]] + y[i - 1] if j + x[i - 1] &lt;= mx: # 这张卡牌给小b tmp2 = dp[i - 1][j + x[i - 1]] + y[i - 1] dp[i][j] = max(dp[i - 1][j], tmp1, tmp2) # 三种状态的最高得分 if i == 1 and j == 0: # 只有一张卡牌时 dp[i][j] = 0 return dp[n][0]if __name__ == "__main__": a = Solution() print(a.CardGame()) 参考： Leetcode416. 分割等和子集 https://leetcode-cn.com/problems/partition-equal-subset-sum/ Leetcode322. 零钱兑换 https://leetcode-cn.com/problems/coin-change/ Leetcode377. 组合总和 Ⅳ https://leetcode-cn.com/problems/combination-sum-iv/ Leetcode474. 一和零 https://leetcode-cn.com/problems/ones-and-zeroes/ Leetcode139. 单词拆分 https://leetcode-cn.com/problems/word-break/ Leetcode494. 目标和 https://leetcode-cn.com/problems/target-sum/ 序列区间 抖音主播 参考：经典的贪心算法 校招第二批笔试 2018.8.25 19校招第二批笔试 字节跳动大闯关 乔迁之喜，字节君决定邀请整个EE团队，举办一个大型团建游戏-字节跳动大闯关。 可是遇到了一个问题： EE团队共有n个人，大家都比较害羞，不善于与陌生人交流。 这n个人每个人都向字节君提供了自己认识人的名字，不包括自己。 如果A的名单里有B，或B的名单里有A，则代表A与B相互认识。 同时如果A认识B，B认识C，则代表A与C也会很快认识，毕竟通过B的介 绍，两个人就可以很快相互认识的了。 为了大闯关游戏可以更好地团队协作、气氛更活跃，并使得团队中的人可以尽快的相互了解、认识和交流，字节君决定根据这个名单将团队分为m组，每组人数可以不同，但组内的任何一个人都与组内的其他所有人直接或间接的认识和交流。 如何确定一个方案，使得团队可以分成m组，并且这个m尽可能地小呢？ 输入描述：第一行一个整数n，代表有n个人，从1开始编号。接下来有n行，第x+1行代表编号为x的人认识的人的编号k（1&lt;=k&lt;=n）,每个人的名单以0代表结束。 输出描述：一个整数m，代表可以分的最小的组的个数。 示例 输入： 12345678910111005 3 08 4 09 09 03 007 9 009 7 0 输出： 12 说明： 1号同学孤独地自己一个组，因为他谁也不认识，也没有人认识他。 其他所有人均可以直接或间接认识，分在同一个组。 注意，题目意思是第一行10，代表一共有10个人，第二行0，代表编号为1的人不认识任何人，第三行0 5 3，代表编号为2的人认识编号5和编号3。 标准答案 该题与Leetcode547. 朋友圈思路一致，可以通过并查集快速解决。 代码 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849import sysclass UnionFind(object): def __init__(self, n_friends): self.n = len(n_friends) self.parent = [-1] * self.n for idx in range(self.n): self.parent[idx] = idx def find(self, i): if self.parent[i] != i: self.parent[i] = self.find(self.parent[i]) return self.parent[i] def union(self, x, y): rootx = self.find(x) rooty = self.find(y) if rootx != rooty: self.parent[rooty] = rootx def diff_teams(self): diff_teams = set() for i in range(self.n): diff_teams.add(self.find(i)) return len(diff_teams)class Solution(object): def divide_team(self, n_friends): """ :type n_friends:List[List[int]] :return: int """ n = len(n_friends) uf = UnionFind(n_friends) for i in range(n): if n_friends[i] != []: for j in range(len(n_friends[i])): uf.union(i,n_friends[i][j]-1) return uf.diff_teams()if __name__ == "__main__": n = int(sys.stdin.readline().strip()) n_friends = [] for i in range(n): p_friends = list(map(int, sys.stdin.readline().strip().split(' ')))[:-1] n_friends.append(p_friends) a = Solution() print(a.divide_team(n_friends)) 合法的表达式 双生词 空气质量 思路 和Leetcode300思路一样，这题是求最长不降子序列。 具体解题思路参考Leetcode300。 代码 1234567891011121314151617181920212223import sysclass Solution(): def AirQuality(self): f_line = sys.stdin.readline().strip().split(' ') n = int(f_line[0]) t = int(f_line[1]) s_line = sys.stdin.readline().strip().split(' ') OneHPM = list(map(int, s_line)) PM =[] for i in range(t): PM += OneHPM T = [1 for i in range(len(PM))] for i in range(1, len(PM)): for j in range(i): if PM[j] &lt;= PM[i]: T[i] = max(T[i], T[j]+1) return max(T)if __name__ == "__main__": a = Solution() print(a.AirQuality()) 参考： leetcode300. 最长上升子序列 https://leetcode-cn.com/problems/longest-increasing-subsequence/ 减法求值 校招第三批笔试 2018.9.9 19校招第三批笔试 最大不重复子串 参考： LeetCode 第3题原题 代码 123456789101112131415161718192021import sysclass Solution(): def MaxNotRepeatSTR(self): string = sys.stdin.readline().strip() dict = &#123;&#125; begin, res = -1, 0 for end in range(len(string)): if string[end] in dict: begin = dict[string[end]] dict = &#123;&#125; else: res = max(res, end - begin) dict[string[end]] = end return resif __name__ == "__main__": a = Solution() print(a.MaxNotRepeatSTR()) 组织优化 题目描述： 随着公司的快速发展，基层团队越来越多。近期公司希望对部门重新做一个划分，尽可能把紧密合作的团队放到同一个部门。 给定一个$M \times N$的2维数组，每个值1的元素代表一个团队。如果2个团队在上下或左右的方向上相邻，说明2个团队有紧密合作关系。 需要把合作紧密的团队放到一起，形成一个部门；没有合作关系的团队，放到不同部门。 判断给定输入中，有多少个部门。 例如，给定一个二维数组： 123451 0 0 1 11 0 0 1 10 0 1 0 00 0 1 0 00 0 1 0 0 其中有9个团队，一共需要组成3个部门，分别是： 1211 以及 121 11 1 以及 123111 输入描述： 12第一行一个整数，代表M 后面M行，每行M个整数(取值0或1) 输出描述： 1一个整数，表示部门数量 示例1 12345678输入41 0 0 00 0 0 00 0 0 10 0 0 0输出2 备注： 11 &lt; M &lt; 1000 参考： 岛屿问题，深度优先搜索，详细参考LeetCode 第200题 代码 12345678910111213141516171819202122232425262728293031import sysclass Solution(): def MergeDepartment(self): M = int(sys.stdin.readline().strip()) matrix = [] for i in range(M): line = list(map(int, sys.stdin.readline().strip().split(" "))) matrix.append(line) N = len(matrix[0]) cnt = 0 for i in range(M): for j in range(N): if matrix[i][j] == 1: self.dfs(i, j, matrix, M, N) cnt += 1 return cnt def dfs(self, i, j, matrix, M, N): if i &lt; 0 or i &gt; M - 1 or j &lt; 0 or j &gt; N - 1 or matrix[i][j] != 1: return matrix[i][j] = 9 self.dfs(i + 1, j, matrix, M, N) self.dfs(i - 1, j, matrix, M, N) self.dfs(i, j - 1, matrix, M, N) self.dfs(i, j + 1, matrix, M, N)if __name__ == "__main__": a = Solution() print(a.MergeDepartment()) IP还原 参考： LeetCode 第93题 代码 12345678910111213141516171819202122232425262728import sysclass Solution(): def ReviseIP(self): ip = sys.stdin.readline().strip() self.res = 0 self.dfs(0, ip, "", self.res) return self.res def dfs(self, index, ip, path, res): if index == 4: if not ip: self.res += 1 return for i in range(1, 4): if i &lt;= len(ip): if i == 1: self.dfs(index + 1, ip[1:], path + ip[:1] + '.', res) if i == 2 and ip[0] != '0': self.dfs(index + 1, ip[2:], path + ip[:2] + '.', res) if i == 3 and ip[0] != '0' and int(ip[:3])&lt;256: self.dfs(index + 1, ip[3:], path + ip[:3] + '.', res)if __name__ == "__main__": a = Solution() print(a.ReviseIP()) 注意： 代码中的res要注意。 UTF-8校验 参考： LeetCode 第393题 代码 123456789101112131415161718192021222324252627282930313233import sysclass Solution(): def utf(self): N = int(sys.stdin.readline().strip()) data = list(map(int, sys.stdin.readline().strip().split(" "))) count = 0 for byte in data: if byte &gt;= 128 and byte &lt;= 191: if not count: return False count -= 1 else: if count: return False if byte &lt; 128: continue elif byte &lt; 224: count = 1 elif byte &lt; 240: count = 2 elif byte &lt; 248: count = 3 else: return False return count == 0if __name__ == "__main__": a = Solution() print(a.utf()) 抖音红人 参考： https://www.codetd.com/article/3148943 标准答案 遍历字典，并更新见解关注的关系 代码 1234567891011121314151617181920212223242526272829import collectionsimport sysdef split_guanxi(gx_list, num): gx_dict = collections.defaultdict(set) # key表示用户，value为list，表示谁关注了他 for i, x in enumerate(gx_list): if i % 2 != 0: # 奇数表示拿到的是关注的对象 奇数前面的偶数表示关注此对象的人 gx_dict[x].add(x) gx_dict[x].add(gx_list[i-1]) for i in range(int(num)): # 需要多次检测，因为有间接的关注关系 for star, user in gx_dict.items(): # star 表示被关注的人， user表示关注者 add_people = set() for xx in user: if xx in gx_dict: add_people |= gx_dict[xx] gx_dict[star] |= add_people star_num = 0 for star, user in gx_dict.items(): if len(user) == int(num): star_num += 1 return star_numif __name__ == "__main__": N = int(sys.stdin.readline().strip()) M = int(sys.stdin.readline().strip()) pair = list(map(int, sys.stdin.readline().strip().split(" "))) print(split_guanxi(pair, N)) 奇虎360 2018.8.27 19校招第一批笔试 一共30道选择题，3道编程题。 选择题大多是C语言编程题，时间基本耗在这上面，导致根本没时间看编程题。网上也搜不到资源了。 招行信用卡 2018.8.30 19校招第一批笔试 都是选择题，着重考察机器学习相关知识。 上海农行研发软开 2018.9.1 19校招第一批笔试 题型包括行测、英语、计算机基础（重点考察数据库、C语言），还有最后的性格测试。 普华永道信息技术 2018.9.5 现场全英文笔试 数学、python、机器学习、图像识别、openCV、文本NLP、RNN、正则。 美团 2018.9.6 19校招第一批笔试 选择题：考察行测、机器学习、计算机基础、高数 编程题： 1.大富翁游戏 题目描述： 大富翁游戏，玩家根据骰子的点数决定走的步数，即骰子点数为1时可以走一步，点数为2时可以走两步，点数为n时可以走n步。 求玩家走到第n步（n&lt;=骰子最大点数且是方法的唯一入参）时，总共有多少种投骰子的方法。 输入描述: 输入包括一个整数n,(1 ≤ n ≤ 6) 输出描述: 输出一个整数,表示投骰子的方法 输入例子1: 16 输出例子1: 132 标准代码 和爬楼的想法类似，走n步可以想下除了最后一步以外有几种情况。 参考Leetcode70.爬楼梯 代码 12345678910111213141516171819202122import sysclass Solution(): def BigRich(self): n = int(sys.stdin.readline().strip()) if n == 1: return 1 if n == 2: return 2 if n == 3: return 4 if n == 4: return 8 if n == 5: return 16 if n == 6: return 32if __name__ == "__main__": a = Solution() print(a.BigRich()) 2.拼凑钱币 题目描述： 给你六种面额 1、5、10、20、50、100 元的纸币，假设每种币值的数量都足够多，编写程序求组成N元（N为0~10000的非负整数）的不同组合的个数。 输入描述: 输入包括一个整数n(1 ≤ n ≤ 10000) 输出描述: 输出一个整数,表示不同的组合方案数 输入例子1: 11 输出例子1: 11 B站 2018.9.7 19校招第一批笔试 比较两个版本字符串version1和version2 题目描述： 如果version1 &gt; version2 返回1，如果version1 &lt; version2 返回-1，不然返回0 输入的version字符串非空，只包含数字和字符。字符不代表通常意义上的小数点，只是用来区分数字序列。例如字符串2.5并不代表二点五，只是代表版本是第一级别是2，第二级别是5. 输入： 两个字符串，用空格分割 每个字符串为一个version字符串，非空，只包含数字和字符。 输出： 只能输出1，-1，或0 样例输入： 10.1 1.1 样例输出： 11 顺时针打印数字矩阵 题目描述： 给定一个数字矩阵，请设计一个算法从左上角开始顺时针打印矩阵元素 输入： 第一行是两个数字，分别代表行数M和列数N；接下来是M行，每行N个数字，表示这个矩阵的所有元素；当读到M=-1，N=-1时，输入终止。 输出： 请按逗号分割顺时针打印矩阵元素（注意最后一个元素末尾不要有逗号！例如输出“1，2，3”，而不是“1，2，3，”）每个矩阵输出完成后记得还行； 样例输入： 123453 3 1 2 34 5 6 7 8 9-1 -1 样例输出： 11,2,3,6,9,8,7,4,5 精灵鼠从入口到出口的最少减速 题目描述： 猛兽侠中精灵鼠在利剑飞船的追逐下逃到一个n*n的建筑群中，精灵鼠从(0,0)的位置进入建筑群，建筑群的出口位置为(n-1,n-1)，建筑群的每个位置都有阻碍，每个位置上都会相当于给了精灵鼠一个固定值减速，因为精灵鼠正在逃命所以不能回头只能向前或者向下逃跑，现在精灵鼠最少在减速多少的情况下逃出迷宫？ 输入： 第一行迷宫的大小：n&gt;=2 &amp; n &lt;= 10000;第2到n+1行，每行输入为以‘，’分割的该位置的减速，减速 f &gt;= 1 &amp; f &lt; 10。 输出： 精灵鼠从入口到出口的最少减少速度？ 样例输入： 123435,5,76,7,82,2,4 样例输出： 119 商汤科技 2018.9.7 19校招第一批笔试 最小极差 三原色画板 房间 巨人网络 2018.9.7 19校招第一批笔试 编程题竟然都是SQL语句。 第四范式 2018.9.9 19校招建模工程师笔试 流水表中插入切片表数据 数组分解K个等和子数组 京东 2018.9.9 19校招数据分析工程师笔试 完全多部图 相似子字符串 中国电信IT研发 2018.9.10 19校招大数据工程师 题型分为单选、多选以及编程题，题目大部分是牛客网原题，提前30min交卷😏 迅雷 2018.9.12 19校招大数据分析工程师 全部都是选择题，重点考察概率、数据库以及大数据相关工具Hadoop,Hive等。 记录开发岗两道开发岗的编程题。 红黑积木求和 素勾股数 小米 2018.9.27 19校招算法工程师 10道单选，10道专业多选，2道编程题 厨艺大赛奖金 扑克牌四则运算 牛客网2019年第一次模拟笔试 独立的牛牛 状态：通过40% 题目： 小牛牛为了向他的父母表现他已经长大独立了,他决定搬出去自己居住一段时间。 一个人生活增加了许多花费: 牛牛每天必须吃一个水果并且需要每天支付x元的房屋租金。 当前牛牛手中已经有f个水果和d元钱,牛牛也能去商店购买一些水果,商店每个水果售卖p元。 牛牛为了表现他独立生活的能力,希望能独立生活的时间越长越好,牛牛希望你来帮他计算一下他最多能独立生活多少天。 输入描述: 输入包括一行,四个整数x, f, d, p(1 &lt;= x,f,d,p &lt;= 2 * 10^9),以空格分割 输出描述: 输出一个整数, 表示牛牛最多能独立生活多少天。 示例1 输入 3 5 100 10 输出 11 牛牛炒股票 状态：不会 题目： 牛牛得知了一些股票今天买入的价格和明天卖出的价格，他找犇犇老师借了一笔钱，现在他想知道他最多能赚多少钱。 输入描述： 每个输入包含一个测试用例。 输入的第一行包括两个正整数,表示股票的种数N (1&lt;=N&lt;=1000)(1&lt;=N&lt;=1000)和牛牛借的钱数M (1&lt;=M&lt;=1000)(1&lt;=M&lt;=1000)。 接下来N行，每行包含两个正整数，表示这只股票每一股的买入价X (1&lt;=X&lt;=1000)(1&lt;=X&lt;=1000) 和卖出价Y (1&lt;=Y&lt;=2000)(1&lt;=Y&lt;=2000)。 每只股票可以买入多股，但必须是整数。 输出描述： 输出一个整数表示牛牛最多能赚的钱数。 样例： 输入： 3 5 3 6 2 3 1 1 输出： 4 牛牛取快递 状态： 题目： 牛牛的快递到了，他迫不及待地想去取快递，但是天气太热了，以至于牛牛不想在烈日下多走一步。他找来了你，请你帮他规划一下，他最少要走多少距离才能取回快递。 输入描述: 每个输入包含一个测试用例。 输入的第一行包括四个正整数，表示位置个数N(2&lt;=N&lt;=10000)，道路条数M(1&lt;=M&lt;=100000)，起点位置编号S(1&lt;=S&lt;=N)和快递位置编号T(1&lt;=T&lt;=N)。位置编号从1到N，道路是单向的。数据保证S≠T，保证至少存在一个方案可以从起点位置出发到达快递位置再返回起点位置。 接下来M行，每行包含三个正整数，表示当前道路的起始位置的编号U(1&lt;=U&lt;=N)，当前道路通往的位置的编号V(1&lt;=V&lt;=N)和当前道路的距离D(1&lt;=D&lt;=1000)。 输出描述: 对于每个用例，在单独的一行中输出从起点出发抵达快递位置再返回起点的最短距离。 示例1 输入 3 3 1 3 1 2 3 2 3 3 3 1 1 输出 7]]></content>
      <categories>
        <category>IT应聘</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[机器学习]]></title>
    <url>%2F2018%2F09%2F03%2F%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%2F</url>
    <content type="text"><![CDATA[算法分类 学习方法 监督式学习 非监督式学习 半监督式学习 强化学习 懒惰学习/急切学习 懒惰学习(lazy learning) 训练阶段仅仅是把训练样本保存起来，训练时间开销为0，待收到测试样本后再进行处理。KNN算法是“懒惰学习”的著名代表。 急切学习(eager learning) 在训练阶段就对样本进行学习处理的方法，称为“急切学习”。几乎所有的机器学习算法都可以认为是eager method，比如线性回归、逻辑回归、ANN、SVM、决策树、relation rule, etc., 因为他们都是根据训练数据集建立好模型从而对新数据进行预测的。 算法类似性 决策树学习 根据数据的属性采用树状结构建立决策模型。决策树模型常常用来解决分类和回归问题。常见的算法包括 CART (Classification And Regression Tree)、ID3、C4.5、随机森林 (Random Forest) 等。 回归算法 试图采用对误差的衡量来探索变量之间的关系的一类算法。常见的回归算法包括最小二乘法 (Least Square)、逻辑回归 (Logistic Regression)、逐步式回归 (Stepwise Regression) 等。 聚类算法 通常按照中心点或者分层的方式对输入数据进行归并。所有的聚类算法都试图找到数据的内在结构，以便按照最大的共同点将数据进行归类。常见的聚类算法包括 K-Means 算法以及期望最大化算法 (Expectation Maximization) 等。 人工神经网络 模拟生物神经网络，是一类模式匹配算法。通常用于解决分类和回归问题。人工神经网络算法包括感知器神经网络 (Perceptron Neural Network) 、反向传递 (Back Propagation) 和深度学习等。 集成算法 用一些相对较弱的学习模型独立地就同样的样本进行训练，然后把结果整合起来进行整体预测。集成算法的主要难点在于究竟集成哪些独立的较弱的学习模型以及如何把学习结果整合起来。这是一类非常强大的算法，同时也非常流行。常见的算法包括 Boosting、Bagging、AdaBoost、随机森林 (Random Forest) 等。 决策树 参考：https://www.jianshu.com/p/fb97b21aeb1d 决策树是附加概率结果的一个树状的决策图，是直观的运用统计概率分析的图法。机器学习中决策树是一个预测模型，它表示对象属性和对象值之间的一种映射，树中的每一个节点表示对象属性的判断条件，其分支表示符合节点条件的对象。树的叶子节点表示对象所属的预测结果。 预测是否具有偿还贷款的能力： 基本知识 信息增益 信息熵表示的是不确定度。均匀分布时，不确定度最大，此时熵就最大。当选择某个特征对数据集进行分类时，分类后的数据集信息熵会比分类前的小，其差值表示为信息增益。信息增益可以衡量某个特征对分类结果的影响大小。 基尼系数 基尼指数反应了从数据集中随机抽取两个样本，其类标不一致的概率。 决策树算法 决策树的损失函数通常是正则化的极大似然函数，学习的策略是以损失函数为目标函数的最小化。 所以决策树的本质和其他机器学习模型是一致的，有一个损失函数，然后去优化这个函数；然而，区别就在于如何优化。 决策树采用启发式算法来近似求解最优化问题，得到的是次最优的结果。 该启发式算法可分为三步： 特征选择 模型生成 决策树的剪枝 决策树学习算法通常是一个递归地选择最优特征，并根据该特征对训练数据进行分割。 选择最优特征要根据特征的分类能力，特征分类能力的衡量通常采用信息增益或信息增益比。 决策树学习常用的算法主要有以下三种： ID3算法，C4.5算法，CART算法。 算法总结: ID3算法/C4.5算法/CART算法。 ID3算法和C4.5算法用于生成分类树，区别主要在于选取特征的依据，前者是信息增益，后者是信息增益比。 CART算法可以生成分类树和回归树，分类树使用基尼指数选取特征，并且不用提前确定α值，而是在剪枝的同时找到最优的α值. 集成学习 Bagging bagging:bootstrap aggregating 的缩写。 bagging是一种并行式集成学习方法，可用于二分类，多分类，回归等任务。 基本流程 对一个包含 m 个样本的数据集，有放回地进行 m 次随机采样，这样得到具有 m 个样本的采样集。 取 T 个这样的采样集。 每个采样集训练一个基学习器。 结合：分类任务，使用简单投票法。回归任务，使用简单平均法。 有放回抽样的好处? 这种有放回抽样会有 63.2% 的样本出现在采样集中，而剩下的 36.8% 样本可以作为验证集对模型的泛化性能进行包外估计。 当基学习器是决策树时，可以用包外样本来辅助剪枝， 还可以用于估计决策树中各结点的后验概率来辅助对零训练样本结点的处理。 基学习器是神经网络时，用包外样本来辅助早期停止来减小过拟合。 Bagging特点 Bagging 主要关注降低方差，是要降低过拟合，而不会降低偏差，因此最好不要用高偏差的模型。 在不剪枝决策树，神经网络等易受样本扰动的学习器上效用更为明显。 例如当基学习器是决策树时，Bagging 是并行的生成多个决策树，此时可以不做剪枝，这样每个都是强学习器，就会有过拟合的问题，但是多个学习器组合在一起，可以降低过拟合。 随机森林 随机森林和Bagging同属于弱依赖学习器，前面已经介绍了Bagging，随机森林是进阶版Bagging。 随机森林的思想仍然是Bagging，它使用CART决策树作为弱学习器，而RF进阶在于对决策树的建立做了改进。对于普通的决策树，在节点上所有的n个样本特征中选择最优的特征来做决策树的左右子树划分，但是RF通过随机选择节点上的部分样本特征$n_{sub}$，再在这些随机选择的$n_{sub}$个样本特征中选择最优的特征做决策树的左右子树划分，这样做进一步加强了模型的泛化能力。 针对结合策略，如果是分类问题，则采用简单投票法；如果是回归问题，则采用算术平均法。 Bagging 和 Boosting 的区别 样本选择： Bagging 的训练集是在原始集中有放回选取的，各轮训练集之间是独立的，每个样例的权重相等； Boosting 的训练集不变，只是每个样例在分类器中的权重发生变化，错误的样本会得到更大的重视； Bagging 的预测函数没有权重之分；Boosting 的预测函数是有权重之分，效果好的函数权重大； Bagging 的各个预测函数并行产生，容易 map-reduce ，Boosting 的预测是顺序产生，后一个模型参数需要前一轮模型的结果。]]></content>
  </entry>
  <entry>
    <title><![CDATA[”魔镜杯“风控算法大赛]]></title>
    <url>%2F2018%2F08%2F14%2F%E2%80%9D%E9%AD%94%E9%95%9C%E6%9D%AF%E2%80%9C%E9%A3%8E%E6%8E%A7%E7%AE%97%E6%B3%95%E5%A4%A7%E8%B5%9B%2F</url>
    <content type="text"><![CDATA[介绍 拍拍贷是一家互联网金融公司，在2016年拍拍贷举办“魔镜杯”风险算法大赛，首度公开真实的历史数据，旨在寻求高效准确的预测算法， 为公司投资人提供决策依据，促进健康高效的互联网金融。 数据 为保护用户隐私安全，项目所用数据均已经经过脱敏处理。 数据主要分为3个表：Master、Log_Info、Userupdate_Info 每一行代表一个样本(一笔成功成交借款),每个样本包含200多个各类字段。 1.Master 主要字段 描述 idx 每一笔贷款的unique key，可以与另外2个文件里的idx相匹配 UserInfo 借款人特征字段 WeblogInfo Info网络行为字段 Education 学历学籍字段 ThirdParty_Info_PeriodN 第三方数据时间段N字段 SocialNetwork 社交网络字段 LinstingInfo 借款成交时间 Target 违约标签（1/0,违约/正常）测试集不包含target字段 1234567train_master.info()》&lt;class &apos;pandas.core.frame.DataFrame&apos;&gt;RangeIndex: 30000 entries, 0 to 29999Columns: 228 entries, Idx to ListingInfodtypes: float64(38), int64(170), object(20)memory usage: 52.2+ MB 2.Log_Info 借款人的登陆信息。 主要字段 描述 ListingInfo 借款成交时间 LogInfo1 操作代码 LogInfo2 操作类别 LogInfo3 登陆时间 idx 每一笔贷款的unique key 123456789101112train_loginfo.info()》&lt;class &apos;pandas.core.frame.DataFrame&apos;&gt;RangeIndex: 580551 entries, 0 to 580550Data columns (total 5 columns):Idx 580551 non-null int64Listinginfo1 580551 non-null objectLogInfo1 580551 non-null int64LogInfo2 580551 non-null int64LogInfo3 580551 non-null objectdtypes: int64(3), object(2)memory usage: 22.1+ MB 3.Userupdate_Info 借款人修改信息。 主要字段 描述 ListingInfo1 借款成交时间 UserupdateInfo1 修改内容 UserupdateInfo2 修改时间 idx 每一笔贷款的unique key 1234567891011train_userinfo.info()》&lt;class &apos;pandas.core.frame.DataFrame&apos;&gt;RangeIndex: 372463 entries, 0 to 372462Data columns (total 4 columns):Idx 372463 non-null int64ListingInfo1 372463 non-null objectUserupdateInfo1 372463 non-null objectUserupdateInfo2 372463 non-null objectdtypes: int64(1), object(3)memory usage: 11.4+ MB 比赛规则 参赛团队需要基于训练集数据构建预测模型，使用模型计算测试集的评分（评分数值越高，表示越有可能出现贷款违约）。 模型评价标准： 定义：本次比赛采用AUC来评判模型的效果。AUC即以False Positive Rate为横轴，True Positive Rate为纵轴的ROC （Receiver Operating Characteristic）curve下方的面积的大小。 $$AUC=\frac{\sum_{i} S_{i}}{M \times N}$$ 其中，M为正样本个数，N为负样本个数，M*N为正负样本对的个数。$S_{i}$为第i个正负样本对的得分，定义如下： $$S_{i}=\begin{cases} 1 &amp; score_{i-p} &gt; score_{i-n} \\ 0.5 &amp; score_{i-p} = score_{i-n} \\ 0 &amp; score_{i-p} &lt; score_{i-n} \end{cases}$$ 其中， $score_{i-p}$为正负样本对中，模型给正样本的评分， $score_{i-n}$为正负样本对中，模型给负样本的评分， AUC值在[0,1]区间，越高越好。 数据清洗 缺失值处理 删除缺失数据 Master表信息缺失情况相对比较为严重。 统计各字段的缺失情况： 123456null_sum = train_master.isnull().sum()null_sum = null_sum[null_sum!=0]null_sum_df = pd.DataFrame(null_sum, columns=['num'])null_sum_df['ratio'] = null_sum_df['num'] / 30000.0null_sum_df.sort_values(by='ratio', ascending=False, inplace=True)#对每个字段信息进行缺失率排序null_sum_df[:10] num ratio WeblogInfo_3 29030 0.967667 WeblogInfo_1 29030 0.967667 UserInfo_11 18909 0.630300 UserInfo_13 18909 0.630300 UserInfo_12 18909 0.630300 WeblogInfo_20 8050 0.268333 WeblogInfo_21 3074 0.102467 WeblogInfo_19 2963 0.098767 WeblogInfo_2 1658 0.055267 WeblogInfo_4 1651 0.055033 删除缺失严重的行: 1train_master.drop(['WeblogInfo_3', 'WeblogInfo_1', 'UserInfo_11', 'UserInfo_13', 'UserInfo_12', 'WeblogInfo_20'],axis=1,inplace=True) 删除缺失严重的行： 12345record_nan=train_master.isnull().sum(axis=1).sort_values(ascending=False)drop_record_index=[i for i in record_nan.loc[(record_nan&gt;=5)].index]print("Before train_master shape &#123;&#125;".format(train_master.shape))train_master.drop(drop_record_index, inplace=True)print("After train_master shape &#123;&#125;".format(train_master.shape)) 12Before train_master shape (30000, 222)After train_master shape (29189, 222) 缺失填充 填充缺失值要根据字段的属性进行合理填充，在没有字段信息的情况下，根据数据分布情况填充。 在缺失数据较少的情况下，用频率最高的值填充；在缺失数据较多的情况下，用均值填充。 12345678910111213141516171819202122232425print('Before all nan num&#123;&#125;'.format(train_master.isnull().sum().sum()))train_master.loc[train_master['UserInfo_2'].isnull(), 'UserInfo_2'] = '位置地点'train_master.loc[train_master['UserInfo_4'].isnull(), 'UserInfo_4'] = '位置地点'def fill_nan(f, method): if method == "most": common_value=pd.value_counts(train_master[f], ascending=False).index[0] else: common_value = train_master[f].mean() train_master.loc[train_master[f].isnull(), f]=common_value# 通过pd.value_counts(train_master[f])的观察得到经验fill_nan('UserInfo_1', 'most')fill_nan('UserInfo_3', 'most')fill_nan('WeblogInfo_2', 'most')fill_nan('WeblogInfo_4', 'mean')fill_nan('WeblogInfo_5', 'mean')fill_nan('WeblogInfo_6', 'mean')fill_nan('WeblogInfo_19', 'most')fill_nan('WeblogInfo_21', 'most')print('After all nan num: &#123;&#125;'.format(train_master.isnull().sum() .sum())) 12Before all nan num: 9808After all nan num: 0 异常值处理 本文在处理离群点时，先通过特征分类将数值型特征单独列出来。 通过画图的方式，发现离群点。 12345678910import seaborn as sbnsbn.set(style='whitegrid')import matplotlib.pyplot as plt%matplotlib inlinemelt = pd.melt(train_master, id_vars=['target'], value_vars=[f for f in numerical_features])#FacetGrid绘制各变量之间的关系图g = sbn.FacetGrid(data=melt, col="variable", col_wrap=4, sharex=False, sharey=False)g.map(sbn.stripplot, 'target', 'value', jitter=True, palette='muted') 针对每一个数值型特征值作图分析判断，并删除特征离群的对象。 1229189 lines before drop28074 lines after drop 删除数值型离群点，剩下28074个样本。 特征分类 特征可以分为二值特征、连续特征、枚举特征。 二值特征 主要是0/1特征，即特征只取两种值：0或者1 连续值特征 取值为有理数的特征，特征取值个数不定，例如距离特征，特征取值为是0~正无穷。 枚举值特征 主要是特征有固定个数个可能值，例如今天周几，只有7个可能值：周1，周2，…，周日。 这块内容主要是特征转换,本文涉及以下几种转换情况： 非二值特征转换为二值特征 检查所有特征值的分布，若出现频率最高的值占该特征所有取值情况高达50%，那么就可以将该特征转换为二值特征。 连续值特征转换为枚举特征 当连续值特征的取值范围过小时，可将每个值单独作为一类，即将连续值特征转换为枚举特征。 123456789101112131415161718192021222324252627282930"""-----------------------筛选二值特征--开始------------------"""ratio_threshold = 0.5binarized_features = []binarized_features_most_freq_value = []for f in train_master.columns: if f in ['target']: continue not_null_sum = (train_master[f].notnull()).sum() most_count = pd.value_counts(train_master[f], ascending=False).iloc[0] most_value = pd.value_counts(train_master[f], ascending=False).index[0] ratio = most_count / not_null_sum if ratio &gt; ratio_threshold: binarized_features.append(f) binarized_features_most_freq_value.append(most_value) """-----------------------筛选二值特征--结束------------------""""""-------------------筛选连续值特征--开始------------------"""numerical_features = [f for f in train_master.select_dtypes(exclude=['object']).columns if f not in (['Idx', 'target']) and f not in binarized_features] """-------------------筛选连续值特征--结束------------------""""""-------------------筛选枚举特征--开始------------------"""categorical_features = [f for f in train_master.select_dtypes (include=['object']).columns if f not in (['Idx', 'target']) and f not in binarized_features]"""------------------筛选枚举特征--结束------------------""" 数据转换 特征转换 123456789101112131415161718192021#将挑选出的特征转换为二值特征for i in range(len(binarized_features)): f = binarized_features[i] most_value = binarized_features_most_freq_value[i] train_master['b_'+f] = 1 train_master.loc[train_master[f] == most_value, 'b_'+f] = 0 train_master.drop([f], axis=1, inplace=True) #连续值特征转换为枚举特征import numpy as npfeature_unique_count = []for f in numerical_features: feature_unique_count.append((np.count_nonzero(train_master[f] .unique()), f))for c, f in feature_unique_count: if c &lt;= 10: print('&#123;&#125; moved from numerical to categorical'.format(f)) numerical_features.remove(f) categorical_features.append(f) 对数转换 为提高模型拟合程度，通常要求样本分布呈现(近似)正态分布。 去除离群点后的数值特征分布情况： 明显数据分布偏左，可以采取对数转换的方法将数据分布变得更均匀： 解析时间 解析时间，并将解析后的时间字段加入主表master信息中： 123456789101112131415161718import arrowdef parse_date(date_str, str_format='YYYY/MM/DD'): d = arrow.get(date_str, str_format) #月初、月中、月末 month_stage = int((d.day-1) / 10) + 1 return (d.timestamp, d.year, d.month, d.day, d.week, d.isoweekday(), month_stage)def parse_ListingInfo(date): d = parse_date(date, 'YYYY/M/D') return pd.Series(d, index=['ListingInfo_timestamp', 'ListingInfo_year', 'ListingInfo_month','ListingInfo_day', 'ListingInfo_week', 'ListingInfo_isoweekday', 'ListingInfo_month_stage'], dtype=np.int32)ListingInfo_parsed =train_master_['ListingInfo'].apply(parse_ListingInfo)print('before train_master_ shape&#123;&#125;'.format(train_master_.shape))train_master_ = train_master_.merge(ListingInfo_parsed, how='left', left_index=True, right_index=True)print('after train_master_ shape &#123;&#125;'.format(train_master_.shape)) 解析时间数据后，整个master表多了7列： 12before train_master_ shape (28074, 223)after train_master_ shape (28074, 230) 转换登陆信息 登陆信息： Idx Listinginfo1 LogInfo1 LogInfo2 LogInfo3 0 10001 2014-03-05 107 6 2014-02-20 1 10001 2014-03-05 107 6 2014-02-23 2 10001 2014-03-05 107 6 2014-02-24 3 10001 2014-03-05 107 6 2014-02-25 4 10001 2014-03-05 107 6 2014-02-27 统计每笔交易登陆次数、交易成功时间戳(包含借款、还款等)、登陆次数、登陆间隔时长、最新登陆时间戳、相同操作次数，得到转换后的登陆信息： loginfo_num loginfo_LogInfo1_unique_num XXX loginfo_LogInfo12_unique_num 0 3 26 XXX 8 1 5 11 XXX 4 2 8 125 XXX 13 3 12 199 XXX 11 4 16 15 XXX 7 转换修改信息 修改信息： Idx ListingInfo1 UserupdateInfo1 UserupdateInfo2 0 10001 2014/03/05 _EducationId 2014/02/20 1 10001 2014/03/05 _HasBuyCar 2014/02/20 2 10001 2014/03/05 _LastUpdateDate 2014/02/20 3 10001 2014/03/05 _MarriageStatusId 2014/02/20 4 10001 2014/03/05 _MobilePhone 2014/02/20 统计每笔交易修改信息次数、修改字段数、修改时间次数、间隔天数、最新修改时间戳、按照UserupdateInfo1信息分别统计，得到转换后的修改信息： Idx userinfo_num XXX userinfo_Position_num 0 3 13 XXX 0 1 5 13 XXX 0 2 8 14 XXX 0 3 12 14 XXX 0 4 16 13 XXX 0 枚举特征编码 pandas的get_dummies()函数： 参数： columns：要编码的DataFrame中的列名称。如果列为None，则将转换具有对象或类别dtype的所有列。 12345678910111213141516drop_columns= ['Idx', 'ListingInfo', 'UserInfo_20', 'UserInfo_19','UserInfo_8','UserInfo_7','UserInfo_4','UserInfo_2','ListingInfo_timestamp', 'loginfo_last_day_timestamp', 'userinfo_last_day_timestamp']train_master_ = train_master_.drop(drop_columns, axis=1)dummy_columns = categorical_features.copy()dummy_columns.extend(['ListingInfo_year', 'ListingInfo_month', 'ListingInfo_day', 'ListingInfo_week', 'ListingInfo_isoweekday', 'ListingInfo_month_stage'])finally_dummy_columns = []for c in dummy_columns: if c not in drop_columns: finally_dummy_columns.append(c)print('before get_dummies train_master_ shape &#123;&#125;'.format(train_master_.shape))train_master_ = pd.get_dummies(train_master_, columns=finally_dummy_columns)print('after get_dummies train_master_ shape &#123;&#125;'.format(train_master_.shape)) 建模工作前的数据处理工作基本就是以上内容，还包括合并三个表、删除不相关字段、添加at_home字段，增加家乡字段信息，可能与是否违约相关。 算法建模 标准化 创建训练集及验证集，并对训练集做标准化处理： 123456from sklearn.preprocessing import StandardScalerX_train = train_master_.drop(['target'], axis=1)X_train = StandardScaler().fit_transform(X_train)y_train = train_master_['target']print(X_train.shape, y_train.shape) 得到训练集及验证集的大小： 1(28074, 443) (28074,) 交叉验证 选择StratifiedKFoldS折交叉验证法，确保训练集中每一类的比例是相同的。 123from sklearn.model_selection import StratifiedKFoldcv = StratifiedKFold(n_splits=3, shuffle=True)#分层采样 分类算法评估 AUC、精确度、召回率： 12345678from sklearn.model_selection import cross_val_scoredef estimate(estimator, name='estimator'): auc = cross_val_score(estimator, X_train, y_train, scoring='roc_auc', cv=cv).mean() accuracy = cross_val_score(estimator, X_train, y_train, scoring='accuracy', cv=cv).mean() recall = cross_val_score(estimator, X_train, y_train, scoring='recall', cv=cv).mean() print("&#123;&#125;: auc:&#123;:f&#125;, recall:&#123;:f&#125;, accuracy:&#123;:f&#125;".format(name, auc, recall, accuracy)) 算法 评估以下分类算法： 线性分类器 LogisticRegression 广义线性分类器 RidgeClassifier 集成方法分类器 RandomForestClassifier、AdaBoostClassifier、XGBClassifier 支持向量机分类器 SVC、LinearSVC 通过评估方法选择分类效果较好的LogisticRegression、XGBClassifier、AdaBoostClassifier三种模型，最终通过投票的方式聚合三种模型。 123456789from sklearn.ensemble import VotingClassifierestimators = []estimators.append(('LogisticRegression', LogisticRegression()))estimators.append(('XGBClassifier', XGBClassifier(learning_rate=0.1, n_estimators=20, objective='binary:logistic')))estimators.append(('AdaBoostClassifier', AdaBoostClassifier()))voting = VotingClassifier(estimators = estimators, voting='soft')estimate(voting, 'voting') 最终达到的效果： 1voting: auc:0.800663, recall:0.001285, accuracy:0.944433]]></content>
  </entry>
  <entry>
    <title><![CDATA[数据分析]]></title>
    <url>%2F2018%2F08%2F12%2F%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%2F</url>
    <content type="text"><![CDATA[背景 在数据分析的路上跌跌撞撞，从一开始实习做Splunk大数据分析，到小论文做时间序列聚类，再到现在为找工作丰富简历做金融项目“魔镜杯”风控算法大赛。这一路上，迂回转折，慢慢明白了，数据分析，是一个大的概念，包含的很多，但是都有一个共同的目标：帮助决策者做出明智的决策。 Splunk: Splunk软件主要用作大数据搜索引擎。 实习做项目的主要流程： 安装软件及配置，包括Enterprise(索引)、转发器以及部署配置，确保分散的数据能集中统一管理。 搜索数据，提取字段。 做一些基础的见解分析，再与客户沟通需求，定制化开发。 完成可视化报表以及告警等其他配套应用。 时间序列聚类： 这是自己小论文做的电力负荷聚类算法研究，通过阅读文献，大致知晓了数据清洗、特征选择、算法研究这些步骤，算法是写论文发表期刊的主要任务。但是，由于学术研究通常面对的数据集都是标准数据集，不存在数据缺失以及噪声的情况，而现实世界里的数据繁杂、缺失、异常随处可见，对数据的预处理以及特征工程反而是比研究算法更为重要的事情。 项目经验 感觉自己整个研究生生涯顺序都是反的，先去了实习，而延误了写论文。先看文献，而后做试验。如果有一次重来的机会，我会先做学术工作，把论文搞定后再去做相关算法的工作，而不是虎头虎脑地去实习。先动手做实验，而不是看文献，还是中文的论文，简直就是垃圾，误导祖国的花朵。目前想找金融方面的数据分析工作，所以在网上找到了2016年拍拍贷“魔镜杯”风控算法大赛的项目。通过学习各位获奖大神的研究现实问题的思路，这才茅塞顿开，豁然开朗，感觉找到了做数据分析的正轨。 数据分析 参考：https://www.cnblogs.com/charlotte77/p/5606926.html 数据分析的常见流程如下： 关键步骤： 数据清洗 特征工程 算法模型 本文主要以2016年拍拍贷主办的“魔镜杯”风控算法大赛项目介绍以上三个步骤，熟悉数据分析的流程。 数据清洗 数据清洗主要包含： 缺失值处理 异常值处理 去重处理 噪音数据处理 为何要数据清洗？ 平常在论文里用到的公开数据集譬如UCI标准数据集都是没有缺失值、异常值、噪音的优质数据。 然而在现实世界里，我们要探索的数据往往都是包含了大量缺失值、噪音的数据，例如，app里一些个人信息，分为标*必填字段，以及非必填字段，那么这样就会存在信息缺失了，同时，部分信息可能因为手工误填而导致出现异常值。而这些低质量的数据会对后序的算法建模产生巨大的影响，直接导致模型的偏差。 所以我们必须要进行数据清洗工作。 缺失值处理 没有高质量的数据，就没有高质量的数据挖掘结果，数据值缺失是数据分析中经常遇到的问题之一。 处理不完整数据集的方法主要有三大类：删除元组、数据补齐、不处理。 删除元组 将存在遗漏信息属性值的对象（元组，记录）删除，从而得到一个完备的信息表。这种方法简单易行，在对象有多个属性缺失值、被删除的含缺失值的对象与初始数据集的数据量相比非常小的情况下非常有效。 缺点：对于小样本数据集，即使删除少量数据也可能严重影响结果的正确性。 数据补齐 用一定的值去填充缺失值，从而使信息表完备化。通常基于统计学原理，根据初始数据集中其余对象取值的分布情况来对一个缺失值进行填充。数据挖掘中常用的有以下几种补齐方法： 人工填写(不可行) 当数据规模很大、空值很多时 特殊值填充(不可行)，该方法耗时耗力，不可行。 将空值作为一种特殊的属性值来处理，它不同于其他的任何属性值。如所有的空值都用“unknown”填充。这样将形成另一个有趣的概念，可能导致严重的数据偏离，一般不推荐使用。 平均值填充 将初始数据集中的属性分为数值属性和非数值属性来分别进行处理。 如果空值是数值型的，就根据该属性在其他所有对象的取值的平均值来填充该缺失的属性值； 如果空值是非数值型的，就根据统计学中的众数原理，用该属性在其他所有对象的取值次数最多的值(即出现频率最高的值)来补齐该缺失的属性值。与其相似的另一种方法叫条件平均值填充法（Conditional Mean Completer）。在该方法中，用于求平均的值并不是从数据集的所有对象中取，而是从与该对象具有相同决策属性值的对象中取得。这两种数据的补齐方法，其基本的出发点都是一样的，以最大概率可能的取值来补充缺失的属性值，只是在具体方法上有一点不同。与其他方法相比，它是用现存数据的多数信息来推测缺失值。 下面举例说明： 1. “年收入”：商品推荐场景下填充平均值，借贷额度场景下填充最小值； “行为时间点”：填充众数； “价格”：商品推荐场景下填充最小值，商品匹配场景下填充平均值； “人体寿命”：保险费用估计场景下填充最大值，人口估计场景下填充平均值； “驾龄”：没有填写这一项的用户可能是没有车，为它填充为0较为合理； ”本科毕业时间”：没有填写这一项的用户可能是没有上大学，为它填充正无穷比较合理； “婚姻状态”：没有填写这一项的用户可能对自己的隐私比较敏感，应单独设为一个分类，如已婚1、未婚0、未填-1。 插补法 随机插补法 从总体中随机抽取某个样本代替缺失样本 多重插补法 通过变量之间的关系对缺失数据进行预测，利用蒙特卡洛方法生成多个完整的数据集，在对这些数据集进行分析，最后对分析结果进行汇总处理 热卡插补 指在非缺失数据集中找到一个与缺失值所在样本相似的样本（匹配样本），利用其中的观测值对缺失值进行插补。 优点：简单易行，准去率较高 - 缺点：变量数量较多时，通常很难找到与需要插补样本完全相同的样本。但我们可以按照某些变量将数据分层，在层中对缺失值实用均值插补 拉格朗日差值法和牛顿插值法 建模法 回归 基于完整的数据集，建立回归方程。对于包含空值的对象，将已知属性值代入方程来估计未知属性值，以此估计值来进行填充。 缺点：当变量不是线性相关时会导致有偏差的估计。 - K最近距离邻法（K-means clustering） 先根据欧式距离或相关分析来确定距离具有缺失数据样本最近的K个样本，将这K个值加权平均来估计该样本的缺失数据。 期望值最大化方法 EM算法是一种在不完全数据情况下计算极大似然估计或者后验分布的迭代算法。在每一迭代循环过程中交替执行两个步骤：E步（Excepctaion step,期望步），在给定完全数据和前一次迭代所得到的参数估计的情况下计算完全数据对应的对数似然函数的条件期望；M步（Maximzation step，极大化步），用极大化对数似然函数以确定参数的值，并用于下步的迭代。算法在E步和M步之间不断迭代直至收敛，即两次迭代之间的参数变化小于一个预先给定的阈值时结束。该方法可能会陷入局部极值，收敛速度也不是很快，并且计算很复杂。 归纳法 - C4.5方法 通过寻找属性间的关系来对遗失值填充。它寻找之间具有最大相关性的两个属性，其中没有遗失值的一个称为代理属性，另一个称为原始属性，用代理属性决定原始属性中的遗失值。这种基于规则归纳的方法只能处理基数较小的名词型属性。 就几种基于统计的方法而言，删除元组法和平均值法差于热卡填充法、期望值最大化方法和多重填充法；回归是比较好的一种方法，但仍比不上hot deck和EM；EM缺少MI包含的不确定成分。值得注意的是，这些方法直接处理的是模型参数的估计而不是空缺值预测本身。它们合适于处理无监督学习的问题，而对有监督学习来说，情况就不尽相同了。譬如，你可以删除包含空值的对象用完整的数据集来进行训练，但预测时你却不能忽略包含空值的对象。另外，C4.5和使用所有可能的值填充方法也有较好的补齐效果，人工填写和特殊值填充则是一般不推荐使用的。 不处理 补齐处理只是将未知值补以我们的主观估计值，不一定完全符合客观事实，在对不完备信息进行补齐处理的同时，我们或多或少地改变了原始的信息系统。而且，对空值不正确的填充往往将新的噪声引入数据中，使挖掘任务产生错误的结果。因此，在许多情况下，我们还是希望在保持原始信息不发生变化的前提下对信息系统进行处理。 不处理缺失值，直接在包含空值的数据上进行数据挖掘的方法包括贝叶斯网络和人工神经网络等。 贝叶斯网络提供了一种自然的表示变量间因果信息的方法，用来发现数据间的潜在关系。在这个网络中，用节点表示变量，有向边表示变量间的依赖关系。贝叶斯网络仅适合于对领域知识具有一定了解的情况，至少对变量间的依赖关系较清楚的情况。否则直接从数据中学习贝叶斯网的结构不但复杂性较高（随着变量的增加，指数级增加），网络维护代价昂贵，而且它的估计参数较多，为系统带来了高方差，影响了它的预测精度。只有当数据集较小或满足某些条件（如多元正态分布）时完全贝叶斯分析才是可行的。 人工神经网络可以有效的对付缺失值，但人工神经网络在这方面的研究还有待进一步深入展开。 映射到高维空间 比如性别，有男、女、缺失三种情况，则映射成3个变量：是否男、是否女、是否缺失。连续型变量也可以这样处理。比如Google、百度的CTR预估模型，预处理时会把所有变量都这样处理，达到几亿维。这样做的好处是完整保留了原始数据的全部信息、不用考虑缺失值、不用考虑线性不可分之类的问题。缺点是计算量大大提升。 而且只有在样本量非常大的时候效果才好，否则会因为过于稀疏，效果很差 异常值处理 异常值通常也称为“离群点”。 发现异常值 画图 简单的统计分析 1data.describe()#pandas的describe()函数 3∂原则 箱型图分析 基于模型检测 首先建立一个数据模型，异常是那些同模型不能完美拟合的对象；如果模型是簇的集合，则异常是不显著属于任何簇的对象；在使用回归模型时，异常是相对远离预测值的对象 优缺点：1.有坚实的统计学理论基础，当存在充分的数据和所用的检验类型的知识时，这些检验可能非常有效；2.对于多元数据，可用的选择少一些，并且对于高维数据，这些检测可能性很差。 基于距离 通常可以在对象之间定义邻近性度量，异常对象是那些远离其他对象的对象 优缺点：1.简单；2.缺点：基于邻近度的方法需要O(m2)时间，大数据集不适用；3.该方法对参数的选择也是敏感的；4.不能处理具有不同密度区域的数据集，因为它使用全局阈值，不能考虑这种密度的变化。 基于密度 当一个点的局部密度显著低于它的大部分近邻时才将其分类为离群点。适合非均匀分布的数据。 优缺点：1.给出了对象是离群点的定量度量，并且即使数据具有不同的区域也能够很好的处理；2.与基于距离的方法一样，这些方法必然具有O(m2)的时间复杂度。对于低维数据使用特定的数据结构可以达到O(mlogm)；3.参数选择困难。虽然算法通过观察不同的k值，取得最大离群点得分来处理该问题，但是，仍然需要选择这些值的上下界。 基于聚类 基于聚类的离群点：一个对象是基于聚类的离群点，如果该对象不强属于任何簇。离群点对初始聚类的影响：如果通过聚类检测离群点，则由于离群点影响聚类，存在一个问题：结构是否有效。为了处理该问题，可以使用如下方法：对象聚类，删除离群点，对象再次聚类（这个不能保证产生最优结果）。 优缺点：1.基于线性和接近线性复杂度（k均值）的聚类技术来发现离群点可能是高度有效的；2.簇的定义通常是离群点的补，因此可能同时发现簇和离群点；3.产生的离群点集和它们的得分可能非常依赖所用的簇的个数和数据中离群点的存在性；4.聚类算法产生的簇的质量对该算法产生的离群点的质量影响非常大。 异常值处理 删除异常值 明显看出是异常且数量较少可以直接删除 不处理 如果算法对异常值不敏感则可以不处理，但如果算法对异常值敏感，则最好不要用，如基于距离计算的一些算法，包括kmeans，knn之类的。 平均值替代 损失信息小，简单高效。 视为缺失值 可以按照处理缺失值的方法来处理]]></content>
      <categories>
        <category>数据分析</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[SQL]]></title>
    <url>%2F2018%2F08%2F07%2FMySQL%2F</url>
    <content type="text"><![CDATA[参考：http://www.runoob.com/sql/sql-syntax.html 数据仓库 四个特点 面向主题 操作型数据库的数据组织面向事务处理任务，各个业务系统之间各自分离，而数据仓库中的数据是按照一定的主题域进行组织。主题是一个抽象的概念，是指用户使用数据仓库进行决策时所关心的重点方面，一个主题通常与多个操作型信息系统相关。 集成的 面向事务处理的操作型数据库通常与某些特定的应用相关，数据库之间相互独立，并且往往是异构的。而数据仓库中的数据是在对原有分散的数据库数据抽取、清理的基础上经过系统加工、汇总和整理得到的，必须消除源数据中的不一致性，以保证数据仓库内的信息是关于整个企业的一致的全局信息。 相对稳定的 操作型数据库中的数据通常实时更新，数据根据需要及时发生变化。数据仓库的数据主要供企业决策分析之用，所涉及的数据操作主要是数据查询，一旦某个数据进入数据仓库以后，一般情况下将被长期保留，也就是数据仓库中一般有大量的查询操作，但修改和删除操作很少，通常只需要定期的加载、刷新。 反映历史变化 操作型数据库主要关心当前某一个时间段内的数据，而数据仓库中的数据通常包含历史信息，系统记录了企业从过去某一时点(如开始应用数据仓库的时点)到目前的各个阶段的信息，通过这些信息，可以对企业的发展历程和未来趋势做出定量分析和预测。 常用模型 维度模型 星型模型 雪花模型 星座模型 关系模型 范式建模 数据库基础 数据库操作语言(Data Manipulation Language, DML) 它们是SELECT、UPDATE、INSERT、DELETE，就象它的名字一样，这4条命令是用来对数据库里的数据进行操作的语言。 数据库定义语言(Data Definition Language, DDL) DDL比DML要多，主要的命令有CREATE、ALTER、DROP、TRUNCATE等，DDL主要是用在定义或改变表（TABLE）的结构，数据类型，表之间的链接和约束等初始化工作上，他们大多在建立表时使用。 数据库控制语言(Data Control Language, DCL) 用来设置或更改数据库用户或角色权限的语句，包括（grant,deny,revoke等）语句。在默认状态下，只有sysadmin,dbcreator,db_owner或db_securityadmin等人员才有权力执行DCL语句。 查询筛选 题目： 筛选出人口数量大于25000000的国家，并显示他们的所有信息。 表World: name continent area population gdp Afghanistan Asia 652230 25500100 20343000 Albania Europe 28748 2831741 12960000 Algeria Africa 2381741 37100000 188681000 Andorra Europe 468 78115 3712000 Angola Africa 1246700 20609294 100990000 通过SQL查询语句 123SELECT name, population, areaFROM WorldWHERE population &gt; 25000000 得到查询结果： name population area Afghanistan 25500100 652230 Algeria 37100000 2381741 处理重复数据 找出重复项 题目： 选出重复邮件。 表Person: Id Email 1 a@b.com 2 c@d.com 3 a@b.com SQL语句： 1234select Emailfrom Persongroup by Emailhaving count(*) &gt; 1 得到： Email a@b.com 删除重复项 题目： 删除重复的电子邮箱。 表Person:（Id 是这个表的主键） Id Email 1 john@example.com 2 bob@example.com 3 john@example.com SQL语句： 123DELETE p1FROM Person p1, Person p2WHERE p1.Email = p2.Email AND p1.Id &gt; p2.Id 得到： Id Email 1 john@example.com 2 bob@example.com 排序 题目： 筛选出id为奇数且描述为不无聊的，按照评分由高到低。 表 cinema: id movie description rating 1 War great 3D 8.9 2 Science fiction 8.5 3 irish boring 6.2 4 Ice song Fantacy 8.6 5 House card Interesting 9.1 SQL语句： 1234SELECT *FROM cinemaWHERE (id % 2 = 1) AND (description &lt;&gt; &apos;boring&apos;)#&lt;&gt;不等于，筛选条件有歧义一定要加括号ORDER BY rating DESC 结果： id movie description rating 5 House card Interesting 9.1 1 War great 3D 8.9 更新表 题目： 将sex互换。 表salary: id name sex salary 1 A m 2500 2 B f 1500 3 C m 5500 4 D f 500 SQL语句： 12UPDATE salary SET sex= CHAR(ASCII(&apos;f&apos;)+ASCII(&apos;m&apos;)-ASCII(sex)); id name sex salary 1 A f 2500 2 B m 1500 3 C f 5500 4 D m 500 删除 DELETE、DROP、TRUNCATE都可以删除表内的数据。 不同的是： TRUNCATE和DELETE只删除数据不删除表的结构 DROP语句将删除表的结构，被依赖的约束(constrain)、触发器(trigger)、索引(index)；依赖于该表的存储过程/函数将保留,但是变为 invalid 状态。 DELETE是DML语句，DROP和TRUNCATE是DDL语句 DELETE语句是数据库操作语言(DML),这个操作会放到 rollback segement 中，事务提交之后才生效；如果有相应的 trigger，执行的时候将被触发。 DROP和TRUNCATE是数据库定义语言(DDL),操作立即生效，原数据不放到 rollback segment 中，不能回滚，操作不触发 trigger。 DELETE语句不会自动提交，DROP和TRUNCATE执行后会自动提交，所以要小心使用DROP和TRUNCATE语句。 速度：DROP&gt; TRUNCATE &gt; DELETE DELETE DELETE语句是DML语句，不会自动提交，万一操作失误，还可以通过回滚恢复数据。 不带WHERE子句的DELETE语句与TRUNCATE的功能相同，两者都是删除表中的全部行，但是TRUNCATE TABLE比DELETE速度快，且使用的系统和事务日志资源少。DELETE语句每次删除一行，并在事务日志中为所删除的每行记录一项。TRUNCATE TABLE通过释放存储表数据所用的数据页来删除数据，并且只在事务日志中记录页的释放。 DROP drop 语句将表所占用的空间全部释放。 drop 语句将删除表的结构被依赖的约束(constrain)、触发器(trigger)、索引(index)；依赖于该表的存储过程/函数将保留,但是变为 invalid 状态。 TRUNCATE TRUNCATE TABLE删除表中的所有行，但表结构及其列、约束、索引等保持不变。新行标识所用的计数值重置为该列的种子。如果想保留标识计数值，请改用DELETE。如果要删除表定义及其数据，请使用DROP TABLE 语句。 TRUNCATE TABLE删除表中的所有行，但表结构及其列、约束、索引等保持不变。新行标识所用的计数值重置为该列的种子。如果想保留标识计数值，请改用DELETE。如果要删除表定义及其数据，请使用DROP TABLE 语句。 连接 等值连接 在连接条件中使用等于号(=)运算符比较被连接列的列值，其查询结果中列出被连接表中的所有列，包括其中的重复列。 不等值连接 在连接条件使用除等于运算符以外的其它比较运算符比较被连接的列的列值。这些运算符包括&gt;、&gt;=、&lt;=、&lt;、!&gt;、!&lt;和&lt;&gt;。 自然连接 在连接条件中使用等于(=)运算符比较被连接列的列值，但它使用选择列表指出查询结果集合中所包括的列，并删除连接表中的重复列。 示例： book表： id bookname sutid 1 python编程 1 2 sql编程 2 3 winform 3 4 web教程 4 6 前端教程 10 stu表： sutid stuname 1 张三 2 李四 3 王五 4 任六 5 赵七 内连接 内连接查询操作列出与连接条件匹配的数据行，它使用比较运算符比较被连接列的列值。 123select * from book as a,stu as b where a.sutid = b.stuidselect * from book as a inner join stu as b on a.sutid = b.stuid id bookname sutid sutid stuname 1 python编程 1 1 张三 2 sql编程 2 2 李四 3 winform 3 3 王五 4 web教程 4 4 任六 外连接 左连接 以左表为基准，将a.stuid = b.stuid的数据进行连接，然后将左表没有的对应项显示，右表的列为NULL 1select * from book as a left join stu as b on a.sutid = b.stuid id bookname sutid sutid stuname 1 python编程 1 1 张三 2 sql编程 2 2 李四 3 winform 3 3 王五 4 web教程 4 4 任六 6 前端教程 10 NULL NULL 右连接 以右表为基准，将a.stuid = b.stuid的数据进行连接，然以将右表没有的对应项显示，左表的列为NULL 1select * from book as a right join stu as b on a.sutid = b.stuid id bookname sutid sutid stuname 1 python编程 1 1 张三 2 sql编程 2 2 李四 3 winform 3 3 王五 4 web教程 4 4 任六 NULL NULL NULL 5 赵七 全连接 完整外部联接返回左表和右表中的所有行。当某行在另一个表中没有匹配行时，则另一个表的选择列表列包含空值。如果表之间有匹配行，则整个结果集行包含基表的数据值。 1select * from book as a full outer join stu as b on a.sutid = b.stuid id bookname sutid sutid stuname 1 python编程 1 1 张三 2 sql编程 2 2 李四 3 winform 3 3 王五 4 web教程 4 4 任六 6 前端教程 10 NULL NULL NULL NULL NULL 5 赵七]]></content>
  </entry>
  <entry>
    <title><![CDATA[Python]]></title>
    <url>%2F2018%2F08%2F06%2FPython%2F</url>
    <content type="text"><![CDATA[本文主要用于记录LeetCode中遇到的比较好的一些python写法以及招聘笔试面试中遇到的问题。 self参数 在python的类的方法定义中，请描述’self’参数的作用？ self参数在类定义中，指类本身，可以用来传递外部参数。 math库 log函数 描述： log()返回 x 的自然对数。 语法： 123import mathmath.log(x[, base]) 参数： x – 数值表达式。 base – 可选，底数，默认为 e。 返回值： 返回 x 的自然对数，x&gt;0。 实例： 1234import mathprint "math.log(10,2) : ", math.log(10,2)#相当于log_2(10)》3.32192809489 sum函数 描述： sum() 方法对系列进行求和计算。 语法: sum(iterable[, start]) 参数: iterable – 可迭代对象，如：列表、元组、集合。 start – 指定相加的参数，如果没有设置这个值，默认为0。 返回值: 返回计算结果。 实例: 12345678sum([0,1,2])3sum((2, 3, 4), 1)10sum([0,1,2,3,4], 2) 12 常见用法： 将程序变得更pythic，以171.Excel表列序号为例： 常规 1234res = 0 for index in range(len(s)): res += (26 ** (len(s) - index - 1)) * (ord(s[index]) - ord('A') + 1) return res sum() 1return sum((26 ** (len(s) - index - 1)) * (ord(s[index]) - ord('A') + 1) for index in range(len(s))) 把每次迭代的结果以sum的方式一次性取和。 ord函数 描述： 它以一个字符（长度为1的字符串）作为参数，返回对应的 ASCII 数值，或者 Unicode 数值，如果所给的 Unicode 字符超出了你的 Python 定义范围，则会引发一个 TypeError 的异常。 语法： 1ord(c) 参数： c – 字符 返回值： 返回值是对应的十进制整数。 实例： 123456ord('a')》97ord('b')》98ord('c')》99 排序 数组倒序 123a = [1, 2, 3, 4, 5]a[::-1]》[5, 4, 3, 2, 1] sort函数 sort()是Python列表(仅适用于列表)的一个内置的排序方法，list.sort()方法排序时直接修改原列表，返回None； 语法： 1list.sort(*, key=None, reverse=None) 参数： key 带一个参数的函数，返回一个值用来排序，默认为 None reverse 表示排序结果是否反转，默认是升序 实例： 123456a=['1',1,'a',3,7,'n']print a.sort()》Nonea》[1, 3, 7, '1', 'a', 'n'] sorted函数 sorted()是迭代器(不仅针对列表)的排序方法，可以保留原列表，返回新列表。 语法： 1sorted(iterable[, key][, reverse]) 参数： key 带一个参数的函数，返回一个值用来排序，默认为 None reverse 表示排序结果是否反转 实例： 123a = (1,2,4,2,3)print(sorted(a))》[1, 2, 2, 3, 4] set 数据类型set是一个无序不重复元素集。 基本功能包括关系测试和消除重复元素。 集合对象支持联合、交、差和对称差集等数学运算。 支持： x in set len(set) for x in set 不支持： indexing slicing 其它类序列（sequence-like）的操作 元素集合 1234x = set('spam')y = set(['h','a','m'])x, y》(set(['a', 'p', 's', 'm']), set(['a', 'h', 'm'])) 交集 1234x = set('spam')y = set(['h','a','m'])x &amp; y》set(['a', 'm']) 交集 12345x = set('spam')y = set(['h','a','m'])x | yx.union(y)》set(['a', 'p', 's', 'h', 'm']) 差集 1234x = set('spam')y = set(['h','a','m'])x - y # 差集 在x中但不在y中》set(['p', 's']) 对称差集 1234x = set('spam')y = set(['h','a','m'])x ^ y #对称差集 在x或y中，但不会同时出现在二者中》set(['p', 's']) 去除重复元素 123456x = set('spam')y = set(['h','a','m'])#去除重复元素：a = [11,22,33,44,11,22]set(a)》set([33, 11, 44, 22]) 添加元素 12345# 添加一项x.add(&apos;x&apos;)# 添加多项x.update([10,37,42]) 删除元素 123456789#删除一项x.remove(&apos;H&apos;) #如果不存在就报错x.discard(&apos;H&apos;) #存在就删除# 删除 set 中的所有元素x.clear()# 删除并且返回 set “s”中的一个不确定的元素, 如果为空则报错s.pop() set 的长度 1len(x) 关系测试 12345678910s in x # 测试 s 是否是 x 的成员s not in x # 测试 s 是否不是 x 的成员s.issubset(t) #测试是否 s 中的每一个元素都在 t 中s &lt;= ts.issuperset(t) # 测试是否 t 中的每一个元素都在 s 中s &gt;= ts.copy() # 返回 set “s”的一个浅复制 zip函数 描述： 从参数中的多个迭代器取元素组合成一个新的迭代器。 语法： 1zip(iterable,[iterable...]) 注意： 当有多个参数时，zip(a,b)中a和b的维数相同，若不相同时，取最小的维数进行组合。 参数： 一个或多个迭代器，例如，元组、列表、字典等。 返回值： 返回一个zip对象，其内部元素为元组； 可以转化为元组、列表、字典 实例： 单个参数 123456list1 = [1, 2, 3, 4]tuple1 = zip(list1)print("zip()函数的返回类型：\n", type(tuple1))》&lt;class 'zip'&gt; print("zip对象转化为列表：\n", list(tuple1))》[(1,), (2,), (3,), (4,)] 多个参数 123456789m = [[1,2,3], [4,5,6], [7,8,9]] n = [[2,2,2], [3,3,3], [4,4,4]] p = [[2,2,2], [3,3,3,]list(zip(m, n))》[([1, 2, 3], [2, 2, 2]), ([4, 5, 6], [3, 3, 3]), ([7, 8, 9], [4, 4, 4])]list(zip(m, p))》[([1, 2, 3], [2, 2, 2]), ([4, 5, 6], [3, 3, 3])] *zip(*iterables) 描述： *zip()函数是zip()函数的逆过程，将zip对象变成原先组合前的数据。 实例： 1234567m = [[1, 2, 3], [4, 5, 6], [7, 8, 9]]n = [[2, 2, 2], [3, 3, 3], [4, 4, 4]]m2, n2 = zip(*zip(m, n))m2》[[1, 2, 3], [4, 5, 6], [7, 8, 9]]n2》[[2, 2, 2], [3, 3, 3], [4, 4, 4]] zip(*) 12p = [[1,2,3],[4,5,6]]zip(*p)# 等价于zip([1,2,3],[4,5,6])，相当于把p最外层的[]给去掉了 sys模块 sys.stdin 标准输入： stdin获得输入(用input()输入的通过它获得) readline() 每次读取一整行，包括 “\n” 字符。 readlines() 读取所有行并返回列表,包括 “\n” 字符。 sys.stdout stdout用于输出print()和expression语句以及input()的提示。 print()的本质就是sys.stdout.write(object + ‘\n’) 删除指定字符 strip函数 移除字符串头尾指定的字符（默认为空格或换行符）或字符序列。 注意：该方法只能删除开头或是结尾的字符，不能删除中间部分的字符。 语法： 1str.strip([chars]) 参数: chars:移除字符串头尾指定的字符序列。 返回值: 返回移除字符串头尾指定的字符生成的新字符串。 实例： 123456789# 去除首尾字符 0str = "00000003210Runoob01230000000";print(str.strip('0'))》3210Runoob0123# 去除首尾空格str2 = " Runoob "print(str2.strip())》Runoob replace函数 实则为替代函数，但也非常方便实施删除指定元素。 语法： 1str.replace(old, new[, max]) 参数： old – 将被替换的子字符串。 new – 新字符串，用于替换old子字符串。 max – 可选字符串, 替换不超过 max 次 返回值： 返回字符串中的 old（旧字符串） 替换成 new(新字符串)后生成的新字符串，如果指定第三个参数max，则替换不超过 max 次。 实例： 123456789101112#展示替换功能str = &quot;this is string example....wow!!! this is really string&quot;;print str.replace(&quot;is&quot;, &quot;was&quot;);print str.replace(&quot;is&quot;, &quot;was&quot;, 3);》thwas was string example....wow!!! thwas was really stringthwas was string example....wow!!! thwas is really string#展示删除功能str = &quot;test.email+alex@leetcode.com&quot;print(str.replace(&apos;.&apos;, &apos;&apos;))》testemail+alex@leetcode.com functools库 map函数 描述： map()会根据提供的函数对指定序列做映射。 语法： 1map(function, iterable, ...) 参数: function – 函数，有两个参数 iterable – 一个或多个序列 返回值： Python 3.x 返回迭代器。 实例： 123456789101112def square(x) : # 定义计算平方数的函数 return x ** 2 map(square, [1,2,3,4,5]) # 计算列表各个元素的平方》[1, 4, 9, 16, 25]map(lambda x: x ** 2, [1, 2, 3, 4, 5]) # 使用 lambda 匿名函数》[1, 4, 9, 16, 25]# 提供了两个列表，对相同位置的列表数据进行相加map(lambda x, y: x + y, [1, 3, 5, 7, 9], [2, 4, 6, 8, 10])[3, 7, 11, 15, 19] 总结： map(function, iterable, …) 相当于[f(x) for x in list] reduce函数 对参数序列中的元素进行累积。 将序列中的第一个元素与第二个元素进行操作，得到的结果再与第三个元素进行运算。 语法： 1reduce(function, iterable[, initializer]) 参数： function – 函数，有两个参数 iterable – 可迭代对象 initializer – 可选，初始参数 返回值： 返回函数计算结果。 实例： 123456#实现数组内所有元素相乘from functools import reducelist_3 = [3, 3, 3, 3, 2]print(reduce(lambda a, b: a * b, list_3))》162]]></content>
  </entry>
  <entry>
    <title><![CDATA[TensorFlow]]></title>
    <url>%2F2018%2F08%2F01%2F%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%85%A5%E9%97%A8%2F</url>
    <content type="text"><![CDATA[TensorFlow是一个机器学习框架，它提供了一门机器学习速成课程。 官方网址：https://developers.google.cn/machine-learning/crash-course/ 本文按照谷歌提供的机器学习速成课程记录学习笔记。 线性回归 基本概念 下图展示了蟋蟀每分钟的鸣叫声与温度（摄氏度）的关系。 为了清楚地显示鸣叫声与温度之间的关系，创建公式： $$y=mx+b$$ 其中： $y$:指的是温度（以摄氏度表示），即我们试图预测的值。 $m$:指的是直线的斜率。 $x$:指的是每分钟的鸣叫声次数，即输入特征的值。 $b$:指的是 y 轴截距。 将上面代数公式，转换为机器学习样式的方程： $$y^{’}=b+w_{1}x_{1}$$ 其中： $y_{’}$:指的是预测标签（理想输出值）。 $b$:指的是偏差（y 轴截距）。而在一些机器学习文档中，它称为 。 $w_{1}$:指的是特征 1 的权重。权重与上文中用 表示的“斜率”的概念相同。 $x_{1}$:指的是特征（已知输入项）。 延伸到多个特征的情况： $$y^{’}=b+w_{1}x_{1}+w_{2}x_{2}+w_{3}x_{3}$$ 损失 平方损失 平方损失又叫$L_{2}$损失。 红色箭头表示损失 蓝线表示预测 单个样本的平方损失：$${ \left( y-{ y }^{ ’ } \right) }^{ 2 }$$ 均方误差 均方误差 (MSE) 指的是每个样本的平均平方损失。 $$MSE=\frac{1}{N} \sum_{(x,y) \in D} {(y-prediction(x))^{2}}$$ 其中： $(x,y)$指的是样本，其中: $x$指的是模型进行预测时使用的特征集（例如，温度、年龄和交配成功率。 $y$指的是样本的标签(例如，每分钟的鸣叫次数)。 $prediction(x)$指的是权重和偏差与特征集$x$结合的函数。 $D$指的是包含多个有标签样本(即$(x,y)$)的数据集。 $N$指的是$D$中的样本数量。 虽然 MSE 常用于机器学习，但它既不是唯一实用的损失函数，也不是适用于所有情形的最佳损失函数。 降低损失 迭代方法 下图显示了机器学习算法用于训练模型的迭代试错过程： 我们应该为$b$和$w_{1}$设置哪些初始值？ $$y^{’}=b+w_{1}x_{1}$$ 通过迭代方式来降低损失，就是不停的试错，直到得到损失最小的模型。 梯度下降法 根据迭代算法的思想，计算$w_{1}$所有可能值的损失。 损失与$w_{1}$的图形始终是凸形的，随着$w_{1}$的增大，损失从大变小，再变大的一个过程。 凸形问题只有一个最低点；即只存在一个斜率正好为 0 的位置。这个最小值就是损失函数收敛之处。 通过计算整个数据集中 每个可能值的损失函数来找到收敛点这种方法效率太低。 我们来研究一种更好的机制，这种机制在机器学习领域非常热门，称为梯度下降法。 梯度下降法算法会沿着负梯度的方向走一步，以便尽快降低损失。 梯度矢量具有方向和大小。梯度下降法算法用梯度乘以一个称为学习速率（有时也称为步长）的标量，以确定下一个点的位置。 如果您选择的学习速率过小，就会花费太长的学习时间。 相反，如果您指定的学习速率过大，下一个点将永远在 U 形曲线的底部随意弹跳，就好像量子力学实验出现了严重错误一样。 随机梯度下降法 在梯度下降法中，批量指的是用于在单次迭代中计算梯度的样本总数。到目前为止，我们一直假定批量是指整个数据集。就 Google 的规模而言，数据集通常包含数十亿甚至数千亿个样本。此外，Google 数据集通常包含海量特征。因此，一个批量可能相当巨大。如果是超大批量，则单次迭代就可能要花费很长时间进行计算。 包含随机抽样样本的大型数据集可能包含冗余数据。实际上，批量大小越大，出现冗余的可能性就越高。一些冗余可能有助于消除杂乱的梯度，但超大批量所具备的预测价值往往并不比大型批量高。 如果我们可以通过更少的计算量得出正确的平均梯度，会怎么样？通过从我们的数据集中随机选择样本，我们可以通过小得多的数据集估算（尽管过程非常杂乱）出较大的平均值。 随机梯度下降法 (SGD) 将这种想法运用到极致，它每次迭代只使用一个样本（批量大小为 1）。如果进行足够的迭代，SGD 也可以发挥作用，但过程会非常杂乱。“随机”这一术语表示构成各个批量的一个样本都是随机选择的。 小批量随机梯度下降法（小批量 SGD）是介于全批量迭代与 SGD 之间的折衷方案。小批量通常包含 10-1000 个随机选择的样本。小批量 SGD 可以减少 SGD 中的杂乱样本数量，但仍然比全批量更高效。 TF的基本介绍 TensorFlow工具包层次结构： 不同层的用途： 工具包 说明 Estimator (tf.estimator) 高级 OOP API tf.layers/tf.losses/tf.metrics 用于常见模型组件的库 TensorFlow 低级 API TensorFlow 由以下两个组件组成： 图协议缓冲区 执行（分布式）运行 这两个组件类似于 Java 编译器和 JVM。正如 JVM 会实施在多个硬件平台（CPU 和 GPU）上一样，TensorFlow 也是如此。 tf.estimator API tf.estimator API是TF的高级API，代码行数少，易于使用，但是设计不够灵活。 tf.estimator 与 scikit-learn API 兼容。 本文中主要使用tf.estimator API学习TensorFlow。]]></content>
      <tags>
        <tag>TensorFlow</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Git问题备忘]]></title>
    <url>%2F2018%2F05%2F29%2FGit%E9%97%AE%E9%A2%98%E5%A4%87%E5%BF%98%2F</url>
    <content type="text"><![CDATA[更新本地库 在LeetCode上，每做完一道题目，为方便后续回顾，同步远程Github。 123git add 需要同步的文件git commit -m &quot;备注&quot;git push -u origin master 远程仓库与本地仓库冲突 由于在远程仓库创建过新文件，导致与本地仓库版本冲突无法合并： 12345678$ git push origin masterTo github.com:sunflowerJY/LeetCode.git ! [rejected] master -&gt; master (non-fast-forward)error: failed to push some refs to &apos;git@github.com:sunflowerJY/LeetCode.git&apos;hint: Updates were rejected because the tip of your current branch is behindhint: its remote counterpart. Integrate the remote changes (e.g.hint: &apos;git pull ...&apos;) before pushing again.hint: See the &apos;Note about fast-forwards&apos; in &apos;git push --help&apos; for details. 解决方案： http://www.cnblogs.com/daemon369/p/3204646.html]]></content>
      <categories>
        <category>教程</category>
      </categories>
      <tags>
        <tag>Git</tag>
        <tag>Github</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[优化Next主题博客]]></title>
    <url>%2F2018%2F05%2F15%2F%E4%BC%98%E5%8C%96Next%E4%B8%BB%E9%A2%98%E5%8D%9A%E5%AE%A2%2F</url>
    <content type="text"><![CDATA[在上篇博文中已经搭建好一个基础的可用的博客了，但是热爱折腾的我们怎么可能就此满足😎此文将介绍我的博客折腾之路~ 环境 系统：Win10 64位 Git: 2.17.0.windows.1 Node.js: 8.11.1 npm: 5.6.0 Hexo: 3.7.1 Next: 5.1.4 Next主题 选择一个自己可心的主题，会增强更博的动力哟😜 下载Next主题 在Git bash终端执行以下命令： 1git clone https://github.com/iissnan/hexo-theme-next themes/next 本文使用的是Next: 5.1.4，目前已经更新至6.0,由于自己还是新手，基本搭建过程都是参考大神博客的，所以以后熟练了再更新吧😂 下载成功后可以在本地博客站点的主题文件夹/themes中除了默认的landscape文件夹，还多了一个next文件夹。 使用Hexo搭建博客时，由于在多个文件夹中存放了_config.yml配置文件，为表述方便，规定： 1.站点配置文件：sunflowerJY.github.io/_config.yml 2.主题配置文件：sunflowerJY.github.io/themes/next/_config.yml 启用Next主题 打开站点配置文件，找到theme字段，并将其值更改为 next。 1theme: next 预览Next风格的本地博客 在Git bash终端执行： 1hexo s 不知为何，我的hexo命令在站点文件夹以外的目录使用会报错找不到该命令，故我都会在站点根目录执行上述命令。 在浏览器中访问 http://localhost:4000/ 便可预览本地博客效果。❤️ 修改Next主题的Scheme Next主题的默认Scheme是Muse,效果如先上图。本博客使用的是Pisces，编辑主题配置文件中的Scheme字段修改Next主题的风格： 1scheme: Pisces 修改网站的基本信息 修改站点配置文件： 12345678# Sitetitle: 向日葵的自留地subtitle:description:keywords:author: sunflowerJYlanguage: zh-hans #汉语timezone: 修改微博底部添加访客数 themes/next/layout/_partials/footer.swig删除多余信息，保留如下信息： 12345678910111213141516171819202122&lt;div class=&quot;copyright&quot;&gt;&#123;##&#125;&#123;% set current = date(Date.now(), &quot;YYYY&quot;) %&#125;&#123;##&#125;&amp;copy; &#123;% if theme.footer.since and theme.footer.since != current %&#125;&#123;&#123; theme.footer.since &#125;&#125; &amp;mdash; &#123;% endif %&#125;&#123;##&#125;&lt;span itemprop=&quot;copyrightYear&quot;&gt;&#123;&#123; current &#125;&#125;&lt;/span&gt; &lt;span class=&quot;with-love&quot;&gt; &lt;i class=&quot;fa fa-&#123;&#123; theme.footer.icon &#125;&#125;&quot;&gt;&lt;/i&gt; &lt;/span&gt; &lt;span class=&quot;author&quot; itemprop=&quot;copyrightHolder&quot;&gt;&#123;&#123; theme.footer.copyright || config.author &#125;&#125;&lt;/span&gt; &#123;% if theme.post_wordcount.totalcount %&#125; &lt;span class=&quot;post-meta-divider&quot;&gt;|&lt;/span&gt; &lt;span class=&quot;post-meta-item-icon&quot;&gt; &lt;i class=&quot;fa fa-area-chart&quot;&gt;&lt;/i&gt; &lt;/span&gt; &#123;% if theme.post_wordcount.item_text %&#125; &lt;span class=&quot;post-meta-item-text&quot;&gt;&#123;&#123; __(&apos;post.totalcount&apos;) &#125;&#125;&amp;#58;&lt;/span&gt; &#123;% endif %&#125; &lt;span title=&quot;&#123;&#123; __(&apos;post.totalcount&apos;) &#125;&#125;&quot;&gt;&#123;# #&#125;&#123;&#123; totalcount(site, &apos;0,0.0a&apos;) &#125;&#125;&#123;# #&#125;&lt;/span&gt; &#123;% endif %&#125;&lt;/div&gt; 在上面copyright代码前添加： 1&lt;script async src=&quot;https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js&quot;&gt;&lt;/script&gt; 在最后添加： 12345&lt;div class=&quot;powered-by&quot;&gt;&lt;i class=&quot;fa fa-user-md&quot;&gt;&lt;/i&gt;&lt;span id=&quot;busuanzi_container_site_uv&quot;&gt; 本站访客数:&lt;span id=&quot;busuanzi_value_site_uv&quot;&gt;&lt;/span&gt;&lt;/span&gt;&lt;/div&gt; 添加头像 修改主题配置文件中的avatar,值设置为头像的链接： 1234# Sidebar Avatar# in theme directory(source/images): /images/avatar.gif# in site directory(source/uploads): /uploads/avatar.gif（新建 uploads 目录若不存在）avatar: /images/avatar.jpg 配置完成部署更新后便可以在HOME页看到自己的头像啦😃 设置网站图标 将图片在ico图片生成网站上分别生成16x16和32x32的图表，并改名为favicon-16x16-sunflower.ico和favicon-32x32-sunflower.ico，并放到/themes/next/source/images中，修改主题配置文件的small和medium字段： 1234567favicon: small: /images/favicon-16x16-sunflower.ico medium: /images/favicon-32x32-sunflower.ico apple_touch_icon: /images/apple-touch-icon-next.png safari_pinned_tab: /images/logo.svg #android_manifest: /images/manifest.json #ms_browserconfig: /images/browserconfig.xml 效果如图： 添加动态背景 Next主题版本》=5.1.1可以直接在主题配置文件修改： 12# Canvas-nestcanvas_nest: true 添加顶部加载条 修改主题配置文件将pace: false改为pace: true，还可以换不同风格的加载条： 添加分类和标签 分类(Categories)和标签(tags)能够很好得将博客文章进行分类管理，方便查阅归类。 添加分类 在博客文件夹下，执行： 1hexo new page categories 自动在/source/categories/文件下创建index.md文件: 1234 ---title: 分类date: 2018-05-15 15:39:08--- 如果有集成评论服务，分类页面也会带有评论。 若需要关闭的话，请添加字段 comments 并将值设置为 false，修改后的index.md： 123456---title: 分类date: 2018-05-15 15:39:08type: &quot;categories&quot;comments: false--- 修改菜单： 在菜单中添加链接。编辑主题配置文件， 添加categories到menu中，如下: 1234menu: home: / archives: /archives categories: /categories 添加标签 在博客文件夹下，执行： 1hexo new page tags 自动在/source/tags/文件下创建index.md文件: 1234 ---title: 标签date: 2018-05-15 15:39:08--- 如果有集成评论服务，标签页面也会带有评论。 若需要关闭的话，请添加字段 comments 并将值设置为 false，修改后的index.md： 123456---title: 标签date: 2018-05-15 15:39:08type: &quot;tags&quot;comments: false--- 修改菜单： 在菜单中添加链接。编辑主题配置文件， 添加tags到menu中，如下: 1234menu: home: / archives: /archives categories: /tags 修改标签图标 Next主题中设置了标签后，默认在文章最底部显示#，后面接文章所有的标签。总是觉得#这个标识丑丑的😂😂😂还是改一下吧 修改/themes/next/layout/_macro/post.swig：搜索rel=&quot;tag&quot;&gt;#,将#换成&lt;i class=&quot;fa fa-tag&quot;&gt;&lt;/i&gt;，效果图： 添加本地搜索 安装hexo-generator-searchdb，在站点的根目录下执行以下命令： 1npm install hexo-generator-search --save 编辑站点配置文件，新增以下内容到任意位置： 12345search: path: search.xml field: post format: html limit: 10000 编辑主题配置文件，启用本地搜索功能： 1234local_search: enable: true trigger: auto top_n_per_article: 1 修改首页摘要 修改主题配置文件： 123auto_excerpt: enable: true length: 150 修改文内链接式样 在/themes/next/source/css/_common/components/post/post.styl文末添加： 1234567891011// 文章内链接文本样式.post-body p a&#123; color: #FF6600; border-bottom: none; border-bottom: 1px solid #FF6600; &amp;:hover &#123; color: #FF6600; border-bottom: none; border-bottom: 1px solid #FF6600; &#125;&#125; 其中，.post-body是为了不影响标题，选择p是为了不影响首页“阅读全文”的显示样式,颜色可以自己定义，效果如图： 添加emoji表情包 把原来的hexo渲染换成基于markdown-it的渲染: 12npm un hexo-renderer-marked --savenpm i hexo-renderer-markdown-it --save 在站点根目录node_modules\hexo-renderer-markdown-it\下安装markdown-it-emoji插件： 1npm install markdown-it-emoji --save 编辑站点配置文件，添加如下内容： 12345678910111213141516171819202122# markdown-it配置emoji表情包markdown: render: html: true xhtmlOut: false breaks: true linkify: true typographer: true quotes: &apos;“”‘’&apos; plugins: - markdown-it-abbr - markdown-it-footnote - markdown-it-ins - markdown-it-sub - markdown-it-sup - markdown-it-emoji #用emoji插件 anchors: level: 1 collisionSuffix: &apos;v&apos; permalink: true permalinkClass: header-anchor permalinkSymbol: &apos;&apos; 然后就可以在写博的时候加上emoji表情啦😄 添加评论系统 最新战况： 2019年11月25日，还是用Valine评论系统，参考了各位大神的博客，使用valine-admin成功实现评论邮件提示功能。所以请直接跳转到添加Valine评论系统😁 2019年7月3日再次更换评论系统，配置了Valine根本不起作用，开源的东西太不稳定了吧😩 参考BlueLzy切换到Gitalk评论系统。 添加Gitalk评论系统 2019年7月2日更换评论系统，因为Gitment无人维护，出现无法登陆Github评论的Bug，故更换成Valine,其优点是无需登陆即可评论，配置简单，缺点暂时未发现。 添加Valine评论系统 进行实名认证以及手机验证，实名认证需要等待一段时间，以自己为例，早上申请的，下午便收到实名认证成功的邮件。 创建应用： 进入应用设置： 获取APP ID以及APP KEY： 修改主体配置文件themes\next_config.yml: 12345678910valine: enable: true appid: #填写你的appid appkey: #填写你的appkey notify: true verify: false # Verification code placeholder: ヾﾉ≧∀≦)o来啊，快活啊! avatar: mm # gravatar style guest_info: nick,mail,link # custom comment header pageSize: 10 # pagination size appid和appkey很重要，千万不要填错。 设置邮件提醒功能： 参考：https://valine.js.org/notify.html 这块邮件提醒功能是Valine自带的，功能比较有限，我按照这个配置后，测试回复下是没有收到邮件提示的，后来看到valine官方推荐了Valine-Admin (by @zhaojun1998)的第三方增强版评论系统，按照步骤操作即可，这里不再赘述，可实现邮件接收评论提醒，并可直接连接跳转回复评论功能。 最后一步，将blog地址添加为安全域名： 添加Gitment评论系统 注册OAuth Application 登陆Github官网，进入https://github.com/settings/developers: 点击绿色Register a new application，填写以下内容： 点击绿色Register application,可获得Client ID、Client Secret。 创建Github仓库 创建一个仓库存放评论，仓库名：gitment-comments 修改主题配置文件 12345678910111213141516# Gitment# Introduction: https://imsun.net/posts/gitment-introduction/# You can get your Github ID from https://api.github.com/users/&lt;Github username&gt;gitment: enable: true mint: true count: true lazy: false cleanly: false language: github_user: sunflowerJY #Github用户名 github_repo: gitment-comments #仓库名 client_id: 5321cd82f4205f8b784e client_secret: 50caad7a61fb5f6d84fc9a66653e6ff625d1db57 proxy_gateway: redirect_protocol: 上述信息中除了github_user、github_repo、client_id、client_secret需要注意外，其他信息均可默认不改。 部署到博客查看效果： 1hexo d 初始化本文的评论页 使用评论功能要登陆Github账号，登陆后点击初始化本文的评论页。 💔由于文章标题过长的原因，可能会报错Error：validation failed: 修改/themes/next/layout/_third-party/comments/gitment.swig文件中标亮的代码： 用文章的时间替代标题标识评论，避免了标题超出50个字符的问题。 管理评论 在gitment-comments的Issues中可以集中管理博客所有文章的评论。 添加萌宠 给孤独写博人来个伴儿吧😬这里有各种各样的宠物,pick一个心水的萌宠吧😉 安装模块： 1npm install --save hexo-helper-live2d 下载一个宠物包, 以我博客中的黑猫为例： 1npm install live2d-widget-model-hijiki 站点配置文件中添加以下字段： 1234567891011121314151617# live2d live2d: enable: true scriptFrom: local pluginRootPath: live2dw/ pluginJsPath: lib/ pluginModelPath: assets/ model: use: live2d-widget-model-hijiki/ display: position: left width: 80 height: 300 hOffset: 20 #水平相对位移 vOffset: -200 #垂直相对位移 mobile: show: true 其中，注意model.use填写自己下载的宠物包名字。 Hexo-admin一站式写博部署 写第一篇博文的时候，总是纠结困惑排版的问题，网上也有很多推荐的Markdown编辑器，但是由于种种原因，和部署到Github Pages还是会有很多本地没有出现的问题。直到偶然之间，发现Hexo-admin这个插件，可以直接在本地http://localhost:4000/admin/ 写博客，并实时查看排版效果，比如我正在书写的这篇博文： 点击红圈的位置，可以实现实时本地预览： 一键式部署到Github Pages,还可以顺带部署信息，方便以后版本查阅: 是不是和Github Pages用起来无缝连接😉以下实现步骤： 安装插件： 1npm install --save hexo-admin 本地运行,打开http://localhost:4000/admin/ ： 1hexo server -d 💔上述的Deploy可能第一次使用会报错，解决方案如下： 编辑站点配置文件，搜索admin字段修改如下： 123# hexo-admin admin.deployCommandadmin: deployCommand: &apos;sh hexo-deploy.sh&apos; 在站点根目录下新建hexo-deploy.sh文件，内容如下： 1hexo g -d 编辑站点根目录下node_modules/hexo-admin/deploy.js文件，修改标亮处： 1var proc = spawn((process.platform === &quot;win32&quot; ? &quot;hexo.cmd&quot; : &quot;hexo&quot;), [&apos;d&apos;, &apos;-g&apos;]); 安装图床插件 目前上传图片至千牛网生成外链，复制到博客的html语言生成图片，知道有hexo-qiniu-sync这么一个插件能够化繁为简，去除重复劳动，使得在博客中添加图片更方便。但是一直安装配置存在问题，导致该插件无法使用，并且导致基本的hexo-clean、hexo s等命令也报错。 很无奈，未完待续。]]></content>
      <categories>
        <category>教程</category>
      </categories>
      <tags>
        <tag>Github Pages</tag>
        <tag>Hexo</tag>
        <tag>Next</tag>
        <tag>emoji</tag>
        <tag>Hexo-admin</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Github Pages + Hexo搭建博客填坑实记]]></title>
    <url>%2F2018%2F05%2F13%2FGithub%20Pages%20%2B%20Hexo%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2%E5%A1%AB%E5%9D%91%E5%AE%9E%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[背景 从实习结束，开始正儿八经看论文的时候，开始萌生了写博的想法。研一寒假在家不想看论文刷LeetCode的时候，学习了很多大神优秀的解法，却奈何下次遇到类似的方法还是困惑，便想找个地儿记录下来。 一开始选择了博客网站——类似博客园或者CSDN之类的，图形界面，操作简便，但存在广告，排版杂乱的问题。无疑之间发现了Markdown——写博利器，简洁明了，兼容Jupyter Notebook，同时显示代码和文字说明，非常适合数据分析工作。 这是我的博客成品：https://sunflowerjy.github.io/ 搭建此博客步骤很简单，顺利的话最快半小时就能搭建成功。然而标题是填坑实记，一看就是有故事的人😑故事听我娓娓道来~ 环境 系统：Win10 64位 Git: 2.17.0.windows.1 Node.js: 8.11.1 npm: 5.6.0 Hexo: 3.7.1 30分钟搭建最基础博客 写在最前面，提示：此步骤只适合环境与我一样，因为之前我也是参考别人分享的博文，然而由于各种软件的更新导致很多步骤都会报错，所以后期有可能由于软件更新而导致按照本文的方法安装配置出现错误。 安装Git Git的下载地址(Windows版本)：https://git-scm.com/download/win 选择适合自己系统的版本。 除了以下两个步骤以外，都可以默认选择Next(下一步): 如何使用Git? 标注 1：仅使用 Git Bash 进行操作； 标注 2：在选择使用 Git Bash 进行操作的同时，也可以使用 Windows 命令行操作，建议选择此项； 标注 3：在选择使用 Git 的同时，也把 Unix 工具加入到了我们的配置之中，而且此操作会覆盖 Windows 的一些工具，强烈不建议选择此项。 关于回车换行的问题 Dos和Windows采用回车+换行CRLF表示下一行，而Unix/Linux采用换行符LF表示下一行。 第一个选项是默认检查Windows风格的文件，并在提交时转换为Unix风格。 请选择第三项。如果默认选择第一项，在git中提交代码可能会报错。不过可以安装好之后再更改相关配置。若后续commit报错请参考搭建博客遇到的各种坑的详细介绍。 检验Git是否安装成功。 安装成功后，可以在桌面鼠标右键找到Git bash。 安装Node.js Node.js下载地址：https://nodejs.org/en/download/ 选择自己对应系统的版本。一路默认Next安装。 新版本的Node.js中集成了npm工具，故不需要再另外安装。 检验Node.js和npm是否安装成功。 安装Hexo 1npm install hexo-cli -g 检验Hexo是否安装成功。 本地搭建博客 在本地计算机新建一个文件夹存放博客代码： 1hexo init sunflowerJY.github.io 我存放博客代码的文件夹名：sunflowerJY.github.io 生成静态文件： 1hexo g # 或者hexo generate 在sunflowerJY.github.io文件夹下生成public文件夹存放静态文件。 启动本地Web服务： 1hexo s # 或者hexo server 现在可以在本地查看自己搭建的博客啦😃http://localhost:4000 关联Github 注册Github账号 Github官网：https://github.com/ 注册过程跟大部分网站相似，尤其注意注册邮箱user.email和用户名user.name,后期部署博客要用到并且必须一字不差，这也是遇到的坑之一😂 创建Github仓库 创建Github仓库来远程保存备份本地的博客代码。 这里再强调下，仓库名必须命名为用户名.github.io，之前由于我没有严格遵守用户名这一点，导致部署到Github的博客css等文件无法识别😩折腾了好久还是别人帮我检查到的😂 由于我的博客仓库已经搭建过所以提示报错已存在该仓库，新创建的不会报错。 开启Github Pages功能 打开博客仓库的Setting页面。 拉至Github Pages选项，将Source选择master分支。 可能会提示仓库为空，要先添加文件，请将本地的博客push到该远程仓库。熟悉Git命令的请跳过，否则参考上传本地博客仓库至远程仓库 配置Git账号信息 设置git的全局账号信息，user.name为Github用户名，user.email为Github注册邮箱。 12git config --global user.name &quot;sunflowerJY&quot;git config --global user.email &quot;sunflower_jy@icloud.com&quot; 查看Git的所配置信息： 1git config --list 配置SSH 查看本地的SSH Key，桌面右键进入Git bash： 1ls -al ~/.ssh 若有id_rsa和id_rsa.pub两个文件，则复制id_rsa.pub中内容至Github设置中。 New SSH Key 将id_rsa.pub中的内容复制到Key中。 验证SSH是否配置成功： 1ssh -T git@github.com 成功的话会显示以下的大致内容： 123456The authenticity of host &apos;github.com (192.30.252.128)&apos; can&apos;t be established.RSA key fingerprint is 16:27:ac:a5:76:28:2d:36:63:1b:56:4d:eb:df:a6:48.Are you sure you want to continue connecting (yes/no)? yesWarning: Permanently added &apos;github.com,192.30.252.128&apos; (RSA) to the list of known hosts.Hi sunflowerJY! You&apos;ve successfully authenticated, but GitHub does not provide shell access.Connection to github.com closed. 上传本地博客仓库至远程仓库 在Git bash中cd到本地博客文件夹sunflowerJY.github.io： 123git initgit add .git commit -m &quot;first commit blog&quot; 修改配置文件部署部分 修改本地博客文件夹sunflowerJY.github.io中的_config.yml。 其中，repo填写自己的仓库地址，主要修改对应的用户名位置。 安装Deploy工具 1npm install hexo-deployer-git --save 部署至Github 1hexo d#或hexo deploy 至此已经成功搭建了自己的博客，快去查看自己的专属博客吧💕https://用户名.github.io 搭建博客遇到的各种坑 其实在上一节30分钟搭建最基础博客中基本都已经提及了，现在来总结下吧 关于回车换行的问题 上一节在安装Git中提到过，由于Windows和Linux的换行规则不一样，所以为了确保在将Windows平台上的文件commit至Github时能正常使用，Git给出了自动转换文件格式的服务，即下图中的第一个选项。若默认选择了这项Next,后序在使用Git的过程中可能会报crlf与lf文件转换的WARN。 解决方案： 如果你是Windows程序员，且正在开发仅运行在Windows上的项目，可以设置false取消此功能，把回车符记录在库中： 1git config --global core.autocrlf false Github仓库名 Github仓库名必须以用户名.github.io的形式命名，用户名那里要一字不差，不然后期的css等文件渲染会有问题，一开始我没注意到这个问题导致博客打开傻眼了，白花花的一片只有字😱💥😢 开启Github Pages功能 如果仓库内没有文件，页面上会提示无法开启Github Pages功能，可以参照上传本地博客仓库至远程仓库。随即仓库中有文件后，便可开启Github Pages功能。 搭建博客遇到的各种坑这块内容我会一直保持更新。随时记录，方便有需要的人，也方便自己备忘😂 关于博客的内容后续还会更新，例如打造个性化的博客,如有需要请关注教程标签。]]></content>
      <categories>
        <category>教程</category>
      </categories>
      <tags>
        <tag>Github Pages</tag>
        <tag>Hexo</tag>
      </tags>
  </entry>
</search>
