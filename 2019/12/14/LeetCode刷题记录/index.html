<!DOCTYPE html>



  


<html class="theme-next pisces use-motion" lang="zh-hans">
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<meta name="theme-color" content="#222">


  
  
    
    
  <script src="/lib/pace/pace.min.js?v=1.0.2"></script>
  <link href="/lib/pace/pace-theme-flash.min.css?v=1.0.2" rel="stylesheet">







<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css">







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-sunflower.ico?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-sunflower.ico?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Leetcode,">










<meta name="description" content="Leetcode题目 96.不同的二叉搜索树 状态：不会，重做 题目 给定一个整数 n，求以 1 … n 为节点组成的二叉搜索树有多少种？ 示例: 输入: 3 输出: 5 解释: 给定 n = 3, 一共有 5 种不同结构的二叉搜索树: 123451     1      2         3       3   \    \     /  \       /       /">
<meta name="keywords" content="Leetcode">
<meta property="og:type" content="article">
<meta property="og:title" content="LeetCode刷题记录">
<meta property="og:url" content="http://yoursite.com/2019/12/14/LeetCode刷题记录/index.html">
<meta property="og:site_name" content="向日葵的自留地">
<meta property="og:description" content="Leetcode题目 96.不同的二叉搜索树 状态：不会，重做 题目 给定一个整数 n，求以 1 … n 为节点组成的二叉搜索树有多少种？ 示例: 输入: 3 输出: 5 解释: 给定 n = 3, 一共有 5 种不同结构的二叉搜索树: 123451     1      2         3       3   \    \     /  \       /       /">
<meta property="og:locale" content="zh-hans">
<meta property="og:updated_time" content="2019-12-14T07:53:05.817Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="LeetCode刷题记录">
<meta name="twitter:description" content="Leetcode题目 96.不同的二叉搜索树 状态：不会，重做 题目 给定一个整数 n，求以 1 … n 为节点组成的二叉搜索树有多少种？ 示例: 输入: 3 输出: 5 解释: 给定 n = 3, 一共有 5 种不同结构的二叉搜索树: 123451     1      2         3       3   \    \     /  \       /       /">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Pisces',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: 'Author'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/2019/12/14/LeetCode刷题记录/">





  <title>LeetCode刷题记录 | 向日葵的自留地</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-hans">
	
  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">向日葵的自留地</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br>
            
            Home
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br>
            
            Tags
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br>
            
            Categories
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br>
            
            Archives
          </a>
        </li>
      

      
        <li class="menu-item menu-item-search">
          
            <a href="javascript:;" class="popup-trigger">
          
            
              <i class="menu-item-icon fa fa-search fa-fw"></i> <br>
            
            Search
          </a>
        </li>
      
    </ul>
  

  
    <div class="site-search">
      
  <div class="popup search-popup local-search-popup">
  <div class="local-search-header clearfix">
    <span class="search-icon">
      <i class="fa fa-search"></i>
    </span>
    <span class="popup-btn-close">
      <i class="fa fa-times-circle"></i>
    </span>
    <div class="local-search-input-wrapper">
      <input autocomplete="off" placeholder="Searching..." spellcheck="false" type="text" id="local-search-input">
    </div>
  </div>
  <div id="local-search-result"></div>
</div>



    </div>
  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/12/14/LeetCode刷题记录/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="sunflowerJY">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="向日葵的自留地">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">LeetCode刷题记录</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2019-12-14T15:41:00+08:00">
                2019-12-14
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/IT应聘/" itemprop="url" rel="index">
                    <span itemprop="name">IT应聘</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2019/12/14/LeetCode刷题记录/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count valine-comment-count" data-xid="/2019/12/14/LeetCode刷题记录/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          
            <span class="post-meta-divider">|</span>
            <span class="page-pv"><i class="fa fa-file-o"></i> 阅读数
            <span class="busuanzi-value" id="busuanzi_value_page_pv"></span>次
            </span>
          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <h1 id="leetcode题目"><a class="header-anchor" href="#leetcode题目"></a>Leetcode题目</h1>
<h2 id="96-不同的二叉搜索树"><a class="header-anchor" href="#96-不同的二叉搜索树"></a>96.不同的二叉搜索树</h2>
<p>状态：不会，重做<br>
<strong>题目</strong><br>
给定一个整数 n，求以 1 … n 为节点组成的二叉搜索树有多少种？</p>
<p>示例:<br>
输入: 3<br>
输出: 5<br>
解释:<br>
给定 n = 3, 一共有 5 种不同结构的二叉搜索树:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1     1      2         3       3  </span><br><span class="line"> \    \     /  \       /       /            </span><br><span class="line">  3    2    1   3      2       1          </span><br><span class="line"> /      \            /          \</span><br><span class="line">2       3           1            2</span><br></pre></td></tr></table></figure>
<p><strong>解析</strong><br>
动态规划  <br>
以<code>1,2,...,n</code>为节点组成的BST有<code>G[n]</code>种，<br>
<code>G[n]=F(1,n)+F(2,n)+...+F(i,n)+...+F(n,n)</code>  <br>
其中，<code>F(i,n)</code>表示以i为根节点组成的BST个数，  <br>
然而，<code>F(i,n)=G[i-1] * G[n-i]</code>  <br>
注意，<code>G[0]=1</code></p>
<p>以n=3为例，<code>G[3]=F(1,3)+F(2,3)+F(3,3)</code>,</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">F(1,3)=G[0] * G[2]</span><br><span class="line">F(2,3)=G[1] * G[1]</span><br><span class="line">F(3,3)=G[2] * G[0]</span><br></pre></td></tr></table></figure>
<p><strong>代码</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">numTrees</span><span class="params">(self, n)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type n: int</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        G = [<span class="number">0</span>] * (n+<span class="number">1</span>)</span><br><span class="line">        G[<span class="number">0</span>] = <span class="number">1</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, n+<span class="number">1</span>):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(i):</span><br><span class="line">                G[i] += G[j] * G[i<span class="number">-1</span>-j]</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> G[n]</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    a = Solution()</span><br><span class="line">    print(a.numTrees(n=<span class="number">3</span>))</span><br></pre></td></tr></table></figure>
<h2 id="413-等差数列划分"><a class="header-anchor" href="#413-等差数列划分"></a>413. 等差数列划分</h2>
<p>状态：亟待优化<br>
<strong>题目</strong><br>
如果一个数列至少有三个元素，并且任意两个相邻元素之差相同，则称该数列为等差数列。</p>
<p>例如，以下数列为等差数列:<br>
1, 3, 5, 7, 9<br>
7, 7, 7, 7<br>
3, -1, -5, -9</p>
<p>以下数列不是等差数列。<br>
1, 1, 2, 5, 7</p>
<p>数组 A 包含 N 个数，且索引从0开始。数组 A 的一个子数组划分为数组 (P, Q)，P 与 Q 是整数且满足 0&lt;=P&lt;Q&lt;N 。<br>
如果满足以下条件，则称子数组(P, Q)为等差数组：<br>
元素 A[P], A[p + 1], …, A[Q - 1], A[Q] 是等差的。并且 P + 1 &lt; Q 。<br>
函数要返回数组 A 中所有为等差数组的子数组个数。</p>
<p>示例:<br>
A = [1, 2, 3, 4]<br>
返回: 3, A 中有三个子等差数组: [1, 2, 3], [2, 3, 4] 以及自身 [1, 2, 3, 4]。</p>
<p><strong>version1</strong>  <br>
过程：<br>
<image src="https://res.cloudinary.com/sunflower/image/upload/v1544164932/Blog/413_process.png" width="350"><br>
成绩：<br>
<image src="https://res.cloudinary.com/sunflower/image/upload/v1544164932/Blog/413_res.png" width="350"></image></image></p>
<p><strong>解析</strong>    <br>
审题一定要清楚：</p>
<ol>
<li>给定的数组A不一定是等差数列，不要让示例先入为止；</li>
<li>等差子数列，题目中明确要求：元素 A[P], A[p + 1], …, A[Q - 1], A[Q] 是等差的。并且 P + 1 &lt; Q 。即表明，子数列是在原数列中不间隔选出的，且至少3个元素。</li>
</ol>
<p>基于以上分析，先枚举出子数列的所有情形，再判断该子数列是否为等差，但是超时的缘故，在枚举子数列的过程中，若判定该子数列不等差，那么可以包含该子数列的数列肯定也不等差。优化这一判断条件后才勉强通过时间限制。</p>
<p><strong>代码</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">numberOfArithmeticSlices</span><span class="params">(self, A)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type A: List[int]</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">if</span> len(A) &lt; <span class="number">3</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            res = <span class="number">0</span></span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> range(len(A)):         </span><br><span class="line">                <span class="keyword">for</span> j <span class="keyword">in</span> range(i + <span class="number">3</span>, len(A) + <span class="number">1</span>):</span><br><span class="line">                    li = A[i:j]</span><br><span class="line">                    k = li[<span class="number">1</span>] - li[<span class="number">0</span>]<span class="comment">#等差</span></span><br><span class="line">                    flag = <span class="number">0</span></span><br><span class="line">                    <span class="keyword">for</span> m <span class="keyword">in</span> range(<span class="number">1</span>, len(li)):</span><br><span class="line">                        <span class="keyword">if</span> li[m] == li[m<span class="number">-1</span>] + k:</span><br><span class="line">                            flag += <span class="number">1</span></span><br><span class="line">                        <span class="keyword">else</span>:</span><br><span class="line">                            <span class="keyword">break</span></span><br><span class="line">                    <span class="keyword">if</span> flag == len(li) - <span class="number">1</span>:</span><br><span class="line">                        res += <span class="number">1</span></span><br><span class="line">                    <span class="keyword">else</span>:</span><br><span class="line">                        <span class="keyword">break</span>                   </span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>
<p><strong>标准答案</strong><br>
以A=[1,2,3,4,5,6]为例：<br>
10=1+2+3+4<br>
在枚举子数列时，判断A[i-2],A[i-1],A[i]是否为等差数列，若是则根据前一个循环是否也是等差决定是否叠加。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">numberOfArithmeticSlices</span><span class="params">(self, A)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :param A: List[int]</span></span><br><span class="line"><span class="string">        :return: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        N = len(A)</span><br><span class="line">        <span class="keyword">if</span> N &lt;= <span class="number">2</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line"></span><br><span class="line">        count = <span class="number">0</span></span><br><span class="line">        streak = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">2</span>, N):</span><br><span class="line">            <span class="keyword">if</span> A[i] - A[i<span class="number">-1</span>] == A[i<span class="number">-1</span>] - A[i<span class="number">-2</span>]:</span><br><span class="line">                streak += <span class="number">1</span><span class="comment">#以A[i]结尾的等差子数列的个数</span></span><br><span class="line">                count += streak</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                streak = <span class="number">0</span></span><br><span class="line">        <span class="keyword">return</span> count</span><br></pre></td></tr></table></figure>
<h2 id="120-三角形最小路径和"><a class="header-anchor" href="#120-三角形最小路径和"></a>120. 三角形最小路径和</h2>
<p>状态：排名85%，未考虑空间复杂度<br>
<strong>题目</strong>  <br>
给定一个三角形，找出自顶向下的最小路径和。每一步只能移动到下一行中相邻的结点上。</p>
<p>例如，给定三角形：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[</span><br><span class="line">     [2],</span><br><span class="line">    [3,4],</span><br><span class="line">   [6,5,7],</span><br><span class="line">  [4,1,8,3]</span><br><span class="line">]</span><br></pre></td></tr></table></figure>
<p>自顶向下的最小路径和为 11（即，2 + 3 + 5 + 1 = 11）。</p>
<p>说明：<br>
如果你可以只使用 O(n) 的额外空间（n 为三角形的总行数）来解决这个问题，那么你的算法会很加分。</p>
<p><strong>version1</strong>  <br>
过程：<br>
<image src="https://res.cloudinary.com/sunflower/image/upload/v1544363867/Blog/120_process.png" width="350"><br>
成绩：<br>
<image src="https://res.cloudinary.com/sunflower/image/upload/v1544363867/Blog/120_score.png" width="350"></image></image></p>
<p><strong>解析</strong>    <br>
参考之前矩阵的题目，从最左上角开始，每次只能往下或者往右走，最佳的解题思路就是算出每走一步后的结果，依次迭代。  <br>
那么，这里的思路也是一样的，这里的限制条件是只能走相邻的点。</p>
<p><strong>代码</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">minimumTotal</span><span class="params">(self, triangle)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type triangle: List[List[int]]</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">if</span> len(triangle) == <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> triangle[<span class="number">0</span>][<span class="number">0</span>]</span><br><span class="line">        <span class="keyword">elif</span> len(triangle) == <span class="number">2</span>:</span><br><span class="line">            <span class="keyword">return</span> triangle[<span class="number">0</span>][<span class="number">0</span>] + min(triangle[<span class="number">1</span>])</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            triangle[<span class="number">1</span>][<span class="number">0</span>], triangle[<span class="number">1</span>][<span class="number">1</span>] = triangle[<span class="number">1</span>][<span class="number">0</span>] + triangle[<span class="number">0</span>][<span class="number">0</span>], triangle[<span class="number">1</span>][<span class="number">1</span>] + triangle[<span class="number">0</span>][<span class="number">0</span>]</span><br><span class="line">            <span class="keyword">for</span> row <span class="keyword">in</span> range(<span class="number">2</span>, len(triangle)):</span><br><span class="line">                <span class="keyword">for</span> idx <span class="keyword">in</span> range(row + <span class="number">1</span>):</span><br><span class="line">                    <span class="keyword">if</span> idx == <span class="number">0</span>:</span><br><span class="line">                        triangle[row][idx] += triangle[row - <span class="number">1</span>][idx]</span><br><span class="line">                    <span class="keyword">elif</span> idx == row:</span><br><span class="line">                        triangle[row][idx] += triangle[row - <span class="number">1</span>][idx - <span class="number">1</span>]</span><br><span class="line">                    <span class="keyword">else</span>:</span><br><span class="line">                        triangle[row][idx] += min(triangle[row - <span class="number">1</span>][idx], triangle[row - <span class="number">1</span>][idx - <span class="number">1</span>])</span><br><span class="line">            <span class="keyword">return</span> min(triangle[<span class="number">-1</span>])</span><br></pre></td></tr></table></figure>
<p><strong>标准答案</strong>  <br>
关键在于空间复杂度：  <br>
我的解法是至上而下的，需要修改数组中的每一个元素。现在有一种解法是至下而上，只写存最后一行的内层数组空间，这种解法更节约空间。  <br>
<strong>代码</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">minimumTotal</span><span class="params">(self, triangle)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type triangle: List[List[int]]</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> triangle:</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        res = triangle[<span class="number">-1</span>]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(triangle) - <span class="number">2</span>, <span class="number">-1</span>, <span class="number">-1</span>):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(len(triangle[i])):</span><br><span class="line">                res[j] = min(res[j], res[j + <span class="number">1</span>]) + triangle[i][j]</span><br><span class="line">        <span class="keyword">return</span> res[<span class="number">0</span>]</span><br></pre></td></tr></table></figure>
<h2 id="62-不同路径-a-id-62"><a class="header-anchor" href="#62-不同路径-a-id-62"></a>62. 不同路径<a id="62"></a></h2>
<p>状态：排名95.86%<br>
<strong>题目</strong>  <br>
一个机器人位于一个 m x n 网格的左上角 （起始点在下图中标记为“Start” ）。</p>
<p>机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为“Finish”）。</p>
<p>问总共有多少条不同的路径？<br>
<image src="https://res.cloudinary.com/sunflower/image/upload/v1544446636/Blog/robot_maze.png" width="350"><br>
例如，上图是一个7 x 3 的网格。有多少可能的路径？</image></p>
<p>说明：m 和 n 的值均不超过 100。<br>
示例 1:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">输入: m = 3, n = 2</span><br><span class="line">输出: 3</span><br><span class="line">解释:</span><br><span class="line">从左上角开始，总共有 3 条路径可以到达右下角。</span><br><span class="line">1. 向右 -&gt; 向右 -&gt; 向下</span><br><span class="line">2. 向右 -&gt; 向下 -&gt; 向右</span><br><span class="line">3. 向下 -&gt; 向右 -&gt; 向右</span><br></pre></td></tr></table></figure>
<p>示例 2:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: m = 7, n = 3</span><br><span class="line">输出: 28</span><br></pre></td></tr></table></figure>
<p><strong>version1</strong>  <br>
过程：<br>
<image src="https://res.cloudinary.com/sunflower/image/upload/v1544446538/Blog/62_process.png" width="350"><br>
成绩：<br>
<image src="https://res.cloudinary.com/sunflower/image/upload/v1544446539/Blog/62_score.png" width="350"></image></image></p>
<p><strong>解析</strong>  <br>
第一次提交失败：未考虑周全矩阵的形式。  <br>
思路和之前矩阵求最小路径和以及三角形最小路径和是一样的，计算每个节点的路径可能数，最终答案即为最后一个点的值。</p>
<p><strong>代码</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">uniquePaths</span><span class="params">(self, m, n)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type m: int</span></span><br><span class="line"><span class="string">        :type n: int</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">if</span> m == <span class="number">1</span> <span class="keyword">or</span> n == <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            res = [[<span class="number">0</span> <span class="keyword">for</span> i <span class="keyword">in</span> range(n)] <span class="keyword">for</span> i <span class="keyword">in</span> range(m)]</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> range(m):</span><br><span class="line">                <span class="keyword">for</span> j <span class="keyword">in</span> range(n):</span><br><span class="line">                    <span class="keyword">if</span> i == <span class="number">0</span> <span class="keyword">and</span> j == <span class="number">0</span>:</span><br><span class="line">                        <span class="keyword">continue</span></span><br><span class="line">                    <span class="keyword">elif</span> i == <span class="number">0</span>:</span><br><span class="line">                        res[i][j] = <span class="number">1</span></span><br><span class="line">                    <span class="keyword">elif</span> j == <span class="number">0</span>:</span><br><span class="line">                        res[i][j] = <span class="number">1</span></span><br><span class="line">                    <span class="keyword">else</span>:</span><br><span class="line">                        res[i][j] = res[i - <span class="number">1</span>][j] + res[i][j - <span class="number">1</span>]</span><br><span class="line">            <span class="keyword">return</span> res[<span class="number">-1</span>][<span class="number">-1</span>]</span><br></pre></td></tr></table></figure>
<h2 id="712-两个字符串的最小ascii删除和"><a class="header-anchor" href="#712-两个字符串的最小ascii删除和"></a>712. 两个字符串的最小ASCII删除和</h2>
<p>状态：不会做<br>
<strong>题目</strong>  <br>
给定两个字符串s1, s2，找到使两个字符串相等所需删除字符的ASCII值的最小和。</p>
<p>示例 1:<br>
输入: s1 = “sea”, s2 = &quot;eat&quot;<br>
输出: 231<br>
解释: 在 “sea” 中删除 “s” 并将 “s” 的值(115)加入总和。<br>
在 “eat” 中删除 “t” 并将 116 加入总和。<br>
结束时，两个字符串相等，115 + 116 = 231 就是符合条件的最小和。</p>
<p>示例 2:<br>
输入: s1 = “delete”, s2 = &quot;leet&quot;<br>
输出: 403<br>
解释: 在 “delete” 中删除 “dee” 字符串变成 “let”，<br>
将 100[d]+101[e]+101[e] 加入总和。在 “leet” 中删除 “e” 将 101[e] 加入总和。<br>
结束时，两个字符串都等于 “let”，结果即为 100+101+101+101 = 403 。<br>
如果改为将两个字符串转换为 “lee” 或 “eet”，我们会得到 433 或 417 的结果，比答案更大。</p>
<p>注意:<br>
0 &lt; s1.length, s2.length &lt;= 1000。<br>
所有字符串中的字符ASCII值在[97, 122]之间。</p>
<p><strong>最佳答案</strong>  <br>
这题是经典题目“最长公共子串LCS”的变形题目。  <br>
在弄懂LCS之后，这题就很好理解了。<br>
LCS:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">初始化dp矩阵：</span><br><span class="line">----------d---e---l---e---t---e--</span><br><span class="line">|___|_0_|_0_|_0_|_0_|_0_|_0_|_0_|</span><br><span class="line">|_l_|_0_|_0_|_0_|_0_|_0_|_0_|_0_|</span><br><span class="line">|_e_|_0_|_0_|_0_|_0_|_0_|_0_|_0_|</span><br><span class="line">|_e_|_0_|_0_|_0_|_0_|_0_|_0_|_0_|</span><br><span class="line">|_t_|_0_|_0_|_0_|_0_|_0_|_0_|_0_|</span><br><span class="line">从s1=&quot;leet&quot;开始遍历对比s2=&quot;delete&quot;，</span><br><span class="line">1.如果相同，那么dp[i][j]=dp[i-1][j-1]+1;</span><br><span class="line">意味着，如果s1与s2最后一个元素相同，那么</span><br><span class="line">LCS（s1,s2）=LCS(s1[:-1],s2[:-1])+s1[-1]</span><br><span class="line">2.如果不同，那么dp[i][j]=max(dp[i-1][j],dp[i][j-1])</span><br><span class="line">意味着，如果s1与s2最后一个元素不同，那么</span><br><span class="line">LCS(s1,s2)=max(LCS(s1[:-1],s2),LCS(s1,s2[:-1]))</span><br><span class="line">----------d---e---l---e---t---e--</span><br><span class="line">|___|_0_|_0_|_0_|_0_|_0_|_0_|_0_|</span><br><span class="line">|_l_|_0_|_0_|_0_|_1_|_1_|_1_|_1_|</span><br><span class="line">|_e_|_0_|_0_|_1_|_1_|_2_|_2_|_2_|</span><br><span class="line">|_e_|_0_|_0_|_1_|_1_|_2_|_2_|_3_|</span><br><span class="line">|_t_|_0_|_0_|_1_|_1_|_2_|_3_|_3_|</span><br></pre></td></tr></table></figure>
<p><strong>标准代码</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">minimumDeleteSum</span><span class="params">(self, s1, s2)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type s1: str</span></span><br><span class="line"><span class="string">        :type s2: str</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        l1, l2 = len(s1), len(s2)</span><br><span class="line">        dp = [[<span class="number">0</span>] * (l2 + <span class="number">1</span>) <span class="keyword">for</span> _ <span class="keyword">in</span> range(l1 + <span class="number">1</span>)]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(l1):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(l2):</span><br><span class="line">                <span class="keyword">if</span> s1[i] == s2[j]:</span><br><span class="line">                    dp[i + <span class="number">1</span>][j + <span class="number">1</span>] = dp[i][j] + ord(s1[i])</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    dp[i + <span class="number">1</span>][j + <span class="number">1</span>] = max(dp[i][j + <span class="number">1</span>], dp[i + <span class="number">1</span>][j])</span><br><span class="line">        result = sum(map(ord, s1 + s2)) - dp[l1][l2] * <span class="number">2</span></span><br><span class="line">        <span class="keyword">return</span> result</span><br></pre></td></tr></table></figure>
<h2 id="647-回文子串"><a class="header-anchor" href="#647-回文子串"></a>647. 回文子串</h2>
<p>状态：排名23.26%<br>
<strong>题目</strong>  <br>
给定一个字符串，你的任务是计算这个字符串中有多少个回文子串。</p>
<p>具有不同开始位置或结束位置的子串，即使是由相同的字符组成，也会被计为是不同的子串。</p>
<p>示例 1:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: &quot;abc&quot;</span><br><span class="line">输出: 3</span><br><span class="line">解释: 三个回文子串: &quot;a&quot;, &quot;b&quot;, &quot;c&quot;.</span><br></pre></td></tr></table></figure>
<p>示例 2:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: &quot;aaa&quot;</span><br><span class="line">输出: 6</span><br><span class="line">说明: 6个回文子串: &quot;a&quot;, &quot;a&quot;, &quot;a&quot;, &quot;aa&quot;, &quot;aa&quot;, &quot;aaa&quot;.</span><br></pre></td></tr></table></figure>
<p>注意:<br>
输入的字符串长度不会超过1000。</p>
<p><strong>version1</strong>  <br>
过程：<br>
<image src="https://res.cloudinary.com/sunflower/image/upload/v1544703333/Blog/647_process.png" width="350"><br>
成绩：<br>
<image src="https://res.cloudinary.com/sunflower/image/upload/v1544703439/Blog/647_score.png" width="350"></image></image></p>
<p><strong>解析</strong>  <br>
首先一定搞明白回文字符串的意思，回文即正着读反着读都一样。  <br>
所以第一次提交失败。  <br>
第二次暴力求解，成绩亟待提高。</p>
<p><strong>代码</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">countSubstrings</span><span class="params">(self, s)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type s: str</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        flag = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(s)):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(i, len(s)):</span><br><span class="line">                <span class="keyword">if</span> s[i:j + <span class="number">1</span>] == s[i:j + <span class="number">1</span>][::<span class="number">-1</span>]:</span><br><span class="line">                    flag += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> flag</span><br></pre></td></tr></table></figure>
<h2 id="303-区域和检索-数组不可变"><a class="header-anchor" href="#303-区域和检索-数组不可变"></a>303. 区域和检索 - 数组不可变</h2>
<p>状态：排名41.91%，待提高<br>
<strong>题目</strong>  <br>
给定一个整数数组  nums，求出数组从索引 i 到 j  (i ≤ j) 范围内元素的总和，包含 i,  j 两点。</p>
<p>示例：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">给定 nums = [-2, 0, 3, -5, 2, -1]，求和函数为 sumRange()</span><br><span class="line">sumRange(0, 2) -&gt; 1</span><br><span class="line">sumRange(2, 5) -&gt; -1</span><br><span class="line">sumRange(0, 5) -&gt; -3</span><br></pre></td></tr></table></figure>
<p>说明:<br>
你可以假设数组不可变。<br>
会多次调用 sumRange 方法。</p>
<p><strong>version1</strong>  <br>
过程：<br>
<image src="https://res.cloudinary.com/sunflower/image/upload/v1544704657/Blog/303_process.png" width="350"><br>
成绩：<br>
<image src="https://res.cloudinary.com/sunflower/image/upload/v1544704743/Blog/303_score.png" width="350"></image></image></p>
<p><strong>解析</strong>    <br>
这题思路很简单。</p>
<p><strong>代码</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NumArray</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, nums)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type nums: List[int]</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        self.nums = nums</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">sumRange</span><span class="params">(self, i, j)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type i: int</span></span><br><span class="line"><span class="string">        :type j: int</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">return</span> sum(self.nums[i:j+<span class="number">1</span>])</span><br><span class="line"><span class="comment"># Your NumArray object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"># obj = NumArray(nums)</span></span><br><span class="line"><span class="comment"># param_1 = obj.sumRange(i,j)</span></span><br></pre></td></tr></table></figure>
<p><strong>标准答案</strong>  <br>
这题主要是要用动态规划的思想，题目要求的sumRange(i,j)，是可以在遍历数组元素的时候进行叠加求和，一次性求出新的叠加数组。</p>
<p><strong>代码</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NumArray</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, nums)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type nums: List[int]</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        self.nums = nums</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">sumRange</span><span class="params">(self, i, j)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type i: int</span></span><br><span class="line"><span class="string">        :type j: int</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">return</span> sum(self.nums[i:j+<span class="number">1</span>])</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    a = NumArray(nums=[<span class="number">-2</span>, <span class="number">0</span>, <span class="number">3</span>, <span class="number">-5</span>, <span class="number">2</span>, <span class="number">-1</span>])</span><br><span class="line">    print(a.sumRange(<span class="number">0</span>, <span class="number">5</span>))</span><br></pre></td></tr></table></figure>
<h2 id="343-整数拆分"><a class="header-anchor" href="#343-整数拆分"></a>343. 整数拆分</h2>
<p>状态：  排名99%<br>
<strong>题目</strong>  <br>
给定一个正整数 n，将其拆分为至少两个正整数的和，并使这些整数的乘积最大化。 返回你可以获得的最大乘积。</p>
<p>示例 1:<br>
输入: 2<br>
输出: 1<br>
解释: 2 = 1 + 1, 1 × 1 = 1。</p>
<p>示例 2:<br>
输入: 10<br>
输出: 36<br>
解释: 10 = 3 + 3 + 4, 3 × 3 × 4 = 36。</p>
<p>说明: 你可以假设 n 不小于 2 且不大于 58。</p>
<p><strong>version1</strong>    <br>
过程：<br>
<image src="https://res.cloudinary.com/sunflower/image/upload/v1544798598/Blog/343_process.png" width="350"></image></p>
<p><strong>version2</strong>    <br>
过程：<br>
<image src="https://res.cloudinary.com/sunflower/image/upload/v1545488812/Blog/343_progress.png" width="350">  <br>
成绩：<br>
<image src="https://res.cloudinary.com/sunflower/image/upload/v1545488812/Blog/343_score.png" width="350"></image></image></p>
<p><strong>解析</strong>  <br>
第二次再写，硬生生地记住了结论，解题关键要尽可能多拆分为3，若剩下1，则要将3和1转换为2和2。</p>
<p><strong>标准答案</strong>  <br>
这题主要还是没搞懂解题思路，解题的关键是神奇的质数2和质数3。</p>
<p><strong>代码</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> functools <span class="keyword">import</span> reduce</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">integerBreak</span><span class="params">(self, n)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type n: int</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">if</span> n == <span class="number">2</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> n == <span class="number">3</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">2</span></span><br><span class="line">        list_3 = [<span class="number">3</span>] * int((n / <span class="number">3</span>))  <span class="comment"># generate a list of 3</span></span><br><span class="line">        mod_3 = n % <span class="number">3</span></span><br><span class="line">        <span class="keyword">if</span> mod_3 == <span class="number">1</span>:  <span class="comment"># if a 1 is left, then add it to the first element to get a 4</span></span><br><span class="line">            list_3[<span class="number">0</span>] += <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> mod_3 == <span class="number">2</span>:  <span class="comment"># if a 2 is left, then put it into the list</span></span><br><span class="line">            list_3.append(<span class="number">2</span>)</span><br><span class="line">        <span class="keyword">return</span> reduce(<span class="keyword">lambda</span> a, b: a * b, list_3)</span><br></pre></td></tr></table></figure>
<h2 id="638-大礼包"><a class="header-anchor" href="#638-大礼包"></a>638. 大礼包</h2>
<p>状态：未通过，有思路但是有难点无法克服   <br>
<strong>题目</strong>  <br>
在LeetCode商店中， 有许多在售的物品。</p>
<p>然而，也有一些大礼包，每个大礼包以优惠的价格捆绑销售一组物品。<br>
现给定每个物品的价格，每个大礼包包含物品的清单，以及待购物品清单。请输出确切完成待购清单的最低花费。</p>
<p>每个大礼包的由一个数组中的一组数据描述，最后一个数字代表大礼包的价格，其他数字分别表示内含的其他种类物品的数量。</p>
<p>任意大礼包可无限次购买。</p>
<p>示例 1:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">输入: [2,5], [[3,0,5],[1,2,10]], [3,2]</span><br><span class="line">输出: 14</span><br><span class="line">解释: </span><br><span class="line">有A和B两种物品，价格分别为¥2和¥5。</span><br><span class="line">大礼包1，你可以以¥5的价格购买3A和0B。</span><br><span class="line">大礼包2， 你可以以¥10的价格购买1A和2B。</span><br><span class="line">你需要购买3个A和2个B， 所以你付了¥10购买了1A和2B（大礼包2），以及¥4购买2A。</span><br></pre></td></tr></table></figure>
<p>示例 2:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">输入: [2,3,4], [[1,1,0,4],[2,2,1,9]], [1,2,1]</span><br><span class="line">输出: 11</span><br><span class="line">解释: </span><br><span class="line">A，B，C的价格分别为¥2，¥3，¥4.</span><br><span class="line">你可以用¥4购买1A和2B，也可以用¥9购买2A，2B和1C。</span><br><span class="line">你需要买1A，2B和1C，所以你付了¥4买了1A和1B（大礼包1），以及¥3购买1B， ¥4购买1C。</span><br><span class="line">你不可以购买超出待购清单的物品，尽管购买大礼包2更加便宜。</span><br></pre></td></tr></table></figure>
<p>说明:<br>
最多6种物品， 100种大礼包。<br>
每种物品，你最多只需要购买6个。<br>
你不可以购买超出待购清单的物品，即使更便宜。</p>
<p><strong>version1</strong>    <br>
过程：  <br>
本地编译器上未调通，有思路，但是不知道如何解决不同大礼包优惠程度的对比。</p>
<p><strong>标准答案</strong>  <br>
深度优先搜索，主要就是用大礼包或者原价购买的价格比较，不仅要比较不同大礼包之间的差别，还要比较与原价之间的价格。大礼包的比较肯定要用for循环，然后保存下来方便与后续比较。</p>
<p><strong>代码</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">shoppingOffers</span><span class="params">(self, price, special, needs)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type price: List[int]</span></span><br><span class="line"><span class="string">        :type special: List[List[int]]</span></span><br><span class="line"><span class="string">        :type needs: List[int]</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        d = &#123;&#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">dfs</span><span class="params">(cur)</span>:</span></span><br><span class="line">            val = sum(cur[i] * price[i] <span class="keyword">for</span> i <span class="keyword">in</span> range(len(needs)))  <span class="comment"># cost without special</span></span><br><span class="line">            <span class="keyword">for</span> spec <span class="keyword">in</span> special:</span><br><span class="line">                tmp = [cur[j] - spec[j] <span class="keyword">for</span> j <span class="keyword">in</span> range(len(needs))]</span><br><span class="line">                <span class="keyword">if</span> min(tmp) &gt;= <span class="number">0</span>:  <span class="comment"># skip deals that exceed needs</span></span><br><span class="line">                    val = min(val, d.get(tuple(tmp), dfs(tmp)) + spec[<span class="number">-1</span>])  <span class="comment"># .get check the dictionary first for result, otherwise perform dfs.</span></span><br><span class="line">            d[tuple(cur)] = val</span><br><span class="line">            <span class="keyword">return</span> val</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> dfs(needs)</span><br></pre></td></tr></table></figure>
<h2 id="312-戳气球"><a class="header-anchor" href="#312-戳气球"></a>312. 戳气球</h2>
<p>状态：未通过，思路错误    <br>
<strong>题目</strong>  <br>
有 n 个气球，编号为0 到 n-1，每个气球上都标有一个数字，这些数字存在数组 nums 中。</p>
<p>现在要求你戳破所有的气球。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">每当你戳破一个气球 i 时，你可以获得 nums[left] * nums[i] * nums[right] 个硬币。</span><br></pre></td></tr></table></figure>
<p>这里的 left 和 right 代表和 i 相邻的两个气球的序号。  <br>
注意当你戳破了气球 i 后，气球 left 和气球 right 就变成了相邻的气球。</p>
<p>求所能获得硬币的最大数量。</p>
<p>说明:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">你可以假设 nums[-1] = nums[n] = 1，但注意它们不是真实存在的所以并不能被戳破。  </span><br><span class="line">0 ≤ n ≤ 500, 0 ≤ nums[i] ≤ 100</span><br></pre></td></tr></table></figure>
<p>示例:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入: [3,1,5,8]</span><br><span class="line">输出: 167 </span><br><span class="line">解释: nums = [3,1,5,8] --&gt; [3,5,8] --&gt;   [3,8]   --&gt;  [8]  --&gt; []</span><br><span class="line">     coins =  3*1*5      +  3*5*8    +  1*3*8      + 1*8*1   = 167</span><br></pre></td></tr></table></figure>
<p><strong>version1</strong>    <br>
过程：  <br>
整个思考过程就是错误的。忧伤···</p>
<p><strong>标准答案</strong></p>
<p><strong>代码</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maxCoins</span><span class="params">(self, nums)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type nums: List[int]</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        nums = [<span class="number">1</span>] + nums + [<span class="number">1</span>]</span><br><span class="line">        n = len(nums)</span><br><span class="line">        dp = [[<span class="number">0</span>] * n <span class="keyword">for</span> _ <span class="keyword">in</span> xrange(n)]</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">calculate</span><span class="params">(i, j)</span>:</span></span><br><span class="line">            <span class="keyword">if</span> dp[i][j] <span class="keyword">or</span> j == i + <span class="number">1</span>: <span class="comment"># in memory or gap &lt; 2</span></span><br><span class="line">                <span class="keyword">return</span> dp[i][j]</span><br><span class="line">            coins = <span class="number">0</span></span><br><span class="line">            <span class="keyword">for</span> k <span class="keyword">in</span> xrange(i+<span class="number">1</span>, j): <span class="comment"># find the last balloon</span></span><br><span class="line">                coins = max(coins, nums[i] * nums[k] * nums[j] + calculate(i, k) + calculate(k, j))</span><br><span class="line">            dp[i][j] = coins</span><br><span class="line">            <span class="keyword">return</span> coins</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> calculate(<span class="number">0</span>, n<span class="number">-1</span>)</span><br></pre></td></tr></table></figure>
<h2 id="740-删除与获得点数"><a class="header-anchor" href="#740-删除与获得点数"></a>740.删除与获得点数</h2>
<h2 id="95-不同的二叉搜索树ii"><a class="header-anchor" href="#95-不同的二叉搜索树ii"></a>95.不同的二叉搜索树II</h2>
<h2 id="121-买卖股票的最佳时机-a-id-121"><a class="header-anchor" href="#121-买卖股票的最佳时机-a-id-121"></a>121.买卖股票的最佳时机<a id="121"></a></h2>
<p>状态：未通过，超时    <br>
<strong>题目</strong>  <br>
给定一个数组，它的第 i 个元素是一支给定股票第 i 天的价格。</p>
<p>如果你最多只允许完成一笔交易（即买入和卖出一支股票），设计一个算法来计算你所能获取的最大利润。</p>
<p>注意你不能在买入股票前卖出股票。</p>
<p>示例 1:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入: [7,1,5,3,6,4]</span><br><span class="line">输出: 5</span><br><span class="line">解释: 在第 2 天（股票价格 = 1）的时候买入，在第 5 天（股票价格 = 6）的时候卖出，最大利润 = 6-1 = 5 。</span><br><span class="line">     注意利润不能是 7-1 = 6, 因为卖出价格需要大于买入价格。</span><br></pre></td></tr></table></figure>
<p>示例 2:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: [7,6,4,3,1]</span><br><span class="line">输出: 0</span><br><span class="line">解释: 在这种情况下, 没有交易完成, 所以最大利润为 0。</span><br></pre></td></tr></table></figure>
<p><strong>version1</strong>    <br>
过程：  <br>
思路有，就是实现起来不够动态规划。所以会导致很慢，超时不通过。</p>
<p><strong>标准答案</strong>  <br>
标准答案是只需要一次遍历，求出答案，复杂度是O(N)。而我第一次版本是不止一次遍历的，不仅是明显写出的第一次循环还是隐性的求min,max（其实也是遍历）。</p>
<p><strong>代码</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maxProfit</span><span class="params">(self, prices)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type prices: List[int]</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        max_profit, min_price = <span class="number">0</span>, float(<span class="string">'inf'</span>)</span><br><span class="line">        <span class="keyword">for</span> price <span class="keyword">in</span> prices:</span><br><span class="line">            min_price = min(min_price, price)</span><br><span class="line">            profit = price - min_price</span><br><span class="line">            max_profit = max(max_profit, profit)</span><br><span class="line">        <span class="keyword">return</span> max_profit</span><br></pre></td></tr></table></figure>
<h2 id="931-下降路径最小和"><a class="header-anchor" href="#931-下降路径最小和"></a>931.下降路径最小和</h2>
<p>状态：排名98%      <br>
<strong>题目</strong>  <br>
给定一个方形整数数组 A，我们想要得到通过 A 的下降路径的最小和。</p>
<p>下降路径可以从第一行中的任何元素开始，并从每一行中选择一个元素。在下一行选择的元素和当前行所选元素最多相隔一列。</p>
<p>示例：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">输入：[[1,2,3],[4,5,6],[7,8,9]]</span><br><span class="line">输出：12</span><br><span class="line">解释：</span><br><span class="line">可能的下降路径有：</span><br><span class="line">[1,4,7], [1,4,8], [1,5,7], [1,5,8], [1,5,9]</span><br><span class="line">[2,4,7], [2,4,8], [2,5,7], [2,5,8], [2,5,9], [2,6,8], [2,6,9]</span><br><span class="line">[3,5,7], [3,5,8], [3,5,9], [3,6,8], [3,6,9]</span><br><span class="line"></span><br><span class="line">和最小的下降路径是 [1,4,7]，所以答案是 12。</span><br></pre></td></tr></table></figure>
<p>提示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1 &lt;= A.length == A[0].length &lt;= 100</span><br><span class="line">-100 &lt;= A[i][j] &lt;= 100</span><br></pre></td></tr></table></figure>
<p><strong>version1</strong>    <br>
过程：  <br>
<image src="https://res.cloudinary.com/sunflower/image/upload/v1545401185/Blog/931_progress.png" width="350"><br>
成绩：<br>
<image src="https://res.cloudinary.com/sunflower/image/upload/v1545401185/Blog/931_score.png" width="350">  <br>
这种类型的题目已经掌握了，笔试是不会怕了。<br>
相似题目有120，62。</image></image></p>
<p><strong>代码</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">minFallingPathSum</span><span class="params">(self, A)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type A: List[List[int]]</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">if</span> len(A) == <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> sum(A[<span class="number">0</span>])</span><br><span class="line">        <span class="keyword">if</span> len(A[<span class="number">0</span>]) == <span class="number">1</span>:</span><br><span class="line">            res = <span class="number">0</span></span><br><span class="line">            <span class="keyword">for</span> row <span class="keyword">in</span> range(len(A)):</span><br><span class="line">                res += A[row][<span class="number">0</span>]</span><br><span class="line">            <span class="keyword">return</span> res</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, len(A)):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(len(A[<span class="number">0</span>])):</span><br><span class="line">                <span class="keyword">if</span> j == <span class="number">0</span>:</span><br><span class="line">                    A[i][j] += min(A[i<span class="number">-1</span>][j], A[i<span class="number">-1</span>][j+<span class="number">1</span>])</span><br><span class="line">                <span class="keyword">elif</span> j == len(A[<span class="number">0</span>])<span class="number">-1</span>:</span><br><span class="line">                    A[i][j] += min(A[i<span class="number">-1</span>][j], A[i<span class="number">-1</span>][j<span class="number">-1</span>])</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    A[i][j] += min(A[i<span class="number">-1</span>][j], A[i<span class="number">-1</span>][j<span class="number">-1</span>], A[i<span class="number">-1</span>][j+<span class="number">1</span>])</span><br><span class="line">        <span class="keyword">return</span> min(A[<span class="number">-1</span>])</span><br></pre></td></tr></table></figure>
<h2 id="70-爬楼梯"><a class="header-anchor" href="#70-爬楼梯"></a>70.爬楼梯</h2>
<p>状态：未通过<br>
<strong>题目</strong>  <br>
假设你正在爬楼梯。需要 n 阶你才能到达楼顶。<br>
每次你可以爬 1 或 2 个台阶。你有多少种不同的方法可以爬到楼顶呢？<br>
注意：给定 n 是一个正整数。</p>
<p>示例 1：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入： 2</span><br><span class="line">输出： 2</span><br><span class="line">解释： 有两种方法可以爬到楼顶。</span><br><span class="line">1.  1 阶 + 1 阶</span><br><span class="line">2.  2 阶</span><br></pre></td></tr></table></figure>
<p>示例 2：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">输入： 3</span><br><span class="line">输出： 3</span><br><span class="line">解释： 有三种方法可以爬到楼顶。</span><br><span class="line">1.  1 阶 + 1 阶 + 1 阶</span><br><span class="line">2.  1 阶 + 2 阶</span><br><span class="line">3.  2 阶 + 1 阶</span><br></pre></td></tr></table></figure>
<p><strong>标准答案</strong>    <br>
爬楼梯是一道经典的动态规划类型题目。  <br>
这道题目是逆推。比如，要想爬10级楼梯，可以1次爬1级，也可以1次爬2级。如果现在考虑，只剩最后一步，那么有可能是最后一步爬1级，也有可能是最后一步爬2级。如果最后一步爬1级，那么问题转换为爬9级台阶的方式，同理可知，如果最后一步爬2级，就等价于秋节爬8级台阶的方法。  <br>
数学表达式：<br>
F(10)=F(9)+F(8)<br>
F(9)=F(8)+F(7)<br>
…</p>
<p><strong>代码</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">climbStairs</span><span class="params">(self, n)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type n: int</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">if</span> n == <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">        <span class="keyword">elif</span> n == <span class="number">2</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">2</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> self.climbStairs(n<span class="number">-1</span>) + self.climbStairs(n<span class="number">-2</span>)</span><br></pre></td></tr></table></figure>
<h2 id="152-乘积最大子序列"><a class="header-anchor" href="#152-乘积最大子序列"></a>152. 乘积最大子序列</h2>
<p>状态：未通过<br>
<strong>题目</strong>  <br>
给定一个整数数组 nums ，找出一个序列中乘积最大的连续子序列（该序列至少包含一个数）。</p>
<p>示例 1:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: [2,3,-2,4]</span><br><span class="line">输出: 6</span><br><span class="line">解释: 子数组 [2,3] 有最大乘积 6。</span><br></pre></td></tr></table></figure>
<p>示例 2:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: [-2,0,-1]</span><br><span class="line">输出: 0</span><br><span class="line">解释: 结果不能为 2, 因为 [-2,-1] 不是子数组。</span><br></pre></td></tr></table></figure>
<p><strong>标准答案</strong>    <br>
动态规划的题目做多了，直觉告诉我这题应该一次遍历即可得到答案。  <br>
连续子序列的最大值可能因为符号的变化，最大值瞬间变为最小值，最小值瞬间变为最大值，故这题的关键是记录当前遍历状态下的最大值与最小值。</p>
<p><strong>代码</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maxProduct</span><span class="params">(self, nums)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type nums: List[int]</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        maximum = big = small = nums[<span class="number">0</span>]</span><br><span class="line">        <span class="keyword">for</span> n <span class="keyword">in</span> nums[<span class="number">1</span>:]:</span><br><span class="line">            big, small = max(n, n * big, n * small), min(n, n * big, n * small)</span><br><span class="line">            maximum = max(maximum, big)</span><br><span class="line">        <span class="keyword">return</span> maximum</span><br></pre></td></tr></table></figure>
<h2 id="122-买卖股票的最佳时机-ii"><a class="header-anchor" href="#122-买卖股票的最佳时机-ii"></a>122. 买卖股票的最佳时机 II</h2>
<p>状态：未通过<br>
<strong>题目</strong>  <br>
给定一个数组，它的第 i 个元素是一支给定股票第 i 天的价格。<br>
设计一个算法来计算你所能获取的最大利润。你可以尽可能地完成更多的交易（多次买卖一支股票）。<br>
注意：你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。</p>
<p>示例 1:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入: [7,1,5,3,6,4]</span><br><span class="line">输出: 7</span><br><span class="line">解释: 在第 2 天（股票价格 = 1）的时候买入，在第 3 天（股票价格 = 5）的时候卖出, 这笔交易所能获得利润 = 5-1 = 4 。</span><br><span class="line">     随后，在第 4 天（股票价格 = 3）的时候买入，在第 5 天（股票价格 = 6）的时候卖出, 这笔交易所能获得利润 = 6-3 = 3 。</span><br></pre></td></tr></table></figure>
<p>示例 2:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入: [1,2,3,4,5]</span><br><span class="line">输出: 4</span><br><span class="line">解释: 在第 1 天（股票价格 = 1）的时候买入，在第 5 天 （股票价格 = 5）的时候卖出, 这笔交易所能获得利润 = 5-1 = 4 。</span><br><span class="line">     注意你不能在第 1 天和第 2 天接连购买股票，之后再将它们卖出。</span><br><span class="line">     因为这样属于同时参与了多笔交易，你必须在再次购买前出售掉之前的股票。</span><br></pre></td></tr></table></figure>
<p>示例 3:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: [7,6,4,3,1]</span><br><span class="line">输出: 0</span><br><span class="line">解释: 在这种情况下, 没有交易完成, 所以最大利润为 0。</span><br></pre></td></tr></table></figure>
<p><strong>标准答案</strong>    <br>
这题的题目背景与<a href="#121"><code>121.买卖股票的最佳时机</code></a>非常相似。但是不要搞混淆，题目给出的条件一点点的差异也可能导致解法大大不同。这题没有不允许同一天操作买入与卖出的交易行为，而121题则明确提出不可以。</p>
<p><strong>代码</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maxProfit</span><span class="params">(self, prices)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type prices: List[int]</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        res = []</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(prices)<span class="number">-1</span>):</span><br><span class="line">            <span class="keyword">if</span> prices[i+<span class="number">1</span>] &gt; prices[i]:</span><br><span class="line">                res.append(prices[i+<span class="number">1</span>]-prices[i])</span><br><span class="line">        <span class="keyword">return</span> sum(res)</span><br></pre></td></tr></table></figure>
<h2 id="200-岛屿的个数-a-id-200"><a class="header-anchor" href="#200-岛屿的个数-a-id-200"></a>200. 岛屿的个数<a id="200"></a></h2>
<p>状态：未通过<br>
<strong>题目</strong>  <br>
给定一个由’1’（陆地）和 ‘0’（水）组成的的二维网格，计算岛屿的数量。<br>
一个岛被水包围，并且它是通过水平方向或垂直方向上相邻的陆地连接而成的。<br>
你可以假设网格的四个边均被水包围。</p>
<p>示例 1:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">输入:</span><br><span class="line">11110</span><br><span class="line">11010</span><br><span class="line">11000</span><br><span class="line">00000</span><br><span class="line">输出: 1</span><br></pre></td></tr></table></figure>
<p>示例 2:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">输入:</span><br><span class="line">11000</span><br><span class="line">11000</span><br><span class="line">00100</span><br><span class="line">00011</span><br><span class="line">输出: 3</span><br></pre></td></tr></table></figure>
<p><strong>标准答案</strong>    <br>
方法一：<br>
深度优先搜索，在每次遍历中尽可能深入地迭代遍历。  <br>
在目标函数中调用自建的dfs函数，dfs函数中递归调用dfs函数本身。</p>
<p>方法二：  <br>
并查集，利用树形结构，记录每个连通块的情况，而连通块的个数则代表岛屿的个数。</p>
<p><strong>DFS代码</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">numIslands</span><span class="params">(self, grid)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type grid: List[List[str]]</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> grid:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line"></span><br><span class="line">        count = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(grid)):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(len(grid[<span class="number">0</span>])):</span><br><span class="line">                <span class="keyword">if</span> grid[i][j] == <span class="string">'1'</span>:</span><br><span class="line">                    self.dfs(grid, i, j)</span><br><span class="line">                    count += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> count</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">dfs</span><span class="params">(self, grid, i, j)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> i &lt; <span class="number">0</span> <span class="keyword">or</span> j &lt; <span class="number">0</span> <span class="keyword">or</span> i &gt;= len(grid) <span class="keyword">or</span> j &gt;= len(grid[<span class="number">0</span>]) <span class="keyword">or</span> grid[i][j] != <span class="string">'1'</span>:</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        grid[i][j] = <span class="string">'#'</span><span class="comment">#确保已经遍历过的陆地不会再走一遍，不然会一直死循环</span></span><br><span class="line">        self.dfs(grid, i + <span class="number">1</span>, j)</span><br><span class="line">        self.dfs(grid, i - <span class="number">1</span>, j)</span><br><span class="line">        self.dfs(grid, i, j + <span class="number">1</span>)</span><br><span class="line">        self.dfs(grid, i, j - <span class="number">1</span>)</span><br></pre></td></tr></table></figure>
<p><strong>并查集</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UnionFind</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, grid)</span>:</span></span><br><span class="line">        m, n = len(grid), len(grid[<span class="number">0</span>])</span><br><span class="line">        self.count = <span class="number">0</span><span class="comment">#记录岛屿的数量，节省一次遍历</span></span><br><span class="line">        self.parent = [<span class="number">-1</span>] * (m*n)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(m):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(n):</span><br><span class="line">                <span class="keyword">if</span> grid[i][j] == <span class="string">'1'</span>:</span><br><span class="line">                    self.parent[i*n + j] = i*n + j</span><br><span class="line">                    self.count += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">find</span><span class="params">(self, i)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> self.parent[i] != i:</span><br><span class="line">            self.parent[i] = self.find(self.parent[i])</span><br><span class="line">        <span class="keyword">return</span> self.parent[i]</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">union</span><span class="params">(self, x, y)</span>:</span></span><br><span class="line">        rootx = self.find(x)</span><br><span class="line">        rooty = self.find(y)</span><br><span class="line">        <span class="keyword">if</span> rootx != rooty:</span><br><span class="line">            self.parent[rooty] = rootx</span><br><span class="line">            self.count -= <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">is_valid</span><span class="params">(self, grid, r, c)</span>:</span></span><br><span class="line">        m, n = len(grid), len(grid[<span class="number">0</span>])</span><br><span class="line">        <span class="keyword">if</span> r &lt; <span class="number">0</span> <span class="keyword">or</span> c &lt; <span class="number">0</span> <span class="keyword">or</span> r &gt;= m <span class="keyword">or</span> c &gt;= n:</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">True</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">numIslands</span><span class="params">(self, grid)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type grid: List[List[str]]</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> grid <span class="keyword">or</span> <span class="keyword">not</span> grid[<span class="number">0</span>]:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line"></span><br><span class="line">        uf = UnionFind(grid)</span><br><span class="line"></span><br><span class="line">        directions = [(<span class="number">0</span>,<span class="number">1</span>), (<span class="number">0</span>,<span class="number">-1</span>), (<span class="number">-1</span>,<span class="number">0</span>), (<span class="number">1</span>,<span class="number">0</span>)]</span><br><span class="line">        m, n = len(grid), len(grid[<span class="number">0</span>])</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(m):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(n):</span><br><span class="line">                <span class="keyword">if</span> grid[i][j] == <span class="string">'1'</span>:</span><br><span class="line">                    <span class="keyword">for</span> d <span class="keyword">in</span> directions:</span><br><span class="line">                        nr, nc = i + d[<span class="number">0</span>], j + d[<span class="number">1</span>]</span><br><span class="line">                        <span class="keyword">if</span> self.is_valid(grid, nr, nc) <span class="keyword">and</span> grid[nr][nc] == <span class="string">'1'</span>:</span><br><span class="line">                            uf.union(i*n+j, nr*n+nc)</span><br><span class="line">        <span class="keyword">return</span> uf.count</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    a = Solution()</span><br><span class="line">    print(a.numIslands(grid=[[<span class="string">'1'</span>,<span class="string">'1'</span>,<span class="string">'1'</span>,<span class="string">'1'</span>,<span class="string">'0'</span>], [<span class="string">'1'</span>,<span class="string">'1'</span>,<span class="string">'0'</span>,<span class="string">'1'</span>,<span class="string">'0'</span>], [<span class="string">'1'</span>,<span class="string">'1'</span>,<span class="string">'0'</span>,<span class="string">'0'</span>,<span class="string">'0'</span>], [<span class="string">'0'</span>,<span class="string">'0'</span>,<span class="string">'0'</span>,<span class="string">'0'</span>,<span class="string">'0'</span>]]))</span><br></pre></td></tr></table></figure>
<h2 id="695-岛屿的最大面积-a-id-695"><a class="header-anchor" href="#695-岛屿的最大面积-a-id-695"></a>695. 岛屿的最大面积<a id="695"></a></h2>
<p>状态：排名53.56%     <br>
<strong>题目</strong>  <br>
给定一个包含了一些 0 和 1的非空二维数组 grid , 一个 岛屿 是由四个方向 (水平或垂直) 的 1 (代表土地) 构成的组合。你可以假设二维矩阵的四个边缘都被水包围着。</p>
<p>找到给定的二维数组中最大的岛屿面积。(如果没有岛屿，则返回面积为0。)</p>
<p>示例 1:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">[[0,0,1,0,0,0,0,1,0,0,0,0,0],</span><br><span class="line"> [0,0,0,0,0,0,0,1,1,1,0,0,0],</span><br><span class="line"> [0,1,1,0,1,0,0,0,0,0,0,0,0],</span><br><span class="line"> [0,1,0,0,1,1,0,0,1,0,1,0,0],</span><br><span class="line"> [0,1,0,0,1,1,0,0,1,1,1,0,0],</span><br><span class="line"> [0,0,0,0,0,0,0,0,0,0,1,0,0],</span><br><span class="line"> [0,0,0,0,0,0,0,1,1,1,0,0,0],</span><br><span class="line"> [0,0,0,0,0,0,0,1,1,0,0,0,0]]</span><br><span class="line">对于上面这个给定矩阵应返回 6。注意答案不应该是11，因为岛屿只能包含水平或垂直的四个方向的‘1’。</span><br></pre></td></tr></table></figure>
<p>示例 2:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[[0,0,0,0,0,0,0,0]]</span><br><span class="line">对于上面这个给定的矩阵, 返回 0。</span><br><span class="line">注意: 给定的矩阵grid 的长度和宽度都不超过 50。</span><br></pre></td></tr></table></figure>
<p><strong>version1</strong>    <br>
过程：  <br>
<image src="https://res.cloudinary.com/sunflower/image/upload/v1546343789/Blog/695_process.png" width="350"><br>
成绩：<br>
<image src="https://res.cloudinary.com/sunflower/image/upload/v1546343789/Blog/695_score.png" width="350">  <br>
与<a href="#200"><code>200. 岛屿的个数</code></a>类似，采用深度优先搜索的思想，200那题是计算岛屿的个数，这题计算岛屿的大小，大同小异。</image></image></p>
<p><strong>代码</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maxAreaOfIsland</span><span class="params">(self, grid)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type grid: List[List[int]]</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        res = [<span class="number">0</span>]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(grid)):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(len(grid[<span class="number">0</span>])):</span><br><span class="line">                area = <span class="number">0</span></span><br><span class="line">                tmp = self.dfs(grid, i, j, area)</span><br><span class="line">                <span class="keyword">if</span> tmp:</span><br><span class="line">                    res.append(tmp)</span><br><span class="line">        <span class="keyword">return</span> max(res)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">dfs</span><span class="params">(self, grid, i, j, area)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> i &lt; <span class="number">0</span> <span class="keyword">or</span> j &lt; <span class="number">0</span> <span class="keyword">or</span> i &gt;= len(grid) <span class="keyword">or</span> j &gt;= len(grid[<span class="number">0</span>]) <span class="keyword">or</span> grid[i][j] != <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        grid[i][j] = <span class="string">'#'</span></span><br><span class="line">        area = <span class="number">1</span></span><br><span class="line">        down = self.dfs(grid, i + <span class="number">1</span>, j, area)</span><br><span class="line">        <span class="keyword">if</span> down:</span><br><span class="line">            area += down</span><br><span class="line">        up = self.dfs(grid, i<span class="number">-1</span>, j, area)</span><br><span class="line">        <span class="keyword">if</span> up:</span><br><span class="line">            area += up</span><br><span class="line">        right = self.dfs(grid, i, j+<span class="number">1</span>, area)</span><br><span class="line">        <span class="keyword">if</span> right:</span><br><span class="line">            area += right</span><br><span class="line">        left = self.dfs(grid, i, j<span class="number">-1</span>, area)</span><br><span class="line">        <span class="keyword">if</span> left:</span><br><span class="line">            area += left</span><br><span class="line">        <span class="keyword">return</span> area</span><br></pre></td></tr></table></figure>
<h2 id="300-最长上升子序列"><a class="header-anchor" href="#300-最长上升子序列"></a>300. 最长上升子序列</h2>
<p>状态：不会     <br>
<strong>题目</strong>  <br>
给定一个无序的整数数组，找到其中最长上升子序列的长度。</p>
<p>示例:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: [10,9,2,5,3,7,101,9,18]</span><br><span class="line">输出: 4 </span><br><span class="line">解释: 最长的上升子序列是 [2,3,7,101]，它的长度是 4。</span><br></pre></td></tr></table></figure>
<p>说明:<br>
可能会有多种最长上升子序列的组合，你只需要输出对应的长度即可。<br>
你算法的时间复杂度应该为 O(n2) 。<br>
进阶: 你能将算法的时间复杂度降低到 O(n log n) 吗?</p>
<p><strong>标准答案</strong>    <br>
动态规划，设置两个指针i,j以及一个长度与给定数组相同的数组T，核心公式：<code>T[i]=max(T[i],T[j]+1)</code>。  <br>
具体讲解见Youtube：<a href="https://www.youtube.com/watch?v=CE2b_-XfVDk" target="_blank" rel="noopener">https://www.youtube.com/watch?v=CE2b_-XfVDk</a></p>
<p><strong>代码</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">lengthOfLIS</span><span class="params">(self, nums)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type nums: List[int]</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        res = []</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(nums)):</span><br><span class="line">            tmp = self.find_bigger(cur=nums[i], rest=nums[i+<span class="number">1</span>:])</span><br><span class="line">            <span class="keyword">if</span> tmp!= <span class="keyword">None</span>:</span><br><span class="line">                res.append(tmp+<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> max(res)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">find_bigger</span><span class="params">(self, cur, rest)</span>:</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(rest)):</span><br><span class="line">            <span class="keyword">if</span> rest[i] &gt; cur:</span><br><span class="line">                tmpp = self.find_bigger(rest[i], rest[i+<span class="number">1</span>:])</span><br><span class="line">                <span class="keyword">if</span> tmpp != <span class="keyword">None</span>:</span><br><span class="line">                    <span class="keyword">return</span> tmpp+<span class="number">1</span></span><br><span class="line">            <span class="keyword">elif</span> i == len(rest)<span class="number">-1</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    a = Solution()</span><br><span class="line">    print(a.lengthOfLIS(nums=[<span class="number">10</span>,<span class="number">9</span>,<span class="number">2</span>,<span class="number">5</span>,<span class="number">3</span>,<span class="number">7</span>,<span class="number">101</span>,<span class="number">9</span>,<span class="number">18</span>]))</span><br></pre></td></tr></table></figure>
<h2 id="416-分割等和子集-a-id-beibao"><a class="header-anchor" href="#416-分割等和子集-a-id-beibao"></a>416. 分割等和子集<a id="beibao"></a></h2>
<p>状态：不会     <br>
<strong>题目</strong>  <br>
给定一个只包含正整数的非空数组。是否可以将这个数组分割成两个子集，使得两个子集的元素和相等。</p>
<p>注意:<br>
每个数组中的元素不会超过 100<br>
数组的大小不会超过 200</p>
<p>示例 1:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: [1, 5, 11, 5]</span><br><span class="line">输出: true</span><br><span class="line">解释: 数组可以分割成 [1, 5, 5] 和 [11].</span><br></pre></td></tr></table></figure>
<p>示例 2:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: [1, 2, 3, 5]</span><br><span class="line">输出: false</span><br><span class="line">解释: 数组不能分割成两个元素和相等的子集.</span><br></pre></td></tr></table></figure>
<p><strong>标准答案</strong>    <br>
0/1背包问题，详细讲解见：<br>
<a href="https://www.youtube.com/watch?v=8LusJS5-AGo" target="_blank" rel="noopener">https://www.youtube.com/watch?v=8LusJS5-AGo</a>  <br>
这题背包的重量为sum/2,比背包问题简单，没有价值信息，更不用求价值最大值。</p>
<p><strong>代码</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">canPartition</span><span class="params">(self, nums)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type nums: List[int]</span></span><br><span class="line"><span class="string">        :rtype: bool</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        total = sum(nums)</span><br><span class="line">        <span class="keyword">if</span> total % <span class="number">2</span> == <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            total = int(total / <span class="number">2</span>)</span><br><span class="line">            dp = [[<span class="number">0</span> <span class="keyword">for</span> i <span class="keyword">in</span> range(total + <span class="number">1</span>)] <span class="keyword">for</span> j <span class="keyword">in</span> range(len(nums))]</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> range(nums[<span class="number">0</span>], total + <span class="number">1</span>):</span><br><span class="line">                dp[<span class="number">0</span>][i] = nums[<span class="number">0</span>]</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, len(nums)):</span><br><span class="line">                <span class="keyword">for</span> j <span class="keyword">in</span> range(nums[i], total + <span class="number">1</span>):</span><br><span class="line">                    dp[i][j] = max(dp[i - <span class="number">1</span>][j], dp[i - <span class="number">1</span>][j - nums[i]] + nums[i])</span><br><span class="line">            <span class="keyword">if</span> dp[len(nums) - <span class="number">1</span>][total] != total:</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">True</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    a = Solution()</span><br><span class="line">    print(a.canPartition(nums=[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>]))</span><br></pre></td></tr></table></figure>
<h2 id="322-零钱兑换"><a class="header-anchor" href="#322-零钱兑换"></a>322. 零钱兑换</h2>
<p>状态：不会     <br>
<strong>题目</strong>  <br>
给定不同面额的硬币 coins 和一个总金额 amount。<br>
编写一个函数来计算可以凑成总金额所需的最少的硬币个数。<br>
如果没有任何一种硬币组合能组成总金额，返回 -1。</p>
<p>示例 1:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: coins = [1, 2, 5], amount = 11</span><br><span class="line">输出: 3 </span><br><span class="line">解释: 11 = 5 + 5 + 1</span><br></pre></td></tr></table></figure>
<p>示例 2:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: coins = [2], amount = 3</span><br><span class="line">输出: -1</span><br></pre></td></tr></table></figure>
<p>说明:<br>
你可以认为每种硬币的数量是无限的。</p>
<p><strong>标准答案</strong>    <br>
<a href="#beibao"><code>经典0/1背包问题</code></a>的变种类型——完全背包，与01背包不同在于每种物品可以不止使用一次，物品个数是无限的。  <br>
解题关键在于当未计算或者使用该硬币，硬币总数量下降的就更新<code>dp[i]</code>。</p>
<p><strong>代码</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">coinChange</span><span class="params">(self, coins, amount)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type coins: List[int]</span></span><br><span class="line"><span class="string">        :type amount: int</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        dp = [<span class="number">-1</span>] * (amount + <span class="number">1</span>)</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, amount + <span class="number">1</span>):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">0</span>, len(coins)):</span><br><span class="line">                <span class="keyword">if</span> i &gt;= coins[j] <span class="keyword">and</span> dp[i - coins[j]] != <span class="number">-1</span>:</span><br><span class="line">                    <span class="keyword">if</span> dp[i] == <span class="number">-1</span> <span class="keyword">or</span> dp[i] &gt; dp[i - coins[j]] + <span class="number">1</span>:</span><br><span class="line">                        dp[i] = dp[i - coins[j]] + <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> dp[amount]</span><br><span class="line">        </span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    a = Solution()</span><br><span class="line">    print(a.coinChange(coins = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">5</span>], amount = <span class="number">11</span>))</span><br></pre></td></tr></table></figure>
<h2 id="377-组合总和-ⅳ-a-id-wanquanbeibao"><a class="header-anchor" href="#377-组合总和-ⅳ-a-id-wanquanbeibao"></a>377. 组合总和 Ⅳ<a id="wanquanbeibao"></a></h2>
<p>状态：不会     <br>
<strong>题目</strong>  <br>
给定一个由正整数组成且不存在重复数字的数组，找出和为给定目标正整数的组合的个数。</p>
<p>示例:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">nums = [1, 2, 3]</span><br><span class="line">target = 4</span><br><span class="line"></span><br><span class="line">所有可能的组合为：</span><br><span class="line">(1, 1, 1, 1)</span><br><span class="line">(1, 1, 2)</span><br><span class="line">(1, 2, 1)</span><br><span class="line">(1, 3)</span><br><span class="line">(2, 1, 1)</span><br><span class="line">(2, 2)</span><br><span class="line">(3, 1)</span><br></pre></td></tr></table></figure>
<p>请注意，顺序不同的序列被视作不同的组合。<br>
因此输出为 7。</p>
<p><strong>标准答案</strong>    <br>
<a href="#beibao"><code>经典0/1背包问题</code></a>的变种类型——完全背包，与Leetcode322相似，都是物品可以无限次使用，但是dp数组里记录的是不同组合个数。</p>
<p><strong>代码</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">combinationSum4</span><span class="params">(self, nums, target)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type nums: List[int]</span></span><br><span class="line"><span class="string">        :type target: int</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        dp = [<span class="number">0</span>] * (target + <span class="number">1</span>)</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">1</span>  <span class="comment"># if num == target</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, target + <span class="number">1</span>):</span><br><span class="line">            <span class="keyword">for</span> num <span class="keyword">in</span> nums:</span><br><span class="line">                <span class="keyword">if</span> i &gt;= num:</span><br><span class="line">                    dp[i] += dp[i - num]</span><br><span class="line">        <span class="keyword">return</span> dp[target]</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    a = Solution()</span><br><span class="line">    print(a.combinationSum4(nums = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>], target = <span class="number">4</span>))</span><br></pre></td></tr></table></figure>
<h2 id="474-一和零"><a class="header-anchor" href="#474-一和零"></a>474. 一和零</h2>
<p>状态：不会     <br>
<strong>题目</strong>  <br>
在计算机界中，我们总是追求用有限的资源获取最大的收益。<br>
现在，假设你分别支配着 m 个 0 和 n 个 1。另外，还有一个仅包含 0 和 1 字符串的数组。<br>
你的任务是使用给定的 m 个 0 和 n 个 1 ，找到能拼出存在于数组中的字符串的最大数量。每个 0 和 1 至多被使用一次。</p>
<p>注意:<br>
给定 0 和 1 的数量都不会超过 100。<br>
给定字符串数组的长度不会超过 600。</p>
<p>示例 1:<br>
输入: Array = {“10”, “0001”, “111001”, “1”, “0”}, m = 5, n = 3<br>
输出: 4<br>
解释: 总共 4 个字符串可以通过 5 个 0 和 3 个 1 拼出，即 “10”,“0001”,“1”,“0” 。</p>
<p>示例 2:<br>
输入: Array = {“10”, “0”, “1”}, m = 1, n = 1<br>
输出: 2<br>
解释: 你可以拼出 “10”，但之后就没有剩余数字了。更好的选择是拼出 “0” 和 “1” 。</p>
<p><strong>标准答案</strong>    <br>
<a href="#beibao"><code>经典0/1背包问题</code></a>的变种类型——多维背包问题，不仅考虑物品的重量，而是要衡量物品的重量和体积，并且这里求的不是背包的最大价值，而是可能性中包含的最大字符串个数。</p>
<p><strong>代码</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">findMaxForm</span><span class="params">(self, strs, m, n)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type strs: List[str]</span></span><br><span class="line"><span class="string">        :type m: int</span></span><br><span class="line"><span class="string">        :type n: int</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        dp = [[<span class="number">0</span>] * (n + <span class="number">1</span>) <span class="keyword">for</span> _ <span class="keyword">in</span> range(m + <span class="number">1</span>)]</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> item <span class="keyword">in</span> strs:</span><br><span class="line">            z = item.count(<span class="string">'0'</span>)</span><br><span class="line">            o = item.count(<span class="string">'1'</span>)</span><br><span class="line">            <span class="keyword">for</span> x <span class="keyword">in</span> range(m, <span class="number">-1</span>, <span class="number">-1</span>):</span><br><span class="line">                <span class="keyword">for</span> y <span class="keyword">in</span> range(n, <span class="number">-1</span>, <span class="number">-1</span>):</span><br><span class="line">                    <span class="keyword">if</span> x &gt;= z <span class="keyword">and</span> y &gt;= o:</span><br><span class="line">                        dp[x][y] = max(<span class="number">1</span> + dp[x - z][y - o], dp[x][y])</span><br><span class="line">        <span class="keyword">return</span> dp[m][n]</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    a = Solution()</span><br><span class="line">    print(a.findMaxForm(strs=[<span class="string">"10"</span>, <span class="string">"0001"</span>, <span class="string">"111001"</span>, <span class="string">"1"</span>, <span class="string">"0"</span>], m = <span class="number">5</span>, n = <span class="number">3</span>))</span><br></pre></td></tr></table></figure>
<h2 id="139-单词拆分"><a class="header-anchor" href="#139-单词拆分"></a>139. 单词拆分</h2>
<p>状态：不会     <br>
<strong>题目</strong>  <br>
给定一个非空字符串 s 和一个包含非空单词列表的字典 wordDict，判定 s 是否可以被空格拆分为一个或多个在字典中出现的单词。</p>
<p>说明：<br>
拆分时可以重复使用字典中的单词。<br>
你可以假设字典中没有重复的单词。</p>
<p>示例 1：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: s = &quot;leetcode&quot;, wordDict = [&quot;leet&quot;, &quot;code&quot;]</span><br><span class="line">输出: true</span><br><span class="line">解释: 返回 true 因为 &quot;leetcode&quot; 可以被拆分成 &quot;leet code&quot;。</span><br></pre></td></tr></table></figure>
<p>示例 2：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入: s = &quot;applepenapple&quot;, wordDict = [&quot;apple&quot;, &quot;pen&quot;]</span><br><span class="line">输出: true</span><br><span class="line">解释: 返回 true 因为 &quot;applepenapple&quot; 可以被拆分成 &quot;apple pen apple&quot;。</span><br><span class="line">     注意你可以重复使用字典中的单词。</span><br></pre></td></tr></table></figure>
<p>示例 3：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: s = &quot;catsandog&quot;, wordDict = [&quot;cats&quot;, &quot;dog&quot;, &quot;sand&quot;, &quot;and&quot;, &quot;cat&quot;]</span><br><span class="line">输出: false</span><br></pre></td></tr></table></figure>
<p><strong>标准答案</strong>    <br>
属于<a href="#wanquanbeibao"><code>完全背包问题</code></a>,考察的标准不再是体重，价值之类的数值型标准了，而是字符串。dp数组记录当前位置i是否可分。</p>
<p><strong>代码</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">wordBreak</span><span class="params">(self, s, wordDict)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type s: str</span></span><br><span class="line"><span class="string">        :type wordDict: List[str]</span></span><br><span class="line"><span class="string">        :rtype: bool</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        dp = [<span class="keyword">False</span>] * (len(s) + <span class="number">1</span>)  <span class="comment"># dp[i] means s[:i+1] can be segmented into words in the wordDicts</span></span><br><span class="line">        dp[<span class="number">0</span>] = <span class="keyword">True</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(s)):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(i+<span class="number">1</span>, len(s)):</span><br><span class="line">                <span class="keyword">if</span> dp[i] <span class="keyword">and</span> s[i: j] <span class="keyword">in</span> wordDict:</span><br><span class="line">                    dp[j] = <span class="keyword">True</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> dp[<span class="number">-1</span>]</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    a = Solution()</span><br><span class="line">    print(a.wordBreak(s=<span class="string">"catsandog"</span>, wordDict=[<span class="string">"cats"</span>, <span class="string">"dog"</span>, <span class="string">"sand"</span>, <span class="string">"and"</span>, <span class="string">"cat"</span>]))</span><br></pre></td></tr></table></figure>
<h2 id="494-目标和"><a class="header-anchor" href="#494-目标和"></a>494. 目标和</h2>
<p>状态：不会     <br>
<strong>题目</strong>  <br>
给定一个非负整数数组，a1, a2, …, an, 和一个目标数，S。现在你有两个符号 + 和 -。<br>
对于数组中的任意一个整数，你都可以从 + 或 -中选择一个符号添加在前面。</p>
<p>返回可以使最终数组和为目标数 S 的所有添加符号的方法数。</p>
<p>示例 1:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">输入: nums: [1, 1, 1, 1, 1], S: 3</span><br><span class="line">输出: 5</span><br><span class="line">解释: </span><br><span class="line">-1+1+1+1+1 = 3</span><br><span class="line">+1-1+1+1+1 = 3</span><br><span class="line">+1+1-1+1+1 = 3</span><br><span class="line">+1+1+1-1+1 = 3</span><br><span class="line">+1+1+1+1-1 = 3</span><br><span class="line"></span><br><span class="line">一共有5种方法让最终目标和为3。</span><br></pre></td></tr></table></figure>
<p>注意:<br>
数组的长度不会超过20，并且数组中的值全为正数。<br>
初始的数组的和不会超过1000。<br>
保证返回的最终结果为32位整数。</p>
<p><strong>标准答案</strong>    <br>
这题要根据公式推导转换为背包问题  <br>
在nums中，有部分正数和负数。p表示所有正数的集合，q表示所有负数的集合，那么有sum§ - sum(q) = S，<br>
sum§ + sum(q) = sum(all)  <br>
以上两个公式转换可得：<br>
sum§ = (sum(all) + S)/2  <br>
那么，这个问题转换为单纯的背包价值问题。选择将不同价值的物品放入背包与否。</p>
<p><strong>代码</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">findTargetSumWays</span><span class="params">(self, nums, S)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type nums: List[int]</span></span><br><span class="line"><span class="string">        :type S: int</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        s = sum(nums)</span><br><span class="line">        N = s + S</span><br><span class="line">        <span class="keyword">if</span> N % <span class="number">2</span> <span class="keyword">or</span> S &gt; s: <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        N = N // <span class="number">2</span></span><br><span class="line">        dp = [<span class="number">0</span> <span class="keyword">for</span> _ <span class="keyword">in</span> range(N + <span class="number">1</span>)]</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> num <span class="keyword">in</span> nums:</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> range(N, num - <span class="number">1</span>, <span class="number">-1</span>):</span><br><span class="line">                dp[i] += dp[i - num]</span><br><span class="line">        <span class="keyword">return</span> dp[<span class="number">-1</span>]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    a = Solution()</span><br><span class="line">    print(a.findTargetSumWays(nums=[<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>], S=<span class="number">3</span>))</span><br></pre></td></tr></table></figure>
<h2 id="547-朋友圈-a-id-547"><a class="header-anchor" href="#547-朋友圈-a-id-547"></a>547. 朋友圈<a id="547"></a></h2>
<p>状态：不会     <br>
<strong>题目</strong>  <br>
班上有 N 名学生。其中有些人是朋友，有些则不是。他们的友谊具有是传递性。<br>
如果已知 A 是 B 的朋友，B 是 C 的朋友，那么我们可以认为 A 也是 C 的朋友。<br>
所谓的朋友圈，是指所有朋友的集合。</p>
<p>给定一个 N * N 的矩阵 M，表示班级中学生之间的朋友关系。<br>
如果M[i][j] = 1，表示已知第 i 个和 j 个学生互为朋友关系，否则为不知道。<br>
你必须输出所有学生中的已知的朋友圈总数。</p>
<p>示例 1:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">输入: </span><br><span class="line">[[1,1,0],</span><br><span class="line"> [1,1,0],</span><br><span class="line"> [0,0,1]]</span><br><span class="line">输出: 2 </span><br><span class="line">说明：已知学生0和学生1互为朋友，他们在一个朋友圈。</span><br><span class="line">第2个学生自己在一个朋友圈。所以返回2。</span><br></pre></td></tr></table></figure>
<p>示例 2:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">输入: </span><br><span class="line">[[1,1,0],</span><br><span class="line"> [1,1,1],</span><br><span class="line"> [0,1,1]]</span><br><span class="line">输出: 1</span><br><span class="line">说明：已知学生0和学生1互为朋友，学生1和学生2互为朋友，所以学生0和学生2也是朋友，所以他们三个在一个朋友圈，返回1。</span><br></pre></td></tr></table></figure>
<p><strong>标准答案</strong>    <br>
这题有两种解题思路，一个是DFS，另一个是并查集。<br>
DFS：<br>
依次遍历每个人，查看当前这个人所有的关系网，如果这个人有新朋友，添加到已查看集合中去，并再次查看这个新朋友的关系网，依次循环往复。</p>
<p><strong>DFS代码</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">findCircleNum</span><span class="params">(self, M)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type M: List[List[int]]</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        N = len(M)</span><br><span class="line">        seen = set()</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">dfs</span><span class="params">(node)</span>:</span></span><br><span class="line">            <span class="keyword">for</span> nei, adj <span class="keyword">in</span> enumerate(M[node]):</span><br><span class="line">                <span class="keyword">if</span> adj <span class="keyword">and</span> nei <span class="keyword">not</span> <span class="keyword">in</span> seen:</span><br><span class="line">                    seen.add(nei)</span><br><span class="line">                    dfs(nei)</span><br><span class="line"></span><br><span class="line">        ans = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(N):</span><br><span class="line">            <span class="keyword">if</span> i <span class="keyword">not</span> <span class="keyword">in</span> seen:</span><br><span class="line">                dfs(i)</span><br><span class="line">                ans += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> ans</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    a = Solution()</span><br><span class="line">    print(a.findCircleNum(M=[[<span class="number">1</span>,<span class="number">1</span>,<span class="number">0</span>], [<span class="number">1</span>,<span class="number">1</span>,<span class="number">0</span>], [<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>]]))</span><br></pre></td></tr></table></figure>
<p><strong>并查集代码</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">class UnionFind(object):</span><br><span class="line">    def __init__(self, grid):</span><br><span class="line">        self.n = len(grid)</span><br><span class="line">        self.parent = [-1] * self.n</span><br><span class="line">        for idx in range(self.n):</span><br><span class="line">            self.parent[idx] = idx</span><br><span class="line"></span><br><span class="line">    def find(self, i):</span><br><span class="line">        if self.parent[i] != i:</span><br><span class="line">            self.parent[i] = self.find(self.parent[i])</span><br><span class="line">        return self.parent[i]</span><br><span class="line"></span><br><span class="line">    def union(self, x, y):</span><br><span class="line">        rootx = self.find(x)</span><br><span class="line">        rooty = self.find(y)</span><br><span class="line">        if rootx != rooty:</span><br><span class="line">            self.parent[rooty] = rootx</span><br><span class="line"></span><br><span class="line">    def diff_groups(self):</span><br><span class="line">        diff_groups = set()</span><br><span class="line">        for i in range(self.n):</span><br><span class="line">            diff_groups.add(self.find(i))</span><br><span class="line">        return len(diff_groups)</span><br><span class="line"></span><br><span class="line">class Solution(object):</span><br><span class="line">    def findCircleNum(self, M):</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        :type M: List[List[int]]</span><br><span class="line">        :rtype: int</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        n = len(M)</span><br><span class="line">        uf = UnionFind(M)</span><br><span class="line"></span><br><span class="line">        for i in range(n):</span><br><span class="line">            for j in range(n):</span><br><span class="line">                if M[i][j] == 1:</span><br><span class="line">                    uf.union(i, j)</span><br><span class="line"></span><br><span class="line">        return uf.diff_groups()</span><br><span class="line"></span><br><span class="line">if __name__ == &quot;__main__&quot;:</span><br><span class="line">    a = Solution()</span><br><span class="line">    M = [[1, 1, 0], [1, 1, 0], [0, 0, 1]]</span><br><span class="line">    print(a.findCircleNum(M=M))</span><br></pre></td></tr></table></figure>
<h2 id="128-最长连续序列"><a class="header-anchor" href="#128-最长连续序列"></a>128. 最长连续序列</h2>
<p>状态：第二遍通过11.11%     <br>
<strong>题目</strong>  <br>
给定一个未排序的整数数组，找出最长连续序列的长度。</p>
<p>要求算法的时间复杂度为 O(n)。</p>
<p>示例:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: [100, 4, 200, 1, 3, 2]</span><br><span class="line">输出: 4</span><br><span class="line">解释: 最长连续序列是 [1, 2, 3, 4]。它的长度为 4。</span><br></pre></td></tr></table></figure>
<p><strong>version2</strong>    <br>
过程：  <br>
<image src="https://res.cloudinary.com/sunflower/image/upload/v1548236321/Blog/128_process.png" width="350"><br>
成绩：<br>
<image src="https://res.cloudinary.com/sunflower/image/upload/v1548236319/Blog/128_score.png" width="350"></image></image></p>
<p><strong>代码</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">longestConsecutive</span><span class="params">(self, nums)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type nums: List[int]</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">if</span> nums == []:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        nums=sorted(list(set(nums)))</span><br><span class="line">        res = []</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(nums)):</span><br><span class="line">            tmp = nums[:i+<span class="number">1</span>]</span><br><span class="line">            <span class="keyword">if</span> res:</span><br><span class="line">                tmp_res = res[<span class="number">-1</span>]</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                tmp_res = <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> len(tmp) == <span class="number">1</span>:</span><br><span class="line">                tmp_res = <span class="number">1</span></span><br><span class="line">                res.append(tmp_res)</span><br><span class="line">            <span class="keyword">elif</span> res[<span class="number">-1</span>] &gt;= <span class="number">1</span>:</span><br><span class="line">                <span class="keyword">if</span> tmp[<span class="number">-1</span>] == tmp[<span class="number">-2</span>]+<span class="number">1</span>:</span><br><span class="line">                    tmp_res += <span class="number">1</span></span><br><span class="line">                    res[<span class="number">-1</span>] = tmp_res</span><br><span class="line">                <span class="keyword">elif</span> tmp[<span class="number">-1</span>] == tmp[<span class="number">-2</span>]:</span><br><span class="line">                    <span class="keyword">continue</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    res.append(<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> max(res)</span><br></pre></td></tr></table></figure>
<p><strong>标准答案</strong><br>
首先对数组去重即集合，遍历集合中的每个元素，并弹出该元素，找出比这个元素小1或者大1的元素，并分别更新连续值标记。</p>
<p><strong>标准代码</strong></p>
 <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">   <span class="function"><span class="keyword">def</span> <span class="title">longestConsecutive</span><span class="params">(self, nums)</span>:</span></span><br><span class="line">       <span class="string">"""</span></span><br><span class="line"><span class="string">       :type nums: List[int]</span></span><br><span class="line"><span class="string">       :rtype: int</span></span><br><span class="line"><span class="string">       """</span></span><br><span class="line">       num = set(nums)</span><br><span class="line">       maxLen = <span class="number">0</span></span><br><span class="line">       <span class="keyword">while</span> num:</span><br><span class="line">           n = num.pop()</span><br><span class="line">           i = n + <span class="number">1</span></span><br><span class="line">           l1 = <span class="number">0</span></span><br><span class="line">           l2 = <span class="number">0</span></span><br><span class="line">           <span class="keyword">while</span> i <span class="keyword">in</span> num:</span><br><span class="line">               num.remove(i)</span><br><span class="line">               i += <span class="number">1</span></span><br><span class="line">               l1 += <span class="number">1</span></span><br><span class="line">           i = n - <span class="number">1</span></span><br><span class="line">           <span class="keyword">while</span> i <span class="keyword">in</span> num:</span><br><span class="line">               num.remove(i)</span><br><span class="line">               i -= <span class="number">1</span></span><br><span class="line">               l2 += <span class="number">1</span></span><br><span class="line">           maxLen = max(maxLen, l1 + l2 + <span class="number">1</span>)</span><br><span class="line">       <span class="keyword">return</span> maxLen</span><br></pre></td></tr></table></figure>
<h2 id="130-被围绕的区域"><a class="header-anchor" href="#130-被围绕的区域"></a>130. 被围绕的区域</h2>
<p>状态：不会<br>
<strong>题目</strong>  <br>
给定一个二维的矩阵，包含 ‘X’ 和 ‘O’（字母 O）。<br>
找到所有被 ‘X’ 围绕的区域，并将这些区域里所有的 ‘O’ 用 ‘X’ 填充。</p>
<p>示例:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">X X X X</span><br><span class="line">X O O X</span><br><span class="line">X X O X</span><br><span class="line">X O X X</span><br></pre></td></tr></table></figure>
<p>运行你的函数后，矩阵变为：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">X X X X</span><br><span class="line">X X X X</span><br><span class="line">X X X X</span><br><span class="line">X O X X</span><br></pre></td></tr></table></figure>
<p>解释:<br>
被围绕的区间不会存在于边界上，换句话说，任何边界上的 ‘O’ 都不会被填充为 ‘X’。<br>
任何不在边界上，或不与边界上的 ‘O’ 相连的 ‘O’ 最终都会被填充为 ‘X’。<br>
如果两个元素在水平或垂直方向相邻，则称它们是“相连”的。</p>
<p><strong>标准答案</strong>  <br>
这一题与<a href="#200"><code>200. 岛屿的个数</code></a>以及<a href="#695"><code>695. 岛屿的最大面积</code></a>背景类似，解题关键在于找到边界，题目中的关键信息是把除边界以外的‘O’改成‘X’，那么就应该找到边界‘O’，不仅是四周的‘O’，还包括与边界‘O’相连的‘O’，这里就用到了深度优先搜索。</p>
<p><strong>标准代码</strong></p>
 <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">solve</span><span class="params">(self, board)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type board: List[List[str]]</span></span><br><span class="line"><span class="string">        :rtype: void Do not return anything, modify board in-place instead.</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        alive, v = set(), set()</span><br><span class="line">        <span class="keyword">for</span> r <span class="keyword">in</span> range(len(board)):</span><br><span class="line">            <span class="keyword">for</span> c <span class="keyword">in</span> range(len(board[r])):</span><br><span class="line">                <span class="keyword">if</span> r == <span class="number">0</span> <span class="keyword">or</span> r == len(board) - <span class="number">1</span> <span class="keyword">or</span> c == <span class="number">0</span> <span class="keyword">or</span> c == len(board[<span class="number">0</span>]) - <span class="number">1</span>:</span><br><span class="line">                    self.traverse(board, r, c, alive)</span><br><span class="line">        <span class="keyword">for</span> r <span class="keyword">in</span> range(len(board)):</span><br><span class="line">            <span class="keyword">for</span> c <span class="keyword">in</span> range(len(board[r])):</span><br><span class="line">                <span class="keyword">if</span> board[r][c] == <span class="string">'O'</span> <span class="keyword">and</span> (r, c) <span class="keyword">not</span> <span class="keyword">in</span> alive:</span><br><span class="line">                    board[r][c] = <span class="string">'X'</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> board:</span><br><span class="line">            print(i)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">traverse</span><span class="params">(self, board, r, c, alive)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> (r, c) <span class="keyword">in</span> alive <span class="keyword">or</span> r &lt; <span class="number">0</span> <span class="keyword">or</span> r &gt; len(board) - <span class="number">1</span> <span class="keyword">or</span> c &lt; <span class="number">0</span> <span class="keyword">or</span> c &gt; len(board[<span class="number">0</span>]) - <span class="number">1</span> <span class="keyword">or</span> board[r][c] != <span class="string">'O'</span>:</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            alive.add((r, c))</span><br><span class="line">            self.traverse(board, r + <span class="number">1</span>, c, alive)</span><br><span class="line">            self.traverse(board, r, c + <span class="number">1</span>, alive)</span><br><span class="line">            self.traverse(board, r - <span class="number">1</span>, c, alive)</span><br><span class="line">            self.traverse(board, r, c - <span class="number">1</span>, alive)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    a = Solution()</span><br><span class="line">    a.solve(board=[[<span class="string">'X'</span>, <span class="string">'X'</span>, <span class="string">'X'</span>, <span class="string">'X'</span>], [<span class="string">'X'</span>, <span class="string">'O'</span>, <span class="string">'O'</span>, <span class="string">'X'</span>], [<span class="string">'X'</span>, <span class="string">'X'</span>, <span class="string">'O'</span>, <span class="string">'X'</span>], [<span class="string">'X'</span>, <span class="string">'O'</span>, <span class="string">'X'</span>, <span class="string">'X'</span>]])</span><br></pre></td></tr></table></figure>
<h2 id="3-无重复字符的最长子串"><a class="header-anchor" href="#3-无重复字符的最长子串"></a>3. 无重复字符的最长子串</h2>
<p>状态：不会<br>
<strong>题目</strong>  <br>
给定一个字符串，请你找出其中不含有重复字符的 最长子串 的长度。<br>
示例 1:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: &quot;abcabcbb&quot;</span><br><span class="line">输出: 3 </span><br><span class="line">解释: 因为无重复字符的最长子串是 &quot;abc&quot;，所以其长度为 3。</span><br></pre></td></tr></table></figure>
<p>示例 2:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: &quot;bbbbb&quot;</span><br><span class="line">输出: 1</span><br><span class="line">解释: 因为无重复字符的最长子串是 &quot;b&quot;，所以其长度为 1。</span><br></pre></td></tr></table></figure>
<p>示例 3:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入: &quot;pwwkew&quot;</span><br><span class="line">输出: 3</span><br><span class="line">解释: 因为无重复字符的最长子串是 &quot;wke&quot;，所以其长度为 3。  </span><br><span class="line">请注意，你的答案必须是 子串 的长度，&quot;pwke&quot; 是一个子序列，不是子串。</span><br></pre></td></tr></table></figure>
<p><strong>标准答案</strong>  <br>
题目要求找到最大的不重复子串，运用双指针方法，详细解释见<br>
<a href="https://zhuanlan.zhihu.com/p/36074066" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/36074066</a></p>
<p><strong>代码</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">lengthOfLongestSubstring</span><span class="params">(self, s)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type s: str</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        dict = &#123;&#125;</span><br><span class="line">        begin, res = <span class="number">-1</span>, <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> end <span class="keyword">in</span> range(len(s)):</span><br><span class="line">            <span class="keyword">if</span> s[end] <span class="keyword">in</span> dict <span class="keyword">and</span> begin &lt; dict[s[end]]:</span><br><span class="line">                begin = dict[s[end]]</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                res = max(res, end-begin)<span class="comment">#end-begin记录目前不重复子串的长度，res是目前最大不重复子串的长度</span></span><br><span class="line">            dict[s[end]] = end</span><br><span class="line">        <span class="keyword">return</span> res</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    a = Solution()</span><br><span class="line">    print(a.lengthOfLongestSubstring(s=<span class="string">"pwwkew"</span>))</span><br></pre></td></tr></table></figure>
<h2 id="684-冗余连接-a-id-684"><a class="header-anchor" href="#684-冗余连接-a-id-684"></a>684. 冗余连接<a id="684"></a></h2>
<p>状态：不会<br>
<strong>题目</strong>  <br>
在本问题中, 树指的是一个连通且无环的无向图。<br>
输入一个图，该图由一个有着N个节点 (节点值不重复1, 2, …, N) 的树及一条附加的边构成。<br>
附加的边的两个顶点包含在1到N中间，这条附加的边不属于树中已存在的边。<br>
结果图是一个以边组成的二维数组。每一个边的元素是一对[u, v] ，满足 u &lt; v，表示连接顶点u 和v的无向图的边。<br>
返回一条可以删去的边，使得结果图是一个有着N个节点的树。如果有多个答案，则返回二维数组中最后出现的边。<br>
答案边[u, v] 应满足相同的格式 u &lt; v。</p>
<p>示例 1：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">输入: [[1,2], [1,3], [2,3]]</span><br><span class="line">输出: [2,3]</span><br><span class="line">解释: 给定的无向图为:</span><br><span class="line">  1</span><br><span class="line"> / \</span><br><span class="line">2 - 3</span><br></pre></td></tr></table></figure>
<p>示例 2：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">输入: [[1,2], [2,3], [3,4], [1,4], [1,5]]</span><br><span class="line">输出: [1,4]</span><br><span class="line">解释: 给定的无向图为:</span><br><span class="line">5 - 1  - 2</span><br><span class="line">   |   |</span><br><span class="line">   4  - 3</span><br></pre></td></tr></table></figure>
<p>注意:<br>
输入的二维数组大小在 3 到 1000。<br>
二维数组中的整数在1到N之间，其中N是输入数组的大小。</p>
<p><strong>标准答案</strong>  <br>
题目看着就很烦，他想表达的意思是找出使得图连通的最后一条边，删去这个边，输入的图就不再连通了，这一题参考博客<br>
<a href="http://wulc.me/2017/10/12/LeetCode%20%E8%A7%A3%E9%A2%98%E6%8A%A5%E5%91%8A(684,685,721)-%E5%B9%B6%E6%9F%A5%E9%9B%86%E4%BB%8B%E7%BB%8D%E5%8F%8A%E5%BA%94%E7%94%A8/" target="_blank" rel="noopener">http://wulc.me/2017/10/12/LeetCode 解题报告(684,685,721)-并查集介绍及应用/</a>  <br>
可以更好地理解<strong>并查集</strong>这种数据结构，并提到了路径压缩和按等级合并，这两个步骤可以降低算法的时间复杂度。</p>
<p><strong>代码</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UnionFindSet</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.parents = list(range(<span class="number">1001</span>))</span><br><span class="line">        self.rank = [<span class="number">0</span>] * <span class="number">1001</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">find</span><span class="params">(self, val)</span>:</span></span><br><span class="line">        <span class="string">"""find with path compression"""</span></span><br><span class="line">        <span class="keyword">if</span> self.parents[val] != val:</span><br><span class="line">            self.parents[val] = self.find(self.parents[val])</span><br><span class="line">        <span class="keyword">return</span> self.parents[val]</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">union</span><span class="params">(self, v1, v2)</span>:</span></span><br><span class="line">        <span class="string">"""union by rank, check whether union two vertics will lead to a cycle"""</span></span><br><span class="line">        p1, p2 = self.find(v1), self.find(v2)</span><br><span class="line">        <span class="keyword">if</span> p1 == p2:</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">True</span></span><br><span class="line">        <span class="keyword">elif</span> self.rank[p1] &gt; self.rank[p2]:</span><br><span class="line">            self.parents[p2] = p1</span><br><span class="line">        <span class="keyword">elif</span> self.rank[p1] &lt; self.rank[p2]:</span><br><span class="line">            self.parents[p1] = p2</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            self.rank[p2] += <span class="number">1</span></span><br><span class="line">            self.parents[p1] = p2</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">findRedundantConnection</span><span class="params">(self, edges)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type edges: List[List[int]]</span></span><br><span class="line"><span class="string">        :rtype: List[int]</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        ufs = UnionFindSet()</span><br><span class="line">        <span class="keyword">for</span> edge <span class="keyword">in</span> edges:</span><br><span class="line">            <span class="keyword">if</span> ufs.union(edge[<span class="number">0</span>], edge[<span class="number">1</span>]):</span><br><span class="line">                <span class="keyword">return</span> edge</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    a = Solution()</span><br><span class="line">    print(a.findRedundantConnection(edges=[[<span class="number">1</span>,<span class="number">2</span>], [<span class="number">2</span>,<span class="number">3</span>], [<span class="number">3</span>,<span class="number">4</span>], [<span class="number">1</span>,<span class="number">4</span>], [<span class="number">1</span>,<span class="number">5</span>]]))</span><br></pre></td></tr></table></figure>
<h2 id="685-冗余连接-ii-a-id-685"><a class="header-anchor" href="#685-冗余连接-ii-a-id-685"></a>685. 冗余连接 II<a id="685"></a></h2>
<p>状态：不会<br>
<strong>题目</strong>  <br>
在本问题中，有根树指满足以下条件的有向图。<br>
该树只有一个根节点，所有其他节点都是该根节点的后继。<br>
每一个节点只有一个父节点，除了根节点没有父节点。</p>
<p>输入一个有向图，该图由一个有着N个节点 (节点值不重复1, 2, …, N) 的树及一条附加的边构成。<br>
附加的边的两个顶点包含在1到N中间，这条附加的边不属于树中已存在的边。</p>
<p>结果图是一个以边组成的二维数组。<br>
每一个边的元素是一对[u, v]，用以表示有向图中连接顶点 u and v和顶点的边，其中父节点u是子节点v的一个父节点。</p>
<p>返回一条能删除的边，使得剩下的图是有N个节点的有根树。若有多个答案，返回最后出现在给定二维数组的答案。</p>
<p>示例 1:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">输入: [[1,2], [1,3], [2,3]]</span><br><span class="line">输出: [2,3]</span><br><span class="line">解释: 给定的有向图如下:</span><br><span class="line">  1</span><br><span class="line"> /  \</span><br><span class="line">v   v</span><br><span class="line">2 --&gt;3</span><br></pre></td></tr></table></figure>
<p>示例 2:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">输入: [[1,2], [2,3], [3,4], [4,1], [1,5]]</span><br><span class="line">输出: [4,1]</span><br><span class="line">解释: 给定的有向图如下:</span><br><span class="line">5  &lt;-  1  -&gt; 2</span><br><span class="line">     ^    |</span><br><span class="line">     |    v</span><br><span class="line">     4 &lt;-  3</span><br></pre></td></tr></table></figure>
<p>注意:<br>
二维数组大小的在3到1000范围内。<br>
二维数组中的每个整数在1到N之间，其中 N 是二维数组的大小。</p>
<p><strong>标准答案</strong>  <br>
这一题与<a href="#684"><code>Leetcode 684</code></a>相似，不过难度升级，从无向图变为有向图，要返回的边使得删除这条边之后输入的有向图变为一颗合格树。 而 合格树要求每个节点只有一个父节点，根据这个要求可以先筛选一遍，看图中是否存在多个父节点的点，那么要删除的边就在里面。<br>
参考博客：  <br>
<a href="http://wulc.me/2017/10/12/LeetCode%20%E8%A7%A3%E9%A2%98%E6%8A%A5%E5%91%8A(684,685,721)-%E5%B9%B6%E6%9F%A5%E9%9B%86%E4%BB%8B%E7%BB%8D%E5%8F%8A%E5%BA%94%E7%94%A8/" target="_blank" rel="noopener">http://wulc.me/2017/10/12/LeetCode 解题报告(684,685,721)-并查集介绍及应用/</a></p>
<p><strong>代码</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UnionFindSet</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.parents = list(range(<span class="number">1001</span>))</span><br><span class="line">        self.rank = [<span class="number">0</span>] * <span class="number">1001</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">find</span><span class="params">(self, val)</span>:</span></span><br><span class="line">        <span class="string">"""find with path compression"""</span></span><br><span class="line">        <span class="keyword">if</span> self.parents[val] != val:</span><br><span class="line">            self.parents[val] = self.find(self.parents[val])</span><br><span class="line">        <span class="keyword">return</span> self.parents[val]</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">union</span><span class="params">(self, v1, v2)</span>:</span></span><br><span class="line">        <span class="string">"""union by rank, check whether union two vertics will lead to a cycle"""</span></span><br><span class="line">        p1, p2 = self.find(v1), self.find(v2)</span><br><span class="line">        <span class="keyword">if</span> p1 == p2:</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">True</span></span><br><span class="line">        <span class="keyword">elif</span> self.rank[p1] &gt; self.rank[p2]:</span><br><span class="line">            self.parents[p2] = p1</span><br><span class="line">        <span class="keyword">elif</span> self.rank[p1] &lt; self.rank[p2]:</span><br><span class="line">            self.parents[p1] = p2</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            self.rank[p2] += <span class="number">1</span></span><br><span class="line">            self.parents[p1] = p2</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">findRedundantDirectedConnection</span><span class="params">(self, edges)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type edges: List[List[int]]</span></span><br><span class="line"><span class="string">        :rtype: List[int]</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        redundant_edges = <span class="keyword">None</span></span><br><span class="line">        count = &#123;&#125;</span><br><span class="line">        <span class="keyword">for</span> e <span class="keyword">in</span> edges:</span><br><span class="line">            <span class="keyword">if</span> e[<span class="number">1</span>] <span class="keyword">not</span> <span class="keyword">in</span> count:</span><br><span class="line">                count[e[<span class="number">1</span>]] = []</span><br><span class="line">            count[e[<span class="number">1</span>]].append(e)</span><br><span class="line">            <span class="keyword">if</span> len(count[e[<span class="number">1</span>]]) == <span class="number">2</span>:</span><br><span class="line">                redundant_edges = count[e[<span class="number">1</span>]]</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> redundant_edges:</span><br><span class="line">            ufs = UnionFindSet()</span><br><span class="line">            <span class="keyword">for</span> edge <span class="keyword">in</span> edges:</span><br><span class="line">                <span class="keyword">if</span> edge == redundant_edges[<span class="number">1</span>]:</span><br><span class="line">                    <span class="keyword">continue</span></span><br><span class="line">                <span class="keyword">if</span> ufs.union(edge[<span class="number">0</span>], edge[<span class="number">1</span>]):</span><br><span class="line">                    <span class="keyword">return</span> redundant_edges[<span class="number">0</span>]</span><br><span class="line">            <span class="keyword">return</span> redundant_edges[<span class="number">1</span>]</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            ufs = UnionFindSet()</span><br><span class="line">            <span class="keyword">for</span> edge <span class="keyword">in</span> edges:</span><br><span class="line">                <span class="keyword">if</span> ufs.union(edge[<span class="number">0</span>], edge[<span class="number">1</span>]):</span><br><span class="line">                    <span class="keyword">return</span> edge</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    a = Solution()</span><br><span class="line">    print(a.findRedundantDirectedConnection(edges=[[<span class="number">1</span>,<span class="number">2</span>], [<span class="number">1</span>,<span class="number">3</span>], [<span class="number">2</span>,<span class="number">3</span>]]))</span><br></pre></td></tr></table></figure>
<h2 id="721-账户合并-a-id-721"><a class="header-anchor" href="#721-账户合并-a-id-721"></a>721. 账户合并<a id="721"></a></h2>
<p>状态：不会<br>
<strong>题目</strong>  <br>
给定一个列表 accounts，每个元素 accounts[i] 是一个字符串列表，<br>
其中第一个元素 accounts[i][0] 是 名称 (name)，其余元素是 emails 表示该帐户的邮箱地址。</p>
<p>现在，我们想合并这些帐户。如果两个帐户都有一些共同的邮件地址，则两个帐户必定属于同一个人。<br>
请注意，即使两个帐户具有相同的名称，它们也可能属于不同的人，因为人们可能具有相同的名称。<br>
一个人最初可以拥有任意数量的帐户，但其所有帐户都具有相同的名称。</p>
<p>合并帐户后，按以下格式返回帐户：<br>
每个帐户的第一个元素是名称，其余元素是按顺序排列的邮箱地址。accounts 本身可以以任意顺序返回。</p>
<p>例子 1:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Input: </span><br><span class="line">accounts = [[&quot;John&quot;, &quot;johnsmith@mail.com&quot;, &quot;john00@mail.com&quot;], [&quot;John&quot;, &quot;johnnybravo@mail.com&quot;], </span><br><span class="line">[&quot;John&quot;, &quot;johnsmith@mail.com&quot;, &quot;john_newyork@mail.com&quot;], [&quot;Mary&quot;, &quot;mary@mail.com&quot;]]</span><br><span class="line">Output: [[&quot;John&quot;, &apos;john00@mail.com&apos;, &apos;john_newyork@mail.com&apos;, &apos;johnsmith@mail.com&apos;],  </span><br><span class="line">[&quot;John&quot;, &quot;johnnybravo@mail.com&quot;], [&quot;Mary&quot;, &quot;mary@mail.com&quot;]]</span><br><span class="line">Explanation: </span><br><span class="line">  第一个和第三个 John 是同一个人，因为他们有共同的电子邮件 &quot;johnsmith@mail.com&quot;。 </span><br><span class="line">  第二个 John 和 Mary 是不同的人，因为他们的电子邮件地址没有被其他帐户使用。</span><br><span class="line">  我们可以以任何顺序返回这些列表，例如答案[[&apos;Mary&apos;，&apos;mary@mail.com&apos;]，[&apos;John&apos;，&apos;johnnybravo@mail.com&apos;]，</span><br><span class="line">  [&apos;John&apos;，&apos;john00@mail.com&apos;，&apos;john_newyork@mail.com&apos;，&apos;johnsmith@mail.com&apos;]]仍然会被接受。</span><br></pre></td></tr></table></figure>
<p>注意：<br>
accounts的长度将在[1，1000]的范围内。<br>
accounts[i]的长度将在[1，10]的范围内。<br>
accounts[i][j]的长度将在[1，30]的范围内。</p>
<p><strong>标准答案</strong>  <br>
使用并查集或者DFS，这道题目里用到了<strong>路径压缩</strong>(找到u所在的树根v以后，把从u到v的路径上所有点的父亲都设置为v)，注意parent是父节点并不是根节点。怎么去并，去并谁也是要想清楚的，比如这一题我们要合并的是账号，那么遍历账号，根据邮箱一样这个筛选条件去合并。</p>
<p><strong>代码</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> defaultdict</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UnionFind</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, n)</span>:</span></span><br><span class="line">        self.parent = [i <span class="keyword">for</span> i <span class="keyword">in</span> range(n)]</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">find</span><span class="params">(self, x)</span>:</span></span><br><span class="line">        <span class="keyword">while</span> self.parent[x] != x:</span><br><span class="line">            self.parent[x] = self.parent[self.parent[x]]</span><br><span class="line">            x = self.parent[x]</span><br><span class="line">        <span class="keyword">return</span> x</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">union</span><span class="params">(self, x, y)</span>:</span></span><br><span class="line">        rootx = self.find(x)</span><br><span class="line">        rooty = self.find(y)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> rootx != rooty:</span><br><span class="line">            self.parent[rooty] = rootx</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">accountsMerge</span><span class="params">(self, accounts)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type accounts: List[List[str]]</span></span><br><span class="line"><span class="string">        :rtype: List[List[str]]</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        n = len(accounts)</span><br><span class="line">        uf = UnionFind(n)</span><br><span class="line"></span><br><span class="line">        dict = &#123;&#125;</span><br><span class="line">        <span class="keyword">for</span> i, a <span class="keyword">in</span> enumerate(accounts):</span><br><span class="line">            <span class="keyword">for</span> email <span class="keyword">in</span> a[<span class="number">1</span>:]:</span><br><span class="line">                <span class="keyword">if</span> email <span class="keyword">in</span> dict:</span><br><span class="line">                    r1, r2 = uf.find(i), uf.find(dict[email])</span><br><span class="line">                    uf.parent[r2] = r1</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    dict[email] = i</span><br><span class="line"></span><br><span class="line">        dict_res = defaultdict(set)</span><br><span class="line">        <span class="keyword">for</span> k <span class="keyword">in</span> range(n):</span><br><span class="line">            dict_res[uf.find(k)] |= set(accounts[k][<span class="number">1</span>:])</span><br><span class="line"></span><br><span class="line">        res = []</span><br><span class="line">        <span class="keyword">for</span> k,v <span class="keyword">in</span> dict_res.items():</span><br><span class="line">            res.append([accounts[k][<span class="number">0</span>]]+sorted(v))</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res</span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    a = Solution()</span><br><span class="line">    print(a.accountsMerge(accounts=[[<span class="string">"David"</span>,<span class="string">"David0@m.co"</span>,<span class="string">"David1@m.co"</span>],\</span><br><span class="line">                                    [<span class="string">"David"</span>,<span class="string">"David3@m.co"</span>,<span class="string">"David4@m.co"</span>],\</span><br><span class="line">                                    [<span class="string">"David"</span>,<span class="string">"David4@m.co"</span>,<span class="string">"David5@m.co"</span>],\</span><br><span class="line">                                    [<span class="string">"David"</span>,<span class="string">"David2@m.co"</span>,<span class="string">"David3@m.co"</span>],\</span><br><span class="line">                                    [<span class="string">"David"</span>,<span class="string">"David1@m.co"</span>,<span class="string">"David2@m.co"</span>]]))</span><br></pre></td></tr></table></figure>
<h2 id="763-划分字母区间-a-id-763"><a class="header-anchor" href="#763-划分字母区间-a-id-763"></a>763. 划分字母区间<a id="763"></a></h2>
<p>状态：不会<br>
<strong>题目</strong>  <br>
字符串 S 由小写字母组成。<br>
我们要把这个字符串划分为尽可能多的片段，同一个字母只会出现在其中的一个片段。<br>
返回一个表示每个字符串片段的长度的列表。</p>
<p>示例 1:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">输入: S = &quot;ababcbacadefegdehijhklij&quot;</span><br><span class="line">输出: [9,7,8]</span><br><span class="line">解释:</span><br><span class="line">划分结果为 &quot;ababcbaca&quot;, &quot;defegde&quot;, &quot;hijhklij&quot;。</span><br><span class="line">每个字母最多出现在一个片段中。</span><br><span class="line">像 &quot;ababcbacadefegde&quot;, &quot;hijhklij&quot; 的划分是错误的，因为划分的片段数较少。</span><br></pre></td></tr></table></figure>
<p>注意:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">S的长度在[1, 500]之间。</span><br><span class="line">S只包含小写字母&apos;a&apos;到&apos;z&apos;。</span><br></pre></td></tr></table></figure>
<p><strong>标准答案</strong>  <br>
记录每个字符出现的最后一个索引，遍历字符串时，将每个字符与记录索引对比从而求得每个字符区间。</p>
<p><strong>代码</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">partitionLabels</span><span class="params">(self, S)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type S: str</span></span><br><span class="line"><span class="string">        :rtype: List[int]</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        dic = dict()</span><br><span class="line">        <span class="keyword">for</span> i, ch <span class="keyword">in</span> enumerate(S):</span><br><span class="line">            dic[ch] = i</span><br><span class="line">        cnt = [<span class="number">-1</span>]</span><br><span class="line">        cur = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i, ch <span class="keyword">in</span> enumerate(S):</span><br><span class="line">            cur = max(cur, dic[ch])</span><br><span class="line">            <span class="keyword">if</span> i == cur:</span><br><span class="line">                cnt.append(cur)</span><br><span class="line">                cur = i + <span class="number">1</span></span><br><span class="line">        re = []</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, len(cnt)):</span><br><span class="line">            re.append(cnt[i] - cnt[i - <span class="number">1</span>])</span><br><span class="line">        <span class="keyword">return</span> re</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    a = Solution()</span><br><span class="line">    print(a.partitionLabels(S = <span class="string">"ababcbacadefegdehijhklij"</span>))</span><br></pre></td></tr></table></figure>
<h2 id="93-复原ip地址-a-id-93"><a class="header-anchor" href="#93-复原ip地址-a-id-93"></a>93. 复原IP地址<a id="93"></a></h2>
<p>状态：不会<br>
<strong>题目</strong>  <br>
给定一个只包含数字的字符串，复原它并返回所有可能的 IP 地址格式。</p>
<p>示例:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: <span class="string">"25525511135"</span></span><br><span class="line">输出: [<span class="string">"255.255.11.135"</span>, <span class="string">"255.255.111.35"</span>]</span><br></pre></td></tr></table></figure>
<p><strong>标准答案</strong>  <br>
DFS</p>
<p><strong>代码</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">restoreIpAddresses</span><span class="params">(self, s)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type s: str</span></span><br><span class="line"><span class="string">        :rtype: List[str]</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        res = []</span><br><span class="line">        self.dfs(s, <span class="number">0</span>, <span class="string">""</span>, res)</span><br><span class="line">        <span class="keyword">return</span> res</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">dfs</span><span class="params">(self, s, index, path, res)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> index == <span class="number">4</span>:</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> s:</span><br><span class="line">                res.append(path[:<span class="number">-1</span>])</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, <span class="number">4</span>):</span><br><span class="line">            <span class="keyword">if</span> i &lt;= len(s):</span><br><span class="line">                <span class="keyword">if</span> i == <span class="number">1</span>:</span><br><span class="line">                    self.dfs(s[<span class="number">1</span>:], index + <span class="number">1</span>, path + s[<span class="number">0</span>] + <span class="string">'.'</span>, res)</span><br><span class="line">                <span class="keyword">elif</span> i == <span class="number">2</span> <span class="keyword">and</span> s[<span class="number">0</span>] != <span class="string">'0'</span>:</span><br><span class="line">                    self.dfs(s[<span class="number">2</span>:], index + <span class="number">1</span>, path + s[:<span class="number">2</span>] + <span class="string">'.'</span>, res)</span><br><span class="line">                <span class="keyword">elif</span> i == <span class="number">3</span> <span class="keyword">and</span> s[<span class="number">0</span>] != <span class="string">'0'</span> <span class="keyword">and</span> int(s[:<span class="number">3</span>]) &lt; <span class="number">256</span>:</span><br><span class="line">                    self.dfs(s[<span class="number">3</span>:], index + <span class="number">1</span>, path + s[:<span class="number">3</span>] + <span class="string">'.'</span>, res)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    a = Solution()</span><br><span class="line">    print(a.restoreIpAddresses(s=<span class="string">"25525511135"</span>))</span><br></pre></td></tr></table></figure>
<h2 id="393-utf-8-编码验证"><a class="header-anchor" href="#393-utf-8-编码验证"></a>393. UTF-8 编码验证</h2>
<p>状态：空间复杂度未通过</p>
<p><strong>题目</strong>  <br>
UTF-8 中的一个字符可能的长度为 1 到 4 字节，遵循以下的规则：<br>
对于 1 字节的字符，字节的第一位设为0，后面7位为这个符号的unicode码。<br>
对于 n 字节的字符 (n &gt; 1)，第一个字节的前 n 位都设为1，第 n+1 位设为0，后面字节的前两位一律设为10。<br>
剩下的没有提及的二进制位，全部为这个符号的unicode码。<br>
这是 UTF-8 编码的工作方式：</p>
<table>
<thead>
<tr>
<th>Char. number range</th>
<th>UTF-8 octet sequence</th>
</tr>
</thead>
<tbody>
<tr>
<td>0000 0000-0000 007F</td>
<td>0xxxxxxx</td>
</tr>
<tr>
<td>0000 0080-0000 07FF</td>
<td>110xxxxx 10xxxxxx</td>
</tr>
<tr>
<td>0000 0800-0000 FFFF</td>
<td>1110xxxx 10xxxxxx 10xxxxxx</td>
</tr>
<tr>
<td>0001 0000-0010 FFFF</td>
<td>11110xxx 10xxxxxx 10xxxxxx 10xxxxxx</td>
</tr>
</tbody>
</table>
<p>给定一个表示数据的整数数组，返回它是否为有效的 utf-8 编码。</p>
<p>注意:<br>
输入是整数数组。只有每个整数的最低 8 个有效位用来存储数据。这意味着每个整数只表示 1 字节的数据。</p>
<p>示例 1:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">data = [197, 130, 1], 表示 8 位的序列: 11000101 10000010 00000001.</span><br><span class="line">返回 true 。</span><br><span class="line">这是有效的 utf-8 编码，为一个2字节字符，跟着一个1字节字符。</span><br></pre></td></tr></table></figure>
<p>示例 2:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">data = [235, 140, 4], 表示 8 位的序列: 11101011 10001100 00000100.</span><br><span class="line">返回 false 。</span><br><span class="line">前 3 位都是 1 ，第 4 位为 0 表示它是一个3字节字符。</span><br><span class="line">下一个字节是开头为 10 的延续字节，这是正确的。</span><br><span class="line">但第二个延续字节不以 10 开头，所以是不符合规则的。</span><br></pre></td></tr></table></figure>
<p><strong>代码</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">validUtf8</span><span class="params">(self, data)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type data: List[int]</span></span><br><span class="line"><span class="string">        :rtype: bool</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> data:</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">True</span></span><br><span class="line">        <span class="keyword">if</span> self.Binary(data[<span class="number">0</span>])[<span class="number">2</span>] == <span class="string">'0'</span>:</span><br><span class="line">            <span class="keyword">if</span> len(data) == <span class="number">1</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">True</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">return</span> self.validUtf8(data[<span class="number">1</span>:])</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            cB = self.countB(data[<span class="number">0</span>])</span><br><span class="line">            <span class="keyword">if</span> cB == <span class="number">1</span> <span class="keyword">or</span> cB &gt; <span class="number">4</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line">            <span class="keyword">if</span> len(data) &gt;= cB:</span><br><span class="line">                <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, cB):</span><br><span class="line">                    <span class="keyword">if</span> self.Binary(data[i])[<span class="number">2</span>:<span class="number">4</span>] != <span class="string">'10'</span>:</span><br><span class="line">                        <span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line">                <span class="keyword">return</span> self.validUtf8(data[cB:])</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">Binary</span><span class="params">(self, num)</span>:</span></span><br><span class="line">        b_num_len = len(bin(num))</span><br><span class="line">        <span class="keyword">if</span> b_num_len != <span class="number">10</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="string">'0b'</span>+<span class="string">'0'</span>*(<span class="number">10</span>-b_num_len)+bin(num)[<span class="number">2</span>:]</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> bin(num)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">countB</span><span class="params">(self, num)</span>:</span></span><br><span class="line">        cnt = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> b <span class="keyword">in</span> self.Binary(num)[<span class="number">2</span>:]:</span><br><span class="line">            <span class="keyword">if</span> b == <span class="string">'1'</span>:</span><br><span class="line">                cnt += <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">return</span> cnt</span><br><span class="line">        <span class="keyword">return</span> cnt</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    a = Solution()</span><br><span class="line">    print(a.validUtf8(data=[<span class="number">250</span>,<span class="number">145</span>,<span class="number">145</span>,<span class="number">145</span>,<span class="number">145</span>]))</span><br></pre></td></tr></table></figure>
<h2 id="851-喧闹和富有"><a class="header-anchor" href="#851-喧闹和富有"></a>851. 喧闹和富有</h2>
<p>状态：不会</p>
<p><strong>题目</strong>  <br>
在一组 N 个人（编号为 0, 1, 2, …, N-1）中，每个人都有不同数目的钱，以及不同程度的安静（quietness）。<br>
为了方便起见，我们将编号为 x 的人简称为 &quot;person x &quot;。</p>
<p>如果能够肯定 person x 比 person y 更有钱的话，我们会说 richer[i] = [x, y] 。注意 richer 可能只是有效观察的一个子集。<br>
另外，如果 person x 的安静程度为 q ，我们会说 quiet[x] = q 。</p>
<p>现在，返回答案 answer ，其中 answer[x] = y 的前提是，在所有拥有的钱不少于 person x 的人中，person y 是最安静的人（也就是安静值 quiet[y] 最小的人）。</p>
<p>示例：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">输入：richer = [[1,0],[2,1],[3,1],[3,7],[4,3],[5,3],[6,3]], quiet = [3,2,5,4,6,1,7,0]</span><br><span class="line">输出：[5,5,2,5,4,5,6,7]</span><br><span class="line">解释： </span><br><span class="line">answer[0] = 5，</span><br><span class="line">person 5 比 person 3 有更多的钱，person 3 比 person 1 有更多的钱，person 1 比 person 0 有更多的钱。</span><br><span class="line">唯一较为安静（有较低的安静值 quiet[x]）的人是 person 7，</span><br><span class="line">但是目前还不清楚他是否比 person 0 更有钱。</span><br><span class="line"></span><br><span class="line">answer[7] = 7，</span><br><span class="line">在所有拥有的钱肯定不少于 person 7 的人中(这可能包括 person 3，4，5，6 以及 7)，</span><br><span class="line">最安静(有较低安静值 quiet[x])的人是 person 7。</span><br><span class="line"></span><br><span class="line">其他的答案也可以用类似的推理来解释。</span><br></pre></td></tr></table></figure>
<p>提示：<br>
1 &lt;= quiet.length = N &lt;= 500<br>
0 &lt;= quiet[i] &lt; N，所有 quiet[i] 都不相同。<br>
0 &lt;= richer.length &lt;= N * (N-1) / 2<br>
0 &lt;= richer[i][j] &lt; N<br>
richer[i][0] != richer[i][1]<br>
richer[i] 都是不同的。<br>
对 richer 的观察在逻辑上是一致的。</p>
<p><strong>标准答案</strong>  <br>
综合运用动态规划和记忆存储，这道题最佳答案秒在对安静数组进行排序，导致首先遍历最安静的人，那么这个人对应的答案就是自己，因为符合比自己富有（包括自己），并且最安静的要求。  <br>
紧接着遍历比这个人穷的人，并且标记每个穷人的答案就是这个人，因为符合相对富有且最安静的要求。</p>
<p><strong>代码</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> collections</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">loudAndRich</span><span class="params">(self, richer, quiet)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type richer: List[List[int]]</span></span><br><span class="line"><span class="string">        :type quiet: List[int]</span></span><br><span class="line"><span class="string">        :rtype: List[int]</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        graph = collections.defaultdict(list)</span><br><span class="line">        <span class="keyword">for</span> a, b <span class="keyword">in</span> richer:</span><br><span class="line">            graph[a].append(b)</span><br><span class="line">        qi = [[q, i] <span class="keyword">for</span> i, q <span class="keyword">in</span> enumerate(quiet)]</span><br><span class="line"></span><br><span class="line">        <span class="comment"># !! look at me</span></span><br><span class="line">        qi.sort()</span><br><span class="line"></span><br><span class="line">        res = [<span class="number">-1</span>] * len(quiet)</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">search</span><span class="params">(i, t)</span>:</span></span><br><span class="line">            res[i] = t</span><br><span class="line">            <span class="keyword">for</span> adj <span class="keyword">in</span> graph[i]:</span><br><span class="line">                <span class="keyword">if</span> res[adj] == <span class="number">-1</span>:</span><br><span class="line">                    search(adj, t)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> q, i <span class="keyword">in</span> qi:</span><br><span class="line">            <span class="keyword">if</span> res[i] == <span class="number">-1</span>:</span><br><span class="line">                search(i, i)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    a = Solution()</span><br><span class="line">    print(a.loudAndRich(richer=[[<span class="number">0</span>,<span class="number">1</span>],[<span class="number">1</span>,<span class="number">2</span>]], quiet = [<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>]))</span><br></pre></td></tr></table></figure>
<h2 id="5-最长回文子串"><a class="header-anchor" href="#5-最长回文子串"></a>5. 最长回文子串</h2>
<p>状态：不会</p>
<p><strong>题目</strong>  <br>
给定一个字符串 s，找到 s 中最长的回文子串。你可以假设 s 的最大长度为 1000。</p>
<p>示例 1：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: &quot;babad&quot;  </span><br><span class="line">输出: &quot;bab&quot;   </span><br><span class="line">注意: &quot;aba&quot; 也是一个有效答案。</span><br></pre></td></tr></table></figure>
<p>示例 2：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: &quot;cbbd&quot;  </span><br><span class="line">输出: &quot;bb&quot;</span><br></pre></td></tr></table></figure>
<p><strong>标准答案</strong>  <br>
回文子串一共有两种类型：  <br>
1.aba<br>
2.abba  <br>
按照这两种类型的组成特点，依次从内到外遍历。利用记忆存储当前状态下的最长回文子串。</p>
<p><strong>代码</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">class Solution(object):</span><br><span class="line">    def longestPalindrome(self, s):</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        :type s: str</span><br><span class="line">        :rtype: str</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        res = &quot;&quot;</span><br><span class="line">    	  for i in xrange(len(s)):</span><br><span class="line">        	# odd case, like &quot;aba&quot;</span><br><span class="line">        	tmp = self.helper(s, i, i)</span><br><span class="line">        	if len(tmp) &gt; len(res):</span><br><span class="line">            res = tmp</span><br><span class="line">        	# even case, like &quot;abba&quot;</span><br><span class="line">        	tmp = self.helper(s, i, i+1)</span><br><span class="line">        	if len(tmp) &gt; len(res):</span><br><span class="line">            res = tmp</span><br><span class="line">    	  return res</span><br><span class="line">          </span><br><span class="line">    # get the longest palindrome, l, r are the middle indexes  		 # from inner to outer</span><br><span class="line">	  def helper(self, s, l, r):</span><br><span class="line">    	while l &gt;= 0 and r &lt; len(s) and s[l] == s[r]:</span><br><span class="line">        l -= 1; r += 1</span><br><span class="line">    	return s[l+1:r]</span><br></pre></td></tr></table></figure>
<h2 id="63-不同路径-ii"><a class="header-anchor" href="#63-不同路径-ii"></a>63. 不同路径 II</h2>
<p>状态：排名85.07%</p>
<p><strong>题目</strong>  <br>
一个机器人位于一个 m x n 网格的左上角 （起始点在下图中标记为“Start” ）。<br>
机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为“Finish”）。<br>
现在考虑网格中有障碍物。那么从左上角到右下角将会有多少条不同的路径？<br>
<image src="https://res.cloudinary.com/sunflower/image/upload/v1544446636/Blog/robot_maze.png" width="350"><br>
网格中的障碍物和空位置分别用 1 和 0 来表示。<br>
说明：m 和 n 的值均不超过 100。</image></p>
<p>示例 1:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">输入:</span><br><span class="line">[</span><br><span class="line">  [0,0,0],</span><br><span class="line">  [0,1,0],</span><br><span class="line">  [0,0,0]</span><br><span class="line">]</span><br><span class="line">输出: 2</span><br><span class="line">解释:</span><br><span class="line">3x3 网格的正中间有一个障碍物。</span><br><span class="line">从左上角到右下角一共有 2 条不同的路径：</span><br><span class="line">1. 向右 -&gt; 向右 -&gt; 向下 -&gt; 向下</span><br><span class="line">2. 向下 -&gt; 向下 -&gt; 向右 -&gt; 向右</span><br></pre></td></tr></table></figure>
<p><strong>标准答案</strong>  <br>
<a href="#62"><code>62. 不同路径</code></a>的衍生版本，主要难点在于边界条件，在for循环之后要特别考虑有一些特殊情况容易漏掉。</p>
<p><strong>代码</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">class Solution(object):</span><br><span class="line">    def uniquePathsWithObstacles(self, obstacleGrid):</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        :type obstacleGrid: List[List[int]]</span><br><span class="line">        :rtype: int</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        if obstacleGrid[0][0] == 1:</span><br><span class="line">            return 0</span><br><span class="line">        m = len(obstacleGrid)</span><br><span class="line">        n = len(obstacleGrid[0])</span><br><span class="line"></span><br><span class="line">        if m == 1:</span><br><span class="line">            if 1 in obstacleGrid[0]:</span><br><span class="line">                return 0</span><br><span class="line">            else:</span><br><span class="line">                return 1</span><br><span class="line">        if n == 1:</span><br><span class="line">            for row in obstacleGrid:</span><br><span class="line">                if 1 in row:</span><br><span class="line">                    return 0</span><br><span class="line">            return 1</span><br><span class="line"></span><br><span class="line">        res = [[0 for i in range(n)] for j in range(m)]</span><br><span class="line">        res[0][0] = 1</span><br><span class="line">        for i in range(m):</span><br><span class="line">            for j in range(n):</span><br><span class="line">                if i == 0 and j == 0:</span><br><span class="line">                    continue</span><br><span class="line">                if obstacleGrid[i][j] == 1:</span><br><span class="line">                    res[i][j] = 0</span><br><span class="line">                elif i == 0 and j &gt; 0:</span><br><span class="line">                    res[i][j] = res[i][j-1]</span><br><span class="line">                elif j == 0 and i &gt; 0:</span><br><span class="line">                    res[i][j] = res[i-1][j]</span><br><span class="line">                else:</span><br><span class="line">                    res[i][j] = res[i - 1][j] + res[i][j-1]</span><br><span class="line">        return res[-1][-1]</span><br><span class="line"></span><br><span class="line">if __name__ == &quot;__main__&quot;:</span><br><span class="line">    a = Solution()</span><br><span class="line">    print(a.uniquePathsWithObstacles(obstacleGrid=[[1,0],[0,0]]))</span><br></pre></td></tr></table></figure>
<h2 id="39-组合总和-a-id-39"><a class="header-anchor" href="#39-组合总和-a-id-39"></a>39. 组合总和<a id="39"></a></h2>
<p>状态：不会  <br>
<strong>题目</strong>  <br>
给定一个无重复元素的数组<code>candidates</code>和一个目标数<code>target</code>，找出<code>candidates</code>中所有可以使数字和为<code>target</code>的组合。</p>
<p><code>candidates</code>中的数字可以无限制重复被选取。</p>
<p>说明：<br>
所有数字（包括<code>target</code>）都是正整数。<br>
解集不能包含重复的组合。</p>
<p>示例 1:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">输入: candidates = [2,3,6,7], target = 7,</span><br><span class="line">所求解集为:</span><br><span class="line">[</span><br><span class="line">  [7],</span><br><span class="line">  [2,2,3]</span><br><span class="line">]</span><br></pre></td></tr></table></figure>
<p>示例 2:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">输入: candidates = [2,3,5], target = 8,</span><br><span class="line">所求解集为:</span><br><span class="line">[</span><br><span class="line">  [2,2,2,2],</span><br><span class="line">  [2,3,3],</span><br><span class="line">  [3,5]</span><br><span class="line">]</span><br></pre></td></tr></table></figure>
<p><strong>标准答案</strong>  <br>
主要还是递归，不过递归中加入更多的限制条件。<br>
参考：<a href="https://leetcode-cn.com/problems/combination-sum/solution/hui-su-suan-fa-jian-zhi-python-dai-ma-java-dai-m-2/" target="_blank" rel="noopener">回溯算法+剪枝</a></p>
<p><strong>代码</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> java.util.Stack;</span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">	<span class="keyword">private</span> List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">int</span>[] candidates;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">int</span> len;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">findCombinationSum</span><span class="params">(<span class="keyword">int</span> residue, <span class="keyword">int</span> start, Stack&lt;Integer&gt; pre)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (residue == <span class="number">0</span>) &#123;</span><br><span class="line">			res.add(<span class="keyword">new</span> ArrayList&lt;&gt;(pre));</span><br><span class="line">			<span class="keyword">return</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = start; i &lt; len &amp;&amp; residue - candidates[i] &gt;= <span class="number">0</span>; i++) &#123;</span><br><span class="line">			pre.add(candidates[i]);</span><br><span class="line">			</span><br><span class="line">			findCombinationSum(residue-candidates[i], i, pre);</span><br><span class="line">			pre.pop();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; combinationSum(<span class="keyword">int</span>[] candidates, <span class="keyword">int</span> target)&#123;</span><br><span class="line">		<span class="keyword">int</span> len = candidates.length;</span><br><span class="line">		<span class="keyword">if</span> (len == <span class="number">0</span>) &#123;</span><br><span class="line">			<span class="keyword">return</span> res;</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		Arrays.sort(candidates);</span><br><span class="line">		<span class="keyword">this</span>.len = len;</span><br><span class="line">		<span class="keyword">this</span>.candidates = candidates;</span><br><span class="line">		findCombinationSum(target, <span class="number">0</span>, <span class="keyword">new</span> Stack&lt;&gt;());</span><br><span class="line">		<span class="keyword">return</span> res;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">int</span>[] candidates = &#123;<span class="number">2</span>, <span class="number">3</span>, <span class="number">6</span>, <span class="number">7</span>&#125;;</span><br><span class="line">		<span class="keyword">int</span> target = <span class="number">7</span>;</span><br><span class="line">		Solution solution = <span class="keyword">new</span> Solution();</span><br><span class="line">		List&lt;List&lt;Integer&gt;&gt; combinationSum = solution.combinationSum(candidates, target);</span><br><span class="line">		System.out.println(combinationSum);</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
<h2 id="40-组合总和ii"><a class="header-anchor" href="#40-组合总和ii"></a>40. 组合总和II</h2>
<p>状态：不会  <br>
<strong>题目</strong>  <br>
给定一个数组<code>candidates</code>和一个目标数<code>target</code>，找出<code>candidates</code>中所有可以使数字和为<code>target</code>的组合。</p>
<p><code>candidates</code>中的每个数字在每个组合中只能使用一次。</p>
<p>说明：<br>
所有数字（包括目标数）都是正整数。<br>
解集不能包含重复的组合。</p>
<p>示例 1:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">输入: candidates = [10,1,2,7,6,1,5], target = 8,</span><br><span class="line">所求解集为:</span><br><span class="line">[</span><br><span class="line">  [1, 7],</span><br><span class="line">  [1, 2, 5],</span><br><span class="line">  [2, 6],</span><br><span class="line">  [1, 1, 6]</span><br><span class="line">]</span><br></pre></td></tr></table></figure>
<p>示例 2:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">输入: candidates = [2,5,2,1,2], target = 5,</span><br><span class="line">所求解集为:</span><br><span class="line">[</span><br><span class="line">  [1,2,2],</span><br><span class="line">  [5]</span><br><span class="line">]</span><br></pre></td></tr></table></figure>
<p><strong>标准答案</strong>  <br>
<a href="#39"><code>39. 组合总和</code></a>的衍生版本，主要不同在于每个数字只能使用一次。  <br>
参考自<a href="https://leetcode-cn.com/problems/combination-sum-ii/solution/hui-su-suan-fa-jian-zhi-python-dai-ma-java-dai-m-3/" target="_blank" rel="noopener">liweiwei1419</a>的详细解答。</p>
<p><strong>代码</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> java.util.Stack;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">	<span class="keyword">private</span> List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> ArrayList();</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">int</span>[] candidates;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">int</span> target;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">int</span> len;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">findCombinationSum</span><span class="params">(<span class="keyword">int</span> residue, <span class="keyword">int</span> start, Stack&lt;Integer&gt;pre)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span>(residue == <span class="number">0</span>) &#123;</span><br><span class="line">			res.add(<span class="keyword">new</span> ArrayList&lt;&gt;(pre));</span><br><span class="line">			<span class="keyword">return</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i = start; i &lt; len &amp;&amp; residue - candidates[i] &gt;= <span class="number">0</span>; i++) &#123;</span><br><span class="line">			<span class="keyword">if</span>(i &gt; start &amp;&amp; candidates[i] == candidates[i-<span class="number">1</span>]) &#123;</span><br><span class="line">				<span class="keyword">continue</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			</span><br><span class="line">			pre.add(candidates[i]);</span><br><span class="line">			findCombinationSum(residue-candidates[i], i+<span class="number">1</span>, pre);</span><br><span class="line">			pre.pop();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; combinationSum2(<span class="keyword">int</span>[] candidates, <span class="keyword">int</span> target) &#123;</span><br><span class="line">		<span class="keyword">this</span>.len = candidates.length;</span><br><span class="line">		<span class="keyword">this</span>.candidates = candidates;</span><br><span class="line">		<span class="keyword">if</span>(len == <span class="number">0</span>) &#123;</span><br><span class="line">			<span class="keyword">return</span> res;</span><br><span class="line">		&#125;</span><br><span class="line">		Arrays.sort(candidates);</span><br><span class="line">        findCombinationSum(target, <span class="number">0</span>, <span class="keyword">new</span> Stack&lt;&gt;());</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">int</span>[] candidates = &#123;<span class="number">2</span>, <span class="number">5</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">2</span>&#125;;</span><br><span class="line">		<span class="keyword">int</span> target = <span class="number">5</span>;</span><br><span class="line">		Solution solution = <span class="keyword">new</span> Solution();</span><br><span class="line">		List&lt;List&lt;Integer&gt;&gt; combinationSum2 = solution.combinationSum2(candidates, target);</span><br><span class="line">		System.out.println(combinationSum2);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/Leetcode/" rel="tag"><i class="fa fa-tag"></i> Leetcode</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2019/12/09/JAVA数据库操作神器——Ibatis-1/" rel="next" title="JAVA数据库操作神器——iBATIS">
                <i class="fa fa-chevron-left"></i> JAVA数据库操作神器——iBATIS
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          

  
    <div class="comments" id="comments">
    </div>
  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            Table of Contents
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            Overview
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image" src="/images/avatar.jpg" alt="sunflowerJY">
            
              <p class="site-author-name" itemprop="name">sunflowerJY</p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">15</span>
                  <span class="site-state-item-name">posts</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">6</span>
                  <span class="site-state-item-name">categories</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">17</span>
                  <span class="site-state-item-name">tags</span>
                </a>
              </div>
            

          </nav>

          

          

          
          

          
          

          

        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#leetcode题目"><span class="nav-number">1.</span> <span class="nav-text">Leetcode题目</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#96-不同的二叉搜索树"><span class="nav-number">1.1.</span> <span class="nav-text">96.不同的二叉搜索树</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#413-等差数列划分"><span class="nav-number">1.2.</span> <span class="nav-text">413. 等差数列划分</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#120-三角形最小路径和"><span class="nav-number">1.3.</span> <span class="nav-text">120. 三角形最小路径和</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#62-不同路径-a-id-62"><span class="nav-number">1.4.</span> <span class="nav-text">62. 不同路径</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#712-两个字符串的最小ascii删除和"><span class="nav-number">1.5.</span> <span class="nav-text">712. 两个字符串的最小ASCII删除和</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#647-回文子串"><span class="nav-number">1.6.</span> <span class="nav-text">647. 回文子串</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#303-区域和检索-数组不可变"><span class="nav-number">1.7.</span> <span class="nav-text">303. 区域和检索 - 数组不可变</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#343-整数拆分"><span class="nav-number">1.8.</span> <span class="nav-text">343. 整数拆分</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#638-大礼包"><span class="nav-number">1.9.</span> <span class="nav-text">638. 大礼包</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#312-戳气球"><span class="nav-number">1.10.</span> <span class="nav-text">312. 戳气球</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#740-删除与获得点数"><span class="nav-number">1.11.</span> <span class="nav-text">740.删除与获得点数</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#95-不同的二叉搜索树ii"><span class="nav-number">1.12.</span> <span class="nav-text">95.不同的二叉搜索树II</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#121-买卖股票的最佳时机-a-id-121"><span class="nav-number">1.13.</span> <span class="nav-text">121.买卖股票的最佳时机</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#931-下降路径最小和"><span class="nav-number">1.14.</span> <span class="nav-text">931.下降路径最小和</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#70-爬楼梯"><span class="nav-number">1.15.</span> <span class="nav-text">70.爬楼梯</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#152-乘积最大子序列"><span class="nav-number">1.16.</span> <span class="nav-text">152. 乘积最大子序列</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#122-买卖股票的最佳时机-ii"><span class="nav-number">1.17.</span> <span class="nav-text">122. 买卖股票的最佳时机 II</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#200-岛屿的个数-a-id-200"><span class="nav-number">1.18.</span> <span class="nav-text">200. 岛屿的个数</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#695-岛屿的最大面积-a-id-695"><span class="nav-number">1.19.</span> <span class="nav-text">695. 岛屿的最大面积</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#300-最长上升子序列"><span class="nav-number">1.20.</span> <span class="nav-text">300. 最长上升子序列</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#416-分割等和子集-a-id-beibao"><span class="nav-number">1.21.</span> <span class="nav-text">416. 分割等和子集</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#322-零钱兑换"><span class="nav-number">1.22.</span> <span class="nav-text">322. 零钱兑换</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#377-组合总和-ⅳ-a-id-wanquanbeibao"><span class="nav-number">1.23.</span> <span class="nav-text">377. 组合总和 Ⅳ</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#474-一和零"><span class="nav-number">1.24.</span> <span class="nav-text">474. 一和零</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#139-单词拆分"><span class="nav-number">1.25.</span> <span class="nav-text">139. 单词拆分</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#494-目标和"><span class="nav-number">1.26.</span> <span class="nav-text">494. 目标和</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#547-朋友圈-a-id-547"><span class="nav-number">1.27.</span> <span class="nav-text">547. 朋友圈</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#128-最长连续序列"><span class="nav-number">1.28.</span> <span class="nav-text">128. 最长连续序列</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#130-被围绕的区域"><span class="nav-number">1.29.</span> <span class="nav-text">130. 被围绕的区域</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-无重复字符的最长子串"><span class="nav-number">1.30.</span> <span class="nav-text">3. 无重复字符的最长子串</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#684-冗余连接-a-id-684"><span class="nav-number">1.31.</span> <span class="nav-text">684. 冗余连接</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#685-冗余连接-ii-a-id-685"><span class="nav-number">1.32.</span> <span class="nav-text">685. 冗余连接 II</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#721-账户合并-a-id-721"><span class="nav-number">1.33.</span> <span class="nav-text">721. 账户合并</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#763-划分字母区间-a-id-763"><span class="nav-number">1.34.</span> <span class="nav-text">763. 划分字母区间</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#93-复原ip地址-a-id-93"><span class="nav-number">1.35.</span> <span class="nav-text">93. 复原IP地址</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#393-utf-8-编码验证"><span class="nav-number">1.36.</span> <span class="nav-text">393. UTF-8 编码验证</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#851-喧闹和富有"><span class="nav-number">1.37.</span> <span class="nav-text">851. 喧闹和富有</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#5-最长回文子串"><span class="nav-number">1.38.</span> <span class="nav-text">5. 最长回文子串</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#63-不同路径-ii"><span class="nav-number">1.39.</span> <span class="nav-text">63. 不同路径 II</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#39-组合总和-a-id-39"><span class="nav-number">1.40.</span> <span class="nav-text">39. 组合总和</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#40-组合总和ii"><span class="nav-number">1.41.</span> <span class="nav-text">40. 组合总和II</span></a></li></ol></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
<div class="copyright">&copy; <span itemprop="copyrightYear">2019</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">sunflowerJY</span>

  
</div>
        
<div class="busuanzi-count">
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>

  
    <span class="site-uv">
      <i class="fa fa-user"></i> 访客数
      <span class="busuanzi-value" id="busuanzi_value_site_uv"></span>
      
    </span>
  

  
    <span class="site-pv">
      <i class="fa fa-eye"></i> 访问总量
      <span class="busuanzi-value" id="busuanzi_value_site_pv"></span>
      次
    </span>
  
</div>








        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  


  











  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  

  
  
    <script type="text/javascript" src="/lib/canvas-nest/canvas-nest.min.js"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.4"></script>



  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.4"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.4"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  










  <script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script>
  <script src="//unpkg.com/valine/dist/Valine.min.js"></script>
  
  <script type="text/javascript">
    var GUEST = ['nick','mail','link'];
    var guest = 'nick,mail,link';
    guest = guest.split(',').filter(item=>{
      return GUEST.indexOf(item)>-1;
    });
    new Valine({
        el: '#comments' ,
        verify: false,
        notify: true,
        appId: '2e2V4q593joGFtI52rXklbR9-gzGzoHsz',
        appKey: 'W5tylHFpSUHDMT99AvqdBWmk',
        placeholder: 'ヾﾉ≧∀≦)o来啊，快活啊!',
        avatar:'mm',
        guest_info:guest,
        pageSize:'10' || 10,
    });
  </script>



  

  <script type="text/javascript">
    // Popup Window;
    var isfetched = false;
    var isXml = true;
    // Search DB path;
    var search_path = "search.xml";
    if (search_path.length === 0) {
      search_path = "search.xml";
    } else if (/json$/i.test(search_path)) {
      isXml = false;
    }
    var path = "/" + search_path;
    // monitor main search box;

    var onPopupClose = function (e) {
      $('.popup').hide();
      $('#local-search-input').val('');
      $('.search-result-list').remove();
      $('#no-result').remove();
      $(".local-search-pop-overlay").remove();
      $('body').css('overflow', '');
    }

    function proceedsearch() {
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay"></div>')
        .css('overflow', 'hidden');
      $('.search-popup-overlay').click(onPopupClose);
      $('.popup').toggle();
      var $localSearchInput = $('#local-search-input');
      $localSearchInput.attr("autocapitalize", "none");
      $localSearchInput.attr("autocorrect", "off");
      $localSearchInput.focus();
    }

    // search function;
    var searchFunc = function(path, search_id, content_id) {
      'use strict';

      // start loading animation
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay">' +
          '<div id="search-loading-icon">' +
          '<i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>' +
          '</div>' +
          '</div>')
        .css('overflow', 'hidden');
      $("#search-loading-icon").css('margin', '20% auto 0 auto').css('text-align', 'center');

      $.ajax({
        url: path,
        dataType: isXml ? "xml" : "json",
        async: true,
        success: function(res) {
          // get the contents from search data
          isfetched = true;
          $('.popup').detach().appendTo('.header-inner');
          var datas = isXml ? $("entry", res).map(function() {
            return {
              title: $("title", this).text(),
              content: $("content",this).text(),
              url: $("url" , this).text()
            };
          }).get() : res;
          var input = document.getElementById(search_id);
          var resultContent = document.getElementById(content_id);
          var inputEventFunction = function() {
            var searchText = input.value.trim().toLowerCase();
            var keywords = searchText.split(/[\s\-]+/);
            if (keywords.length > 1) {
              keywords.push(searchText);
            }
            var resultItems = [];
            if (searchText.length > 0) {
              // perform local searching
              datas.forEach(function(data) {
                var isMatch = false;
                var hitCount = 0;
                var searchTextCount = 0;
                var title = data.title.trim();
                var titleInLowerCase = title.toLowerCase();
                var content = data.content.trim().replace(/<[^>]+>/g,"");
                var contentInLowerCase = content.toLowerCase();
                var articleUrl = decodeURIComponent(data.url);
                var indexOfTitle = [];
                var indexOfContent = [];
                // only match articles with not empty titles
                if(title != '') {
                  keywords.forEach(function(keyword) {
                    function getIndexByWord(word, text, caseSensitive) {
                      var wordLen = word.length;
                      if (wordLen === 0) {
                        return [];
                      }
                      var startPosition = 0, position = [], index = [];
                      if (!caseSensitive) {
                        text = text.toLowerCase();
                        word = word.toLowerCase();
                      }
                      while ((position = text.indexOf(word, startPosition)) > -1) {
                        index.push({position: position, word: word});
                        startPosition = position + wordLen;
                      }
                      return index;
                    }

                    indexOfTitle = indexOfTitle.concat(getIndexByWord(keyword, titleInLowerCase, false));
                    indexOfContent = indexOfContent.concat(getIndexByWord(keyword, contentInLowerCase, false));
                  });
                  if (indexOfTitle.length > 0 || indexOfContent.length > 0) {
                    isMatch = true;
                    hitCount = indexOfTitle.length + indexOfContent.length;
                  }
                }

                // show search results

                if (isMatch) {
                  // sort index by position of keyword

                  [indexOfTitle, indexOfContent].forEach(function (index) {
                    index.sort(function (itemLeft, itemRight) {
                      if (itemRight.position !== itemLeft.position) {
                        return itemRight.position - itemLeft.position;
                      } else {
                        return itemLeft.word.length - itemRight.word.length;
                      }
                    });
                  });

                  // merge hits into slices

                  function mergeIntoSlice(text, start, end, index) {
                    var item = index[index.length - 1];
                    var position = item.position;
                    var word = item.word;
                    var hits = [];
                    var searchTextCountInSlice = 0;
                    while (position + word.length <= end && index.length != 0) {
                      if (word === searchText) {
                        searchTextCountInSlice++;
                      }
                      hits.push({position: position, length: word.length});
                      var wordEnd = position + word.length;

                      // move to next position of hit

                      index.pop();
                      while (index.length != 0) {
                        item = index[index.length - 1];
                        position = item.position;
                        word = item.word;
                        if (wordEnd > position) {
                          index.pop();
                        } else {
                          break;
                        }
                      }
                    }
                    searchTextCount += searchTextCountInSlice;
                    return {
                      hits: hits,
                      start: start,
                      end: end,
                      searchTextCount: searchTextCountInSlice
                    };
                  }

                  var slicesOfTitle = [];
                  if (indexOfTitle.length != 0) {
                    slicesOfTitle.push(mergeIntoSlice(title, 0, title.length, indexOfTitle));
                  }

                  var slicesOfContent = [];
                  while (indexOfContent.length != 0) {
                    var item = indexOfContent[indexOfContent.length - 1];
                    var position = item.position;
                    var word = item.word;
                    // cut out 100 characters
                    var start = position - 20;
                    var end = position + 80;
                    if(start < 0){
                      start = 0;
                    }
                    if (end < position + word.length) {
                      end = position + word.length;
                    }
                    if(end > content.length){
                      end = content.length;
                    }
                    slicesOfContent.push(mergeIntoSlice(content, start, end, indexOfContent));
                  }

                  // sort slices in content by search text's count and hits' count

                  slicesOfContent.sort(function (sliceLeft, sliceRight) {
                    if (sliceLeft.searchTextCount !== sliceRight.searchTextCount) {
                      return sliceRight.searchTextCount - sliceLeft.searchTextCount;
                    } else if (sliceLeft.hits.length !== sliceRight.hits.length) {
                      return sliceRight.hits.length - sliceLeft.hits.length;
                    } else {
                      return sliceLeft.start - sliceRight.start;
                    }
                  });

                  // select top N slices in content

                  var upperBound = parseInt('1');
                  if (upperBound >= 0) {
                    slicesOfContent = slicesOfContent.slice(0, upperBound);
                  }

                  // highlight title and content

                  function highlightKeyword(text, slice) {
                    var result = '';
                    var prevEnd = slice.start;
                    slice.hits.forEach(function (hit) {
                      result += text.substring(prevEnd, hit.position);
                      var end = hit.position + hit.length;
                      result += '<b class="search-keyword">' + text.substring(hit.position, end) + '</b>';
                      prevEnd = end;
                    });
                    result += text.substring(prevEnd, slice.end);
                    return result;
                  }

                  var resultItem = '';

                  if (slicesOfTitle.length != 0) {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + highlightKeyword(title, slicesOfTitle[0]) + "</a>";
                  } else {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + title + "</a>";
                  }

                  slicesOfContent.forEach(function (slice) {
                    resultItem += "<a href='" + articleUrl + "'>" +
                      "<p class=\"search-result\">" + highlightKeyword(content, slice) +
                      "...</p>" + "</a>";
                  });

                  resultItem += "</li>";
                  resultItems.push({
                    item: resultItem,
                    searchTextCount: searchTextCount,
                    hitCount: hitCount,
                    id: resultItems.length
                  });
                }
              })
            };
            if (keywords.length === 1 && keywords[0] === "") {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-search fa-5x" /></div>'
            } else if (resultItems.length === 0) {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-frown-o fa-5x" /></div>'
            } else {
              resultItems.sort(function (resultLeft, resultRight) {
                if (resultLeft.searchTextCount !== resultRight.searchTextCount) {
                  return resultRight.searchTextCount - resultLeft.searchTextCount;
                } else if (resultLeft.hitCount !== resultRight.hitCount) {
                  return resultRight.hitCount - resultLeft.hitCount;
                } else {
                  return resultRight.id - resultLeft.id;
                }
              });
              var searchResultList = '<ul class=\"search-result-list\">';
              resultItems.forEach(function (result) {
                searchResultList += result.item;
              })
              searchResultList += "</ul>";
              resultContent.innerHTML = searchResultList;
            }
          }

          if ('auto' === 'auto') {
            input.addEventListener('input', inputEventFunction);
          } else {
            $('.search-icon').click(inputEventFunction);
            input.addEventListener('keypress', function (event) {
              if (event.keyCode === 13) {
                inputEventFunction();
              }
            });
          }

          // remove loading animation
          $(".local-search-pop-overlay").remove();
          $('body').css('overflow', '');

          proceedsearch();
        }
      });
    }

    // handle and trigger popup window;
    $('.popup-trigger').click(function(e) {
      e.stopPropagation();
      if (isfetched === false) {
        searchFunc(path, 'local-search-input', 'local-search-result');
      } else {
        proceedsearch();
      };
    });

    $('.popup-btn-close').click(onPopupClose);
    $('.popup').click(function(e){
      e.stopPropagation();
    });
    $(document).on('keyup', function (event) {
      var shouldDismissSearchPopup = event.which === 27 &&
        $('.search-popup').is(':visible');
      if (shouldDismissSearchPopup) {
        onPopupClose();
      }
    });
  </script>





  

  

  

  
  

  
  
    <script type="text/x-mathjax-config">
      MathJax.Hub.Config({
        tex2jax: {
          inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
          processEscapes: true,
          skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
        }
      });
    </script>

    <script type="text/x-mathjax-config">
      MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax(), i;
        for (i=0; i < all.length; i += 1) {
          all[i].SourceElement().parentNode.className += ' has-jax';
        }
      });
    </script>
    <script type="text/javascript" src="//cdn.bootcss.com/mathjax/2.7.1/latest.js?config=TeX-AMS-MML_HTMLorMML"></script>
  


  

  

<script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"pluginRootPath":"live2dw/","pluginJsPath":"lib/","pluginModelPath":"assets/","model":{"jsonPath":"/live2dw/assets/hijiki.model.json"},"display":{"position":"left","width":80,"height":300,"hOffset":20,"vOffset":-200},"mobile":{"show":true},"log":false,"tagMode":false});</script></body>
</html>
